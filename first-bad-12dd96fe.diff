commit 12dd96fe93826f266f5b4d2c79ce6f0702fa8b22
Author: Matthew Morrone <matthewmorrone1@gmail.com>
Date:   Tue Nov 18 09:00:45 2025 -0500

    Refactor code structure for improved readability and maintainability

diff --git a/app.py b/app.py
index 9d1ccf1..75834c5 100755
--- a/app.py
+++ b/app.py
@@ -7973,14 +7973,8 @@ def _list_performers(search: str | None = None) -> list[dict]:
         rec = _PERFORMERS_CACHE.get(norm, {"name": norm, "tags": []})
         if search and search.lower() not in rec["name"].lower():
             continue
-        # Determine primary image URL if available (registry stores paths relative to root)
-        img_rel = None
-        try:
-            primary = rec.get("image") or (rec.get("images") or [None])[0]
-            if isinstance(primary, str) and primary.strip():
-                img_rel = primary.strip()
-        except Exception:
-            img_rel = None
+        # Resolve image via validated registry primary or slug-based fallback
+        img_rel = _resolve_performer_image_rel(rec.get("name") or norm, rec)
         item = {
             "name": rec["name"],
             "slug": _slugify(rec["name"]),
@@ -8334,7 +8328,15 @@ def performers_images_import(
             if mode.lower() == "copy":
                 dest_dir = _performer_images_store() / slug
                 dest_dir.mkdir(parents=True, exist_ok=True)
-                dest = dest_dir / f.name
+                # Save as slug-based filename to ensure stable references
+                ext_lower = (f.suffix or "").lower() or ".jpg"
+                dest = dest_dir / f"{slug}{ext_lower}"
+                # Ensure uniqueness if file exists
+                if dest.exists():
+                    i = 2
+                    while dest.exists() and i < 100:
+                        dest = dest_dir / f"{slug}-{i}{ext_lower}"
+                        i += 1
                 try:
                     shutil.copy2(str(f), str(dest))
                 except Exception:
@@ -8449,10 +8451,17 @@ def performers_images_upload(
                 _PERFORMERS_CACHE[norm] = {"name": perf_disp, "tags": []}
                 _PERFORMERS_INDEX.setdefault(norm, set())
                 created += 1
-            # Persist file into registry store
+            # Persist file into registry store, saved as slug-based filename
             dest_dir = _performer_images_store() / slug
             dest_dir.mkdir(parents=True, exist_ok=True)
-            dest = dest_dir / basename
+            ext_lower = (Path(basename).suffix or "").lower() or ".jpg"
+            dest = dest_dir / f"{slug}{ext_lower}"
+            # Ensure uniqueness if a prior image exists; append -2, -3, ...
+            if dest.exists():
+                i = 2
+                while dest.exists() and i < 100:
+                    dest = dest_dir / f"{slug}-{i}{ext_lower}"
+                    i += 1
             # Save content
             try:
                 with dest.open("wb") as out:
@@ -8712,11 +8721,11 @@ def performer_image_upload(
         _PERFORMERS_CACHE[norm] = {"name": disp, "tags": []}
         _PERFORMERS_INDEX.setdefault(norm, set())
         created = True
-    # Persist file
+    # Persist file (saved under slug-based filename for consistency)
     dest_dir = _performer_images_store() / slug
     dest_dir.mkdir(parents=True, exist_ok=True)
-    # Ensure unique filename if one exists (avoid silent overwrite confusion)
-    dest = dest_dir / raw_fn
+    # Use slug.ext as base name
+    dest = dest_dir / f"{slug}{ext}"
     if dest.exists():
         stem = dest.stem
         suffix = dest.suffix
@@ -9100,6 +9109,7 @@ def api_performers_graph(
     nodes: list[dict] = []
     paths_by_slug: dict[str, set[str]] = {}
     name_by_slug: dict[str, str] = {}
+    image_by_slug: dict[str, str] = {}
     try:
         # Include both indexed and imported performers; filter by count
         all_norms = set((_PERFORMERS_INDEX or {}).keys()) | set((_PERFORMERS_CACHE or {}).keys())
@@ -9112,7 +9122,14 @@ def api_performers_graph(
                 slug = _slugify(name)
                 name_by_slug[slug] = name
                 paths_by_slug[slug] = paths
-                nodes.append({"id": slug, "name": name, "count": count})
+                # Resolve primary image (validate) or fallback by slug
+                img_rel: str | None = _resolve_performer_image_rel(name, rec)
+                if img_rel:
+                    img_url = f"/files/{img_rel}"
+                    image_by_slug[slug] = img_url
+                    nodes.append({"id": slug, "name": name, "count": count, "image": img_url})
+                else:
+                    nodes.append({"id": slug, "name": name, "count": count})
     except Exception:
         nodes = []
     # Compute edges by intersecting path sets for each pair
@@ -9840,15 +9857,61 @@ def thumbnail_head_canonical(path: str = Query(...)):
 
 
 @api.post("/thumbnail")
-def thumbnail_create(path: str = Query(...), t: Optional[str | float] = Query(default=10), quality: int = Query(default=2), overwrite: bool = Query(default=False), priority: bool = Query(default=False)):
+def thumbnail_create(path: str = Query(...), t: Optional[str | float] = Query(default=10), quality: int = Query(default=2), overwrite: bool = Query(default=False), priority: bool = Query(default=False), smart: bool = Query(default=True)):
     name, directory = _name_and_dir(path)
     video = Path(directory) / name
     _log("thumbnail", f"thumbnail api.create start path={path} t={t} q={quality} ow={int(bool(overwrite))}")
 
+    def _avg_luma(p: Path) -> Optional[float]:
+        try:
+            from PIL import Image  # type: ignore
+            with Image.open(p) as im:
+                g = im.convert("L")
+                # Compute mean luminance (0..255)
+                hist = g.histogram()
+                total = sum(hist)
+                if total <= 0:
+                    return None
+                s = 0
+                for i, c in enumerate(hist):
+                    s += i * c
+                return float(s) / float(total)
+        except Exception:
+            return None
+
     def _do():
         time_spec = str(t) if t is not None else "middle"
         try:
             generate_thumbnail(video, force=bool(overwrite), time_spec=time_spec, quality=int(quality))
+            # Smart fallback: if the frame is too dark, try alternate positions
+            if smart:
+                out = thumbnails_path(video)
+                lum = _avg_luma(out)
+                # Treat very dark frames as black; threshold ~15/255
+                if lum is None or lum < 15.0:
+                    # Probe duration for better alternate timestamps
+                    dur = None
+                    try:
+                        metadata_single(video, force=False)
+                        raw = json.loads(metadata_path(video).read_text())
+                        dur = extract_duration(raw)
+                    except Exception:
+                        dur = None
+                    # Candidate times (seconds); prefer spread across video
+                    candidates: list[float | str] = []
+                    if isinstance(dur, (int, float)) and dur and dur > 8:
+                        frac = [0.15, 0.35, 0.55, 0.75]
+                        candidates = [max(2.0, float(dur) * f) for f in frac]
+                    else:
+                        candidates = [5, 15, 30, 45]
+                    for ct in candidates:
+                        try:
+                            generate_thumbnail(video, force=True, time_spec=ct, quality=int(quality))
+                            lum2 = _avg_luma(out)
+                            if lum2 is not None and lum2 >= 15.0:
+                                break
+                        except Exception:
+                            continue
         except Exception:
             # Fallback: write a stub JPEG so tests/UI can proceed
             out = thumbnails_path(video)
@@ -9885,7 +9948,7 @@ def thumbnail_create(path: str = Query(...), t: Optional[str | float] = Query(de
         raise_api_error(f"thumbnail create failed: {e}", status_code=500)
 
 @api.post("/thumbnail/create/sync")
-def thumbnail_create_sync(path: str = Query(...), t: Optional[str | float] = Query(default=10), quality: int = Query(default=2), overwrite: bool = Query(default=False)):
+def thumbnail_create_sync(path: str = Query(...), t: Optional[str | float] = Query(default=10), quality: int = Query(default=2), overwrite: bool = Query(default=False), smart: bool = Query(default=True)):
     """Synchronously generate a thumbnail and return the JPEG directly."""
     name, directory = _name_and_dir(path)
     video = Path(directory) / name
@@ -9895,6 +9958,45 @@ def thumbnail_create_sync(path: str = Query(...), t: Optional[str | float] = Que
     time_spec = str(t) if t is not None else "middle"
     try:
         generate_thumbnail(video, force=bool(overwrite), time_spec=time_spec, quality=int(quality))
+        if smart:
+            # If dark, try alternates synchronously too
+            outp = thumbnails_path(video)
+            def _avg_luma_local(pth: Path) -> Optional[float]:
+                try:
+                    from PIL import Image  # type: ignore
+                    with Image.open(pth) as im:
+                        g = im.convert("L")
+                        hist = g.histogram(); total = sum(hist)
+                        if total <= 0:
+                            return None
+                        s = 0
+                        for i, c in enumerate(hist):
+                            s += i * c
+                        return float(s) / float(total)
+                except Exception:
+                    return None
+            lum = _avg_luma_local(outp)
+            if lum is None or lum < 15.0:
+                dur = None
+                try:
+                    metadata_single(video, force=False)
+                    raw = json.loads(metadata_path(video).read_text())
+                    dur = extract_duration(raw)
+                except Exception:
+                    dur = None
+                candidates: list[float | str] = []
+                if isinstance(dur, (int, float)) and dur and dur > 8:
+                    candidates = [float(dur) * f for f in (0.2, 0.4, 0.6, 0.8)]
+                else:
+                    candidates = [5, 15, 30, 45]
+                for ct in candidates:
+                    try:
+                        generate_thumbnail(video, force=True, time_spec=ct, quality=int(quality))
+                        lum2 = _avg_luma_local(outp)
+                        if lum2 is not None and lum2 >= 15.0:
+                            break
+                    except Exception:
+                        continue
     except Exception as e:  # noqa: BLE001
         _log("thumbnail", f"thumbnail api.inline fail path={path} err={e}")
         raise_api_error(f"inline thumbnail failed: {e}")
@@ -18518,6 +18620,56 @@ def jobs_status(job_id: str):
     }
     return out
 
+# -----------------
+# Performer image resolution helper
+# -----------------
+def _resolve_performer_image_rel(name: str, rec: Optional[dict]) -> Optional[str]:
+    """Return a relative image path for a performer.
+    Preference order:
+      1) Registry primary image if it exists on disk
+      2) File-system slug fallback: <root>/.artifacts/performer-images/<slug>/<slug>.(jpg|jpeg|png|webp|gif)
+      3) First image file found under the slug directory
+
+    Returns a POSIX relative path from MEDIA_ROOT or None.
+    """
+    try:
+        root_path = Path(STATE.get("root") or Path.cwd()).resolve()
+        slug = _slugify(str(name or rec.get("name") if isinstance(rec, dict) else name) or "")
+        # 1) registry primary (validate exists)
+        img_rel = None
+        try:
+            primary = None
+            if isinstance(rec, dict):
+                primary = rec.get("image") or (rec.get("images") or [None])[0]
+            if isinstance(primary, str) and primary.strip():
+                # Normalize to relative POSIX and existence check
+                p_rel = primary.strip().lstrip("/").replace("\\", "/")
+                p_abs = (root_path / p_rel).resolve()
+                if p_abs.exists() and p_abs.is_file():
+                    img_rel = str(p_abs.relative_to(root_path).as_posix())
+        except Exception:
+            img_rel = None
+        if img_rel:
+            return img_rel
+        # 2) filesystem slug-named file
+        try:
+            perf_dir = _performer_images_store() / slug
+            if perf_dir.exists() and perf_dir.is_dir():
+                exts = [".jpg", ".jpeg", ".png", ".webp", ".gif"]
+                for ext in exts:
+                    cand = perf_dir / f"{slug}{ext}"
+                    if cand.exists() and cand.is_file():
+                        return str(cand.relative_to(root_path).as_posix())
+                # 3) pick first image file in directory
+                for child in sorted(perf_dir.iterdir()):
+                    if child.is_file() and child.suffix.lower() in exts:
+                        return str(child.relative_to(root_path).as_posix())
+        except Exception:
+            pass
+        return None
+    except Exception:
+        return None
+
 
 @app.delete("/jobs/{job_id}")
 def jobs_cancel(job_id: str):
diff --git a/index.css b/index.css
index 3f8ba2d..aa7f142 100755
--- a/index.css
+++ b/index.css
@@ -663,6 +663,19 @@ button.btn-danger {
 
 /* ORIGINAL CONTENT CONTINUES (unreordered beyond critical fixes) */
 
+/* Similar tab assets */
+.similar-row { position: relative; display:grid; grid-template-columns: 84px 1fr; grid-template-rows: auto auto; gap:0; }
+.similar-pct { grid-row:1 / span 2; grid-column:1; display:flex; align-items:center; justify-content:center; font-weight:600; font-size:14px; background: rgba(255,255,255,0.04); border-right:1px solid rgba(255,255,255,0.08); }
+.similar-file { display:grid; grid-template-columns: minmax(140px, 1fr) 110px 200px 72px; align-items:center; padding:4px 8px; gap:12px; border-bottom:1px solid rgba(255,255,255,0.06); }
+.similar-file:last-of-type { border-bottom:none; }
+.similar-file .path { font-size:12px; color: var(--muted,#a0a3ad); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
+.similar-file .thumb-wrap { display:flex; }
+.similar-file .thumb-inline { width:96px; height:54px; background: rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.08); border-radius:4px; overflow:hidden; display:flex; align-items:center; justify-content:center; }
+.similar-file img.thumb { width:100%; height:100%; object-fit:cover; display:block; }
+.similar-file .meta { font-size:12px; color: var(--muted,#a0a3ad); }
+.similar-file .actions { display:flex; justify-content:flex-start; }
+.similar-file .actions .btn-sm { font-size:11px; padding:2px 8px; }
+
 #playerControls .btn-sm {
   height: 20px;
   padding: 1px 5px;
@@ -6769,7 +6782,11 @@ a:focus {
   background: var(--panel);
   border-bottom: 1px solid rgba(255,255,255,0.06);
 }
-#cyContainer {  position: relative;  flex: 1 1 auto;  min-height: 320px; }
+#graph-panel, #graph-panel .graph-panel { height: 100%; display:flex; flex-direction:column; }
+.graph-controls label .control-input[type=number],
+.graph-controls input[type=number] { width:70px; }
+.graph-controls select.control-input { width:130px; }
+#cyContainer {  position: relative;  flex: 1 1 auto;  min-height: 320px; height:100%; }
 #cyGraph { position: absolute; inset: 0; }
 .graph-controls input[type="range"] { width: 140px; }
 #graphTooltip { position: fixed; z-index: 9999; background: rgba(10,12,18,0.96); border: 1px solid rgba(255,255,255,0.12); border-radius: 6px; padding: 8px; box-shadow: 0 8px 22px rgba(0,0,0,.45); max-width: 400px; }
@@ -6778,15 +6795,8 @@ a:focus {
 #graphTooltip .gt-item { display: block; text-decoration: none; color: inherit; font-size: 11px; }
 #graphTooltip .gt-item div { margin-top: 3px; line-height: 1.2; word-break: break-word; }
 #graphTooltip img { width: 100%; height: 60px; object-fit: cover; border-radius: 4px; background: #111a28; }
-#cyContainer {
-  position: relative;
-  flex: 1 1 auto;
-  min-height: 320px;
-}
-#cyGraph {
-  position: absolute;
-  inset: 0;
-}
+#cyContainer { position: relative; flex:1 1 auto; min-height:320px; height:100%; }
+#cyGraph { position:absolute; inset:0; }
 #graphTooltip {
   position: fixed;
   z-index: 9999;
diff --git a/index.html b/index.html
index 570f23e..68e042c 100755
--- a/index.html
+++ b/index.html
@@ -16,6 +16,13 @@
   <script src="https://unpkg.com/cytoscape-fcose@2.2.0/cytoscape-fcose.js"></script>
   <script src="https://unpkg.com/cytoscape-cxtmenu@3.5.0/cytoscape-cxtmenu.js"></script>
   <script src="https://unpkg.com/cytoscape-panzoom@2.5.3/cytoscape-panzoom.js"></script>
+  <!-- Additional layout plugins -->
+  <!-- Optional layouts (avsdf, cise) removed due to CDN MIME issues -->
+  <script src="https://unpkg.com/cytoscape-cola@2.5.1/cytoscape-cola.js"></script>
+  <script src="https://unpkg.com/cytoscape-euler@1.2.1/cytoscape-euler.js"></script>
+  <!-- Removed cytoscape-spread: UMD build throws in browser (Thread undefined) -->
+  <script src="https://unpkg.com/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>
+  <script src="https://unpkg.com/cytoscape-klay@3.1.3/cytoscape-klay.js"></script>
   <script>
     // Apply collapsed class ASAP to avoid post-load reflow when sidebar is persisted collapsed
     try {
@@ -438,27 +445,21 @@
 
   <!-- Manual tag result row template -->
   <template id="manualTagRowTemplate">
-    <div class="manual-result-row flex-row gap-10">
-      <div class="file w-100"></div>
-      <button class="btn-sm apply">Apply</button>
-    </div>
-  </template>
-
-  <!-- Error modal (predeclared to avoid dynamic injection) -->
-  <div id="errorModal" class="modal" hidden>
-    <div class="modal-content modal-content--wide">
-      <div class="modal-header modal-header--spaced">
-        <h3 class="m-0">Job Error</h3>
-
-        <!-- Small directory list item (used by folder picker) -->
-        <template id="dirListItemTemplate">
-          <div class="dir">
-            <div class="icon"></div>
-            <div class="name"></div>
+        <div class="card similar-row">
+          <div class="similar-pct" aria-label="Similarity">—</div>
+          <div class="similar-file file-a" aria-label="File A">
+            <div class="path path-a" title="Path A">—</div>
+            <div class="thumb-wrap"><div class="thumb-inline"><img loading="lazy" decoding="async" class="thumb thumb-a" alt="A" /></div></div>
+            <div class="meta meta-a">Loading…</div>
+            <div class="actions"><button class="btn-sm play-a">Play</button></div>
           </div>
-        </template>
-
-        <!-- Autotag preview row template -->
+          <div class="similar-file file-b" aria-label="File B">
+            <div class="path path-b" title="Path B">—</div>
+            <div class="thumb-wrap"><div class="thumb-inline"><img loading="lazy" decoding="async" class="thumb thumb-b" alt="B" /></div></div>
+            <div class="meta meta-b">Loading…</div>
+            <div class="actions"><button class="btn-sm play-b">Play</button></div>
+          </div>
+        </div>
         <template id="autotagRowTemplate">
           <tr>
             <td class="break file"></td>
@@ -472,6 +473,14 @@
             <td class="cell-time-start"></td>
             <td class="cell-time-end"></td>
             <td class="cell-task"></td>
+            <div class="similar-meta-inline hint-sm mt-6" aria-label="Pair metadata">
+              <div class="meta meta-a">—</div>
+              <div class="meta meta-b">—</div>
+            </div>
+            <div class="similar-meta-inline" aria-label="Metadata summary">
+              <div class="meta meta-a">Loading…</div>
+              <div class="meta meta-b">Loading…</div>
+            </div>
             <td class="cell-file" title=""></td>
             <td class="cell-status"><span class="job-status"></span><span class="job-paused-dot" hidden title="Paused"></span></td>
             <td class="cell-progress">
@@ -722,17 +731,24 @@
             <span id="graphStatus" class="hint-sm" style="opacity:.8;"></span>
             <label class="hint-sm">
               Min videos
-              <input id="graphMinCount" type="number" class="control-input w-120" value="2" min="1" step="1" />
+              <input id="graphMinCount" type="number" class="control-input" value="2" min="1" step="1" />
             </label>
             <label class="hint-sm" title="Minimum number of connections (edges) a performer must have to be shown; > 0 hides isolated nodes">
               Min edges
-              <input id="graphMinEdges" type="number" class="control-input w-120" value="0" min="0" step="1" />
+              <input id="graphMinEdges" type="number" class="control-input" value="0" min="0" step="1" />
             </label>
             <label class="hint-sm">
               Layout
-              <select id="graphLayoutSelect" class="control-input w-120">
+              <select id="graphLayoutSelect" class="control-input">
                 <option value="fcose">fCoSE</option>
                 <option value="cose">CoSE</option>
+                <option value="cola">Cola</option>
+                <option value="euler">Euler</option>
+                <!-- Spread removed due to plugin runtime error -->
+                <option value="dagre">Dagre</option>
+                <option value="klay">Klay</option>
+                <!-- AVSDF and CiSE temporarily disabled -->
+                <option value="concentric">Concentric</option>
                 <option value="circle">Circle</option>
                 <option value="grid">Grid</option>
                 <option value="random">Random</option>
@@ -746,14 +762,7 @@
               Node repulsion
               <input id="graphRepulsion" type="range" min="1000" max="120000" step="1000" value="50000" />
             </label>
-            <label class="hint-sm" title="Render edges as straight lines">
-              <input id="graphStraightEdges" type="checkbox" checked />
-              Straight lines
-            </label>
-            <input id="graphSearchInput" class="control-input" placeholder="Search performer…" />
-            <button id="graphRefreshBtn" class="btn-sm">Refresh</button>
             <div class="ml-auto"></div>
-            <button id="graphNeighborhoodBtn" class="btn-sm" title="Reveal neighborhood of matches/selection">Reveal Neighborhood</button>
             <button id="graphClearBtn" class="btn-sm" title="Clear filters and highlights">Clear</button>
             <button id="graphFitBtn" class="btn-sm" title="Fit all">Fit</button>
           </div>
@@ -1295,6 +1304,7 @@
             <button id="performerRenameBtn" class="btn-sm" title="Rename selected" disabled>Rename</button>
             <button id="performerDeleteBtn" class="btn-sm" title="Delete selected" disabled>Delete</button>
             <button id="performerAutoMatchBtn" class="btn-sm" title="Auto‑match performers from filenames">Auto‑Match</button>
+            <button id="performersDetectFacesBtn" class="btn-sm" title="Detect faces for performer images and persist boxes" aria-label="Detect faces for performer images">Detect Faces</button>
           </div>
           <div id="performerDropZone" role="button" tabindex="0" aria-label="Import performers" class="performer-dropzone">
             <strong class="pdz-title">Unified Import</strong>
@@ -1447,17 +1457,22 @@
       <!-- Template: Similar row (pair) -->
       <template id="similarRowTemplate">
         <div class="card similar-row">
-          <div class="row jc-between ai-center">
+          <div class="row jc-between ai-center similar-row__head">
             <strong class="similar-title">—</strong>
+            <div class="hint-sm mt-6">
+              <div class="path-a"></div>
+              <div class="path-b"></div>
+            </div>
+            <div class="thumbs-inline row gap-8" aria-label="Pair thumbnails">
+              <div class="thumb-inline"><img loading="lazy" decoding="async" class="thumb thumb-a" alt="A" /></div>
+              <div class="thumb-inline"><img loading="lazy" decoding="async" class="thumb thumb-b" alt="B" /></div>
+            </div>
             <div class="row gap-10">
               <button class="btn-sm play-a">Play A</button>
               <button class="btn-sm play-b">Play B</button>
             </div>
           </div>
-          <div class="hint-sm mt-6">
-            <div class="path-a"></div>
-            <div class="path-b"></div>
-          </div>
+
         </div>
       </template>
 
diff --git a/index.js b/index.js
index 7f4b945..c7f77cc 100755
--- a/index.js
+++ b/index.js
@@ -54,7 +54,7 @@ function debounce(fn, wait = 120) {
   };
 }
 
-// DOM visibility helpers
+  // DOM visibility helpers
 function hide(el) {
   if (!el) return;
   el.classList.add('hidden');
@@ -176,6 +176,10 @@ function setLocalStorageItem(key, value, opts = null) {
       case 'string':
       default: stored = value == null ? '' : String(value); break;
     }
+    const metaWrap = document.createElement('div'); metaWrap.className = 'similar-meta-inline';
+    const ma = document.createElement('div'); ma.className = 'meta meta-a'; ma.textContent = 'Loading…';
+    const mb = document.createElement('div'); mb.className = 'meta meta-b'; mb.textContent = 'Loading…';
+    metaWrap.appendChild(ma); metaWrap.appendChild(mb); rowEl.appendChild(metaWrap);
     localStorage.setItem(key, stored);
     return true;
   }
@@ -392,7 +396,7 @@ const showToast = (message, type) => {
   }
   catch (_) { }
 };
-const grid = document.getElementById('grid');
+let grid = null;
 try { devLog('info', 'app', 'script loaded build=reset-debug-1', {ts: Date.now()}); }
 catch (_) {}
 
@@ -568,18 +572,46 @@ document.addEventListener('click', (e) => {
 });
 try { window.resetPlayer = resetPlayer; }
 catch (_) {}
-const statusEl = document.getElementById('status');
-const spinner = document.getElementById('spinner');
-const refreshBtn = document.getElementById('refresh');
-const folderInput = document.getElementById('folderInput');
+// Library UI element references (initialized after DOM ready to avoid null refs in remote/slow loading scenarios)
+let statusEl = null;
+let spinner = null;
+let refreshBtn = null;
+let folderInput = null;
 // Grid controls (unified search input: plain text, #tag, @performer)
-const unifiedInput = document.getElementById('libraryUnifiedInput');
-const unifiedChipsEl = document.getElementById('libraryUnifiedChips');
-const randomPlayBtn = document.getElementById('randomPlayBtn');
-const randomAutoBtn = document.getElementById('randomAutoBtn');
-const sortSelect = document.getElementById('sortSelect');
-const orderToggle = document.getElementById('orderToggle');
-const clearFiltersTopBtn = document.getElementById('clearFiltersTopBtn');
+let unifiedInput = null;
+let unifiedChipsEl = null;
+let randomPlayBtn = null;
+let randomAutoBtn = null;
+let sortSelect = null;
+let orderToggle = null;
+let clearFiltersTopBtn = null;
+
+// Template cache (initialized with other elements)
+let cardTemplate = null;
+let dirTemplate = null;
+
+// Initialize library UI elements once DOM is ready
+function initLibraryElements() {
+  if (statusEl) return; // Already initialized
+  statusEl = document.getElementById('status');
+  spinner = document.getElementById('spinner');
+  refreshBtn = document.getElementById('refresh');
+  folderInput = document.getElementById('folderInput');
+  unifiedInput = document.getElementById('libraryUnifiedInput');
+  unifiedChipsEl = document.getElementById('libraryUnifiedChips');
+  randomPlayBtn = document.getElementById('randomPlayBtn');
+  randomAutoBtn = document.getElementById('randomAutoBtn');
+  sortSelect = document.getElementById('sortSelect');
+  orderToggle = document.getElementById('orderToggle');
+  clearFiltersTopBtn = document.getElementById('clearFiltersTopBtn');
+  prevBtn = document.getElementById('prevBtn');
+  nextBtn = document.getElementById('nextBtn');
+  pageInfo = document.getElementById('pageInfo');
+  grid = document.getElementById('grid');
+  cardTemplate = document.getElementById('cardTemplate');
+  dirTemplate = document.getElementById('dirTemplate');
+}
+
 // Sorting order helpers: default to ASC for name, DESC otherwise
 function syncOrderToggleArrow() {
   if (!orderToggle) return;
@@ -603,9 +635,9 @@ if (orderToggle && !orderToggle.dataset.order) {
   applyDefaultOrderForSort(true);
 }
 const densitySlider = document.getElementById('densitySlider');
-const prevBtn = document.getElementById('prevBtn');
-const nextBtn = document.getElementById('nextBtn');
-const pageInfo = document.getElementById('pageInfo');
+let prevBtn = null;
+let nextBtn = null;
+let pageInfo = null;
 // Image adjustment controls (video filters)
 const adjBrightness = document.getElementById('adjBrightness');
 const adjContrast = document.getElementById('adjContrast');
@@ -996,8 +1028,8 @@ function stopAllTilePreviews(exceptTile) {
   catch (_) { }
 }
 function videoCard(v) {
-  const template = document.getElementById('cardTemplate');
-  const el = template.content.cloneNode(true).querySelector('.card');
+  if (!cardTemplate) return document.createElement('div'); // Fallback if template not ready
+  const el = cardTemplate.content.cloneNode(true).querySelector('.card');
   // Resolve thumbnail URL: prefer payload-provided URL; fall back to canonical endpoint
   const imgSrc = (v && (v.thumbnail || v.thumb || v.thumbnail_url))
     ? (v.thumbnail || v.thumb || v.thumbnail_url)
@@ -1470,8 +1502,8 @@ if (!window.__tileIO) {
   catch (_) { }
 }
 function dirCard(d) {
-  const template = document.getElementById('dirTemplate');
-  const el = template.content.cloneNode(true).querySelector('.card');
+  if (!dirTemplate) return document.createElement('div'); // Fallback if template not ready
+  const el = dirTemplate.content.cloneNode(true).querySelector('.card');
   const name = d.name || String(d);
   const dpath = d.path || name;
   el.querySelector('.dir-name').textContent = name;
@@ -1492,6 +1524,7 @@ function dirCard(d) {
   return el;
 }
 function currentPath() {
+  if (!folderInput) return '';
   const v = (folderInput.value || '').trim();
   // When the input contains an absolute path (root), do not treat it as a relative folder
   if (isAbsolutePath(v)) return '';
@@ -1500,6 +1533,9 @@ function currentPath() {
 let __libLoading = false;
 let __libReloadRequested = false;
 async function loadLibrary() {
+  // Ensure UI elements are initialized (safe to call multiple times)
+  initLibraryElements();
+
   // Run only when Library tab is active; otherwise do nothing
   try {
     if (!window.tabSystem || window.tabSystem.getActiveTab() !== 'library') {
@@ -1618,8 +1654,8 @@ async function loadLibrary() {
       try { return (sortState && sortState.id && SERVER_SORT_MAP[sortState.id]) ? SERVER_SORT_MAP[sortState.id] : null; }
       catch(_) { return null; }
     })();
-    params.set('sort', overrideFromSortState || (sortSelect.value || 'date'));
-    params.set('order', orderToggle.dataset.order || 'desc');
+    params.set('sort', overrideFromSortState || (sortSelect ? (sortSelect.value || 'date') : 'date'));
+    params.set('order', orderToggle ? (orderToggle.dataset.order || 'desc') : 'desc');
     // Resolution filter
     const resSel = document.getElementById('resSelect');
     const resVal = resSel ? String(resSel.value || '') : '';
@@ -1627,7 +1663,7 @@ async function loadLibrary() {
     // Add search and filter parameters
     const searchVal = computeSearchVal();
     if (searchVal) params.set('search', searchVal);
-    const val = (folderInput.value || '').trim();
+    const val = folderInput ? ((folderInput.value || '').trim()) : '';
     const p = currentPath();
     // Only set a relative path; ignore absolute values (those represent the root itself)
     if (val && !isAbsolutePath(val) && p) params.set('path', p);
@@ -1736,24 +1772,26 @@ async function loadLibrary() {
     if (infiniteScrollEnabled) {
       const effectiveSize = stablePageSize || applyColumnsAndComputePageSize();
       const shown = Math.min(totalFiles, currentPage * effectiveSize);
-      pageInfo.textContent = `${shown} of ${totalFiles}`;
-      prevBtn.disabled = true;
-      nextBtn.disabled = true;
+      if (pageInfo) pageInfo.textContent = `${shown} of ${totalFiles}`;
+      if (prevBtn) prevBtn.disabled = true;
+      if (nextBtn) nextBtn.disabled = true;
     }
     else {
-      pageInfo.textContent = `Page ${currentPage} of ${totalPages} (${totalFiles} files)`;
-      prevBtn.disabled = currentPage <= 1;
-      nextBtn.disabled = currentPage >= totalPages;
+      if (pageInfo) pageInfo.textContent = `Page ${currentPage} of ${totalPages} (${totalFiles} files)`;
+      if (prevBtn) prevBtn.disabled = currentPage <= 1;
+      if (nextBtn) nextBtn.disabled = currentPage >= totalPages;
     }
     if (!infiniteScrollEnabled || !isAppend) {
-      grid.innerHTML = '';
+      if (grid) grid.innerHTML = '';
     }
   if (files.length === 0) {
       // When searching, do not auto-fill from subfolders;
       // show no results instead
       if (dirs.length > 0 && !searchVal) {
         // Render folders first for navigation
-        for (const d of dirs) grid.appendChild(dirCard(d));
+        if (grid) {
+          for (const d of dirs) grid.appendChild(dirCard(d));
+        }
         // Then fetch videos from up to N subfolders, respecting current sort/order
         const MAX_DIRS = 8;
         const MAX_TILES = 60;
@@ -1811,10 +1849,12 @@ async function loadLibrary() {
         }
         // Render up to MAX_TILES
         let shown = 0;
-        for (const f of combined) {
-          if (shown >= MAX_TILES) break;
-          grid.appendChild(videoCard(f));
-          shown++;
+        if (grid) {
+          for (const f of combined) {
+            if (shown >= MAX_TILES) break;
+            grid.appendChild(videoCard(f));
+            shown++;
+          }
         }
         hide(spinner);
         show(grid);
@@ -1822,7 +1862,9 @@ async function loadLibrary() {
       }
       else {
         hide(spinner);
-        statusEl.className = files.length === 0 && searchVal ? 'empty' : 'empty';
+        if (statusEl) {
+          statusEl.className = files.length === 0 && searchVal ? 'empty' : 'empty';
+        }
   // Try a one-shot relaxed fetch: drop resolution and search filters to populate some content
   // Skip when tag or performer chips are active (user expects exact matches)
   if (!searchVal && (!Array.isArray(libraryTagFilters) || libraryTagFilters.length === 0) && (!Array.isArray(libraryPerformerFilters) || libraryPerformerFilters.length === 0)) {
@@ -1832,9 +1874,9 @@ async function loadLibrary() {
             sp2.set('page_size', String(Math.max(24, applyColumnsAndComputePageSize() || 24)));
             {
               const override2 = (sortState && sortState.id && SERVER_SORT_MAP[sortState.id]) ? SERVER_SORT_MAP[sortState.id] : null;
-              sp2.set('sort', override2 || (sortSelect.value || 'date'));
+              sp2.set('sort', override2 || (sortSelect ? (sortSelect.value || 'date') : 'date'));
             }
-            sp2.set('order', orderToggle.dataset.order || 'desc');
+            sp2.set('order', orderToggle ? (orderToggle.dataset.order || 'desc') : 'desc');
             const u2 = '/api/library?' + sp2.toString();
             const r2 = await fetch(u2, { headers: { Accept: 'application/json' } });
             if (r2.ok) {
@@ -1845,11 +1887,13 @@ async function loadLibrary() {
               else d2 = { files: [] };
               const f2 = Array.isArray(d2.files) ? d2.files : [];
               if (f2.length) {
-                grid.innerHTML = '';
-                const nodes2 = f2.slice(0, Math.max(24, applyColumnsAndComputePageSize() || 24)).map(videoCard);
-                const frag2 = document.createDocumentFragment();
-                nodes2.forEach((n) => frag2.appendChild(n));
-                grid.appendChild(frag2);
+                if (grid) {
+                  grid.innerHTML = '';
+                  const nodes2 = f2.slice(0, Math.max(24, applyColumnsAndComputePageSize() || 24)).map(videoCard);
+                  const frag2 = document.createDocumentFragment();
+                  nodes2.forEach((n) => frag2.appendChild(n));
+                  grid.appendChild(frag2);
+                }
                 hide(statusEl);
                 show(grid);
                 return;
@@ -1893,8 +1937,10 @@ async function loadLibrary() {
           const msg = searchVal ? 'No results match your search.' : 'No videos found.';
           const chips = hasFilters ? `<div class="empty-filters" aria-label="Active filters">${activeFilters.map((f) => `<span class="empty-chip">${f}</span>`).join('')}</div>` : '';
           const btn = hasFilters ? `<div class="mt-12"><button id="clearFiltersBtn" class="btn-sm" type="button" aria-label="Clear filters">Clear filters</button></div>` : '';
-          statusEl.innerHTML = `<div class="empty-state">${msg}${chips}${btn}</div>`;
-          showAs(statusEl, 'block');
+          if (statusEl) {
+            statusEl.innerHTML = `<div class="empty-state">${msg}${chips}${btn}</div>`;
+            showAs(statusEl, 'block');
+          }
           // Wire the button once
           const clearBtn = document.getElementById('clearFiltersBtn');
           if (clearBtn && !clearBtn._wired) {
@@ -1921,8 +1967,10 @@ async function loadLibrary() {
           }
         }
         catch (__) {
-          statusEl.textContent = searchVal ? 'No results match your search.' : 'No videos found.';
-          showAs(statusEl, 'block');
+          if (statusEl) {
+            statusEl.textContent = searchVal ? 'No results match your search.' : 'No videos found.';
+            showAs(statusEl, 'block');
+          }
         }
         hide(grid);
         return;
@@ -1955,16 +2003,16 @@ async function loadLibrary() {
     hide(statusEl);
     if (!isAppend) hide(spinner);
     if (!infiniteScrollEnabled || currentPage === 1) {
-      grid.innerHTML = '';
+      if (grid) grid.innerHTML = '';
     }
     // Mark insertion pending so infinite scroll won't trigger another page mid-insert
     if (!infiniteScrollPendingInsertion) {
       infiniteScrollPendingInsertion = new Promise((resolve) => {
-        grid._resolveInsertion = resolve;
+        if (grid) grid._resolveInsertion = resolve;
       });
     }
     function finishInsertion() {
-      if (grid._resolveInsertion) {
+      if (grid && grid._resolveInsertion) {
         try {
           grid._resolveInsertion();
         }
@@ -1979,10 +2027,10 @@ async function loadLibrary() {
       for (; i < nodes.length && i < start + BATCH; i++) {
         frag.appendChild(nodes[i]);
       }
-      grid.appendChild(frag);
+      if (grid) grid.appendChild(frag);
       // Ensure initially visible cards get their metadata overlays immediately (e.g., 1080p labels)
       try {
-        const cards = Array.from(grid.querySelectorAll('.card'));
+        const cards = grid ? Array.from(grid.querySelectorAll('.card')) : [];
         const vh = (typeof window !== 'undefined') ? window.innerHeight : 0;
         const computeMeta = window.__computeTileMetadata || null;
         if (computeMeta && vh) {
@@ -2004,7 +2052,7 @@ async function loadLibrary() {
       else {
         // Finished
         requestAnimationFrame(() => {
-          const c = grid.querySelector('.card');
+          const c = grid ? grid.querySelector('.card') : null;
           if (c) {
             const h = c.getBoundingClientRect().height;
             if (h && isFinite(h) && h > 50) {
@@ -2031,7 +2079,7 @@ async function loadLibrary() {
           }
         });
       }
-      if (grid.classList.contains('hidden')) show(grid);
+      if (grid && grid.classList.contains('hidden')) show(grid);
       if (infiniteScrollEnabled) setupInfiniteScrollSentinel();
       if (infiniteScrollSentinel) infiniteScrollSentinel.textContent = '';
       // No eager chain trigger here (strict bottom-only mode).
@@ -2039,11 +2087,11 @@ async function loadLibrary() {
     if (nodes.length <= BATCH) {
       const frag = document.createDocumentFragment();
       nodes.forEach((n) => frag.appendChild(n));
-      grid.appendChild(frag);
+      if (grid) grid.appendChild(frag);
       show(grid);
       // One-shot immediate metadata for visible cards
       try {
-        const cards = Array.from(grid.querySelectorAll('.card'));
+        const cards = grid ? Array.from(grid.querySelectorAll('.card')) : [];
         const vh = (typeof window !== 'undefined') ? window.innerHeight : 0;
         const computeMeta = window.__computeTileMetadata || null;
         if (computeMeta && vh) {
@@ -2083,9 +2131,11 @@ async function loadLibrary() {
   catch (e) {
     console.error('Library loading error:', e);
     hide(spinner);
-    statusEl.className = 'error';
-    statusEl.textContent = 'Failed to load library.';
-    showAs(statusEl, 'block');
+    if (statusEl) {
+      statusEl.className = 'error';
+      statusEl.textContent = 'Failed to load library.';
+      showAs(statusEl, 'block');
+    }
     hide(grid);
   }
   finally {
@@ -2212,7 +2262,8 @@ async function loadLibrary() {
   if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init, {once: true});
   else init();
 })();
-refreshBtn.addEventListener('click', loadLibrary);
+// Guard in case script executes before body parsed (script is in <head>)
+if (refreshBtn) refreshBtn.addEventListener('click', loadLibrary);
 if (randomPlayBtn) {
   randomPlayBtn.addEventListener('click', async () => {
     try {
@@ -2660,10 +2711,31 @@ function applyLibraryStateFromUrl() {
   catch (_) { }
 }
 // Apply URL state once on load and when navigating history
-window.addEventListener('DOMContentLoaded', () => {
-  try { applyLibraryStateFromUrl(); currentPage = 1; loadLibrary(); }
+function initializeLibrary() {
+  try {
+    initLibraryElements(); // Initialize UI elements first
+    applyLibraryStateFromUrl();
+    currentPage = 1;
+    loadLibrary();
+  }
   catch (_) {}
-});
+}
+
+// Register library initialization with lazy tab system
+// This ensures it runs only when the library tab is active
+if (typeof window.__LazyTabs !== 'undefined') {
+  window.__LazyTabs.register('library', initializeLibrary);
+} else {
+  // Fallback: wait for lazy tabs to be available
+  const registerWhenReady = () => {
+    if (typeof window.__LazyTabs !== 'undefined') {
+      window.__LazyTabs.register('library', initializeLibrary);
+    } else {
+      setTimeout(registerWhenReady, 50);
+    }
+  };
+  registerWhenReady();
+}
 window.addEventListener('popstate', () => {
   try { applyLibraryStateFromUrl(); currentPage = 1; loadLibrary(); }
   catch (_) {}
@@ -2815,15 +2887,17 @@ if (unifiedInput) {
     updateClearFiltersBtnState();
   });
 }
-sortSelect.addEventListener('change', () => {
-  // Reset to sensible default per changed sort (ASC for name, DESC otherwise) regardless of prior user-set order
-  applyDefaultOrderForSort(true);
-  // Clear the sticky userSet so future clicks re-establish intent on the new sort
-  if (orderToggle) delete orderToggle.dataset.userSet;
-  currentPage = 1;
-  loadLibrary();
-  updateClearFiltersBtnState();
-});
+if (sortSelect) {
+  sortSelect.addEventListener('change', () => {
+    // Reset to sensible default per changed sort (ASC for name, DESC otherwise) regardless of prior user-set order
+    applyDefaultOrderForSort(true);
+    // Clear the sticky userSet so future clicks re-establish intent on the new sort
+    if (orderToggle) delete orderToggle.dataset.userSet;
+    currentPage = 1;
+    loadLibrary();
+    updateClearFiltersBtnState();
+  });
+}
 // Wire up sidebar artifact generation buttons
 function getSelectedFilePath() {
   // Prefer the actively playing path from the Player, if available
@@ -2906,25 +2980,36 @@ function resolveArtifactRequest(artifact, filePath) {
   // Normalize common aliases
   const normMap = {
     meta: 'metadata',
+    chapter: 'markers',
     chapters: 'markers',
+    scene: 'markers',
     scenes: 'markers',
+    marker: 'markers',
     markers: 'markers',
-    thumb: 'thumbnail',
-    thumbnail: 'thumbnail',
+    thumb: 'thumbnails',
+    thumbs: 'thumbnails',
+    thumbnail: 'thumbnails',
+    thumbnails: 'thumbnails',
     preview: 'preview',
     previews: 'preview',
     sprite: 'sprites',
     sprites: 'sprites',
+    sub: 'subtitles',
     subs: 'subtitles',
+    subtitle: 'subtitles',
     subtitles: 'subtitles',
     heat: 'heatmaps',
     heatmap: 'heatmaps',
     heatmaps: 'heatmaps',
+    face: 'faces',
     faces: 'faces',
     phash: 'phash',
-    waveform: 'waveform',
     wave: 'waveform',
-    motion: 'motion',
+    waves: 'waveform',
+    waveform: 'waveforms',
+    waveforms: 'waveforms',
+    motion: 'motions',
+    motions: 'motions',
   };
   const k = normMap[a] || a;
   switch (k) {
@@ -3228,15 +3313,17 @@ function pollArtifactStatusAndUpdateChip(path, chipKey, chipEl) {
     }
   }, intervalMs);
 }
-orderToggle.addEventListener('click', () => {
-  // Mark that the user explicitly chose an order; future sort changes won't auto-reset it
-  orderToggle.dataset.userSet = '1';
-  const isDesc = orderToggle.dataset.order === 'desc';
-  orderToggle.dataset.order = isDesc ? 'asc' : 'desc';
-  orderToggle.textContent = isDesc ? '▲' : '▼';
-  currentPage = 1;
-  loadLibrary();
-});
+if (orderToggle) {
+  orderToggle.addEventListener('click', () => {
+    // Mark that the user explicitly chose an order; future sort changes won't auto-reset it
+    orderToggle.dataset.userSet = '1';
+    const isDesc = orderToggle.dataset.order === 'desc';
+    orderToggle.dataset.order = isDesc ? 'asc' : 'desc';
+    orderToggle.textContent = isDesc ? '▲' : '▼';
+    currentPage = 1;
+    loadLibrary();
+  });
+}
 // Resolution filter change
 const resSelect = document.getElementById('resSelect');
 if (resSelect) {
@@ -3252,38 +3339,44 @@ if (resSelect) {
   });
 }
 // Pagination
-prevBtn.addEventListener('click', () => {
-  if (currentPage > 1) {
-    currentPage--;
-    loadLibrary();
-  }
-});
-nextBtn.addEventListener('click', () => {
-  if (currentPage < totalPages) {
-    currentPage++;
-    loadLibrary();
-  }
-});
+if (prevBtn) {
+  prevBtn.addEventListener('click', () => {
+    if (currentPage > 1) {
+      currentPage--;
+      loadLibrary();
+    }
+  });
+}
+if (nextBtn) {
+  nextBtn.addEventListener('click', () => {
+    if (currentPage < totalPages) {
+      currentPage++;
+      loadLibrary();
+    }
+  });
+}
 // Density slider
-densitySlider.addEventListener('input', () => {
-  currentDensity = parseInt(densitySlider.value);
-  updateDensity();
-  // Mark that this reload is due to a density change so we can bypass the
-  // initial small-page cap; do not auto-fill additional pages.
-  densityReloadPending = true;
-  autoFillAfterLayoutChange = false;
-  autoFillAfterLayoutChangeBudget = 2; // allow up to 2 extra pages to create overflow
-  // Reset last trigger state to allow new bottom checks at the new height; keep
-  // userScrolled=false so we only load after actual user interaction.
-  infiniteScrollLastTriggerHeight = 0;
-  infiniteScrollUserScrolled = false;
-  try { window.__INF_LAST_LOAD_AT = Date.now(); }
-  catch (_) {}
-  // Clean up any existing sentinel before reloading.
-  teardownInfiniteScroll();
-  currentPage = 1;
-  loadLibrary();
-});
+if (densitySlider) {
+  densitySlider.addEventListener('input', () => {
+    currentDensity = parseInt(densitySlider.value);
+    updateDensity();
+    // Mark that this reload is due to a density change so we can bypass the
+    // initial small-page cap; do not auto-fill additional pages.
+    densityReloadPending = true;
+    autoFillAfterLayoutChange = false;
+    autoFillAfterLayoutChangeBudget = 2; // allow up to 2 extra pages to create overflow
+    // Reset last trigger state to allow new bottom checks at the new height; keep
+    // userScrolled=false so we only load after actual user interaction.
+    infiniteScrollLastTriggerHeight = 0;
+    infiniteScrollUserScrolled = false;
+    try { window.__INF_LAST_LOAD_AT = Date.now(); }
+    catch (_) {}
+    // Clean up any existing sentinel before reloading.
+    teardownInfiniteScroll();
+    currentPage = 1;
+    loadLibrary();
+  });
+}
 // Apply density once on startup so initial load uses correct columns
 updateDensity();
 // Settings wiring for video previews (canonical key 'setting.preview')
@@ -3750,7 +3843,9 @@ function wireSettings() {
 }
 // (Removed: simple Enter handler;
 // replaced below with unified behavior)
-folderInput.addEventListener('dblclick', () => openFolderPicker());
+if (folderInput) {
+  folderInput.addEventListener('dblclick', () => openFolderPicker());
+}
 document.addEventListener('visibilitychange', () => {
   if (document.visibilityState === 'visible') {
     loadLibrary();
@@ -3787,7 +3882,7 @@ window.addEventListener('load', () => {
     }
     catch (_) { }
     finally {
-      folderInput.value = '';
+      if (folderInput) folderInput.value = '';
       loadLibrary();
     }
   })();
@@ -3986,6 +4081,7 @@ function enforceGridSideSpacing() {
   // Only operate when library panel is active
   const libPanel = document.getElementById('library-panel');
   if (libPanel && libPanel.hasAttribute('hidden')) return;
+  if (!grid) return;
   // Reset first so we measure true overflow baseline
   grid.style.marginLeft = '0px';
   grid.style.marginRight = '0px';
@@ -4144,21 +4240,25 @@ document.addEventListener('click', (e) => {
   }
 });
 // Selection controls
-selectAllBtn.addEventListener('click', () => {
-  document.querySelectorAll('.card[data-path]').forEach((card) => {
-    const path = card.dataset.path;
-    if (path) selectedItems.add(path);
+if (selectAllBtn) {
+  selectAllBtn.addEventListener('click', () => {
+    document.querySelectorAll('.card[data-path]').forEach((card) => {
+      const path = card.dataset.path;
+      if (path) selectedItems.add(path);
+    });
+    updateSelectionUI();
+    document.querySelectorAll('.card-checkbox')
+    .forEach((cb) => cb.classList.add('checked'));
   });
-  updateSelectionUI();
-  document.querySelectorAll('.card-checkbox')
-  .forEach((cb) => cb.classList.add('checked'));
-});
-selectNoneBtn.addEventListener('click', () => {
-  selectedItems.clear();
-  updateSelectionUI();
-  document.querySelectorAll('.card-checkbox')
-  .forEach((cb) => cb.classList.remove('checked'));
-});
+}
+if (selectNoneBtn) {
+  selectNoneBtn.addEventListener('click', () => {
+    selectedItems.clear();
+    updateSelectionUI();
+    document.querySelectorAll('.card-checkbox')
+    .forEach((cb) => cb.classList.remove('checked'));
+  });
+}
 
 // Bulk edit actions for selected items
 if (bulkEditBtn && bulkEditPanel && bulkValueInput && bulkApplyBtn) {
@@ -4736,22 +4836,24 @@ async function setRoot(val) {
   }
 }
 // Single-input behavior: Enter applies relative browse or sets root if absolute
-folderInput.addEventListener('keydown', async (e) => {
-  if (e.key !== 'Enter') return;
-  const val = (folderInput.value || '').trim();
-  currentPage = 1;
-  // Reset to first page when changing folders
-  if (!val) {
-    await loadLibrary();
-    return;
-  }
-  if (isAbsolutePath(val)) {
-    await setRoot(val);
-  }
-  else {
-    await loadLibrary();
-  }
-});
+if (folderInput) {
+  folderInput.addEventListener('keydown', async (e) => {
+    if (e.key !== 'Enter') return;
+    const val = (folderInput.value || '').trim();
+    currentPage = 1;
+    // Reset to first page when changing folders
+    if (!val) {
+      await loadLibrary();
+      return;
+    }
+    if (isAbsolutePath(val)) {
+      await setRoot(val);
+    }
+    else {
+      await loadLibrary();
+    }
+  });
+}
 // Optional pick root button (present only in Settings panel after header removal)
 const pickRootBtn = document.getElementById('pickRootBtn');
 if (pickRootBtn) {
@@ -6753,9 +6855,9 @@ function setupListTab() {
       filesCache = Array.isArray(data.files) ? data.files : [];
       total = Number(data.total_files || filesCache.length || 0);
       listClientAllMode = false;
-  renderHead();
-  renderBody(filesCache);
-  applyColumnWidths();
+      renderHead();
+      renderBody(filesCache);
+      applyColumnWidths();
       // Auto-size visible columns once (first-render)
       try {
         if (!getLocalStorageItem(AUTOSIZED_ONCE_LS_KEY)) {
@@ -6946,13 +7048,50 @@ function setupSimilarTab() {
       catch (_) {
         directory = '';
       }
+      // Fetch server root for absolute→relative path normalization
+      let serverRoot = null;
+      try {
+        let rc = await fetch('/api/config');
+        if (!rc.ok) rc = await fetch('/config');
+        const cfg = await rc.json();
+        const cdata = (cfg && (cfg.data || cfg)) || {};
+        if (typeof cdata.root === 'string' && cdata.root) serverRoot = cdata.root;
+      } catch(_) { serverRoot = null; }
+      const toRelPath = (p) => {
+        if (!p || typeof p !== 'string') return p;
+        // Normalize separators
+        let s = p;
+        // Prefer stripping serverRoot prefix when present
+        if (serverRoot && s.startsWith(serverRoot)) {
+          s = s.slice(serverRoot.length);
+          if (s.startsWith('/') || s.startsWith('\\')) s = s.slice(1);
+        }
+        // If still absolute, last resort: try to drop drive or leading slash
+        if (s.startsWith('/')) s = s.slice(1);
+        return s;
+      };
+      // Pre-load pHash generation progress (optional enhancement)
+      let phashProgress = null; // { total, have, missing }
+      try {
+        const qp = new URLSearchParams();
+        if (directory) qp.set('path', directory);
+        qp.set('recursive', rec ? 'true' : 'false');
+        const phRes = await fetch('/api/phashes?' + qp.toString(), { headers: { Accept: 'application/json' } });
+        if (phRes.ok) {
+          const pj = await phRes.json();
+          const pdata = (pj && (pj.data || pj)) || {};
+          if (Number.isFinite(pdata.total) && Number.isFinite(pdata.have)) {
+            phashProgress = { total: pdata.total, have: pdata.have, missing: Math.max(0, (pdata.total - pdata.have)) };
+          }
+        }
+      } catch(_) { /* ignore phash progress errors */ }
       const qs = new URLSearchParams();
       qs.set('phash_threshold', String(thr));
       if (directory) qs.set('directory', directory);
       qs.set('recursive', rec ? 'true' : 'false');
       qs.set('page_size', String(limit));
       try {
-  const res = await fetch('/api/duplicates?' + qs.toString(), {headers: {Accept: 'application/json' } });
+        const res = await fetch('/api/duplicates?' + qs.toString(), {headers: {Accept: 'application/json' } });
         if (!res.ok) {
           statusEl.textContent = 'Failed to load';
           statusEl.style.color = 'var(--danger-400, red)';
@@ -6963,11 +7102,19 @@ function setupSimilarTab() {
         const pairs = Array.isArray(data.pairs) ? data.pairs : [];
         const total = Number.isFinite(data.total_pairs) ? data.total_pairs : pairs.length;
         if (!pairs.length) {
-          statusEl.textContent = 'No similar pairs at this threshold.';
+          let msg = 'No similar pairs at this threshold.';
+          if (phashProgress && phashProgress.have < phashProgress.total) {
+            msg += ` (pHash ${phashProgress.have}/${phashProgress.total})`;
+          }
+          statusEl.textContent = msg;
           statusEl.style.color = 'var(--muted-500, #778)';
           return;
         }
-        statusEl.textContent = `${total} pairs ≥ ${(thr * 100).toFixed(0)}%`;
+        let baseMsg = `${total} pairs ≥ ${(thr * 100).toFixed(0)}%`;
+        if (phashProgress && phashProgress.have < phashProgress.total) {
+          baseMsg += ` (pHash ${phashProgress.have}/${phashProgress.total})`;
+        }
+        statusEl.textContent = baseMsg;
         statusEl.style.color = '';
         // Render results
         const frag = document.createDocumentFragment();
@@ -6979,10 +7126,15 @@ function setupSimilarTab() {
             rowEl = document.createElement('div');
             rowEl.className = 'card similar-row';
             const top = document.createElement('div');
-            top.className = 'row jc-between ai-center';
+            top.className = 'row jc-between ai-center similar-row__head';
             const title = document.createElement('strong');
             title.className = 'similar-title';
             top.appendChild(title);
+            // inline thumbs container
+            const tinl = document.createElement('div'); tinl.className = 'thumbs-inline row gap-8';
+            const ta = document.createElement('div'); ta.className = 'thumb-inline'; const ia=document.createElement('img'); ia.loading='lazy'; ia.decoding='async'; ia.className='thumb thumb-a'; ta.appendChild(ia); tinl.appendChild(ta);
+            const tb = document.createElement('div'); tb.className = 'thumb-inline'; const ib=document.createElement('img'); ib.loading='lazy'; ib.decoding='async'; ib.className='thumb thumb-b'; tb.appendChild(ib); tinl.appendChild(tb);
+            top.appendChild(tinl);
             const act = document.createElement('div');
             act.className = 'row gap-10';
             const pa = document.createElement('button'); pa.className = 'btn-sm play-a'; pa.textContent = 'Play A';
@@ -6999,8 +7151,135 @@ function setupSimilarTab() {
           const pathA = rowEl.querySelector('.path-a');
           const pathB = rowEl.querySelector('.path-b');
           if (titleEl) titleEl.textContent = `${Math.round(((p && p.similarity) || 0) * 100)}% similar`;
-          if (pathA) pathA.textContent = p && p.a ? p.a : '';
-          if (pathB) pathB.textContent = p && p.b ? p.b : '';
+          const relA = toRelPath(p && p.a);
+          const relB = toRelPath(p && p.b);
+          if (pathA) pathA.textContent = relA || '';
+          if (pathB) pathB.textContent = relB || '';
+          // Thumb + metadata async load
+          const imgA = rowEl.querySelector('img.thumb-a');
+          const imgB = rowEl.querySelector('img.thumb-b');
+          const metaLineA = rowEl.querySelector('.meta-a');
+          const metaLineB = rowEl.querySelector('.meta-b');
+          // Lightweight hover preview (only if preview artifact already exists)
+          // Does NOT trigger on-demand generation; strictly checks status first.
+          async function fetchPreviewURL(relPath) {
+            if (!relPath) return '';
+            try {
+              const u = new URL('/api/artifacts/status', window.location.origin);
+              u.searchParams.set('path', relPath);
+              const r = await fetch(u.toString());
+              if (!r.ok) return '';
+              const j = await r.json();
+              const data = (j && (j.data || j)) || {};
+              if (!data.preview) return '';
+              // Determine preferred format (reuse logic from ensurePreview without generation)
+              let preferredFmt = 'webm';
+              try {
+                const probe = document.createElement('video');
+                const canWebm = !!probe.canPlayType && probe.canPlayType('video/webm; codecs="vp9,vorbis"');
+                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
+                if (isIOS) preferredFmt = 'mp4';
+                else if (!canWebm || canWebm === 'no') preferredFmt = 'mp4';
+              } catch(_) { preferredFmt = 'webm'; }
+              const qp = encodeURIComponent(relPath);
+              const pr = await fetch(`/api/preview?path=${qp}&fmt=${encodeURIComponent(preferredFmt)}`);
+              if (!pr.ok) return '';
+              const blob = await pr.blob();
+              if (!blob || !blob.size) return '';
+              return URL.createObjectURL(blob);
+            } catch(_) { return ''; }
+          }
+          function attachHoverPreview(imgEl, relPath) {
+            if (!imgEl || !relPath) return;
+            const wrap = imgEl.closest('.thumb-inline') || imgEl.parentElement;
+            if (!wrap) return;
+            let vidEl = null;
+            let objURL = '';
+            const enter = async () => {
+              if (wrap.dataset.previewActive === '1') return;
+              wrap.dataset.previewActive = '1';
+              const url = await fetchPreviewURL(relPath);
+              if (!url) { wrap.dataset.previewActive = '0'; return; }
+              objURL = url;
+              vidEl = document.createElement('video');
+              vidEl.src = url;
+              vidEl.muted = true;
+              vidEl.autoplay = true;
+              vidEl.loop = true;
+              vidEl.playsInline = true;
+              vidEl.style.width = '100%';
+              vidEl.style.height = '100%';
+              vidEl.style.objectFit = 'cover';
+              // Hide image while preview active
+              imgEl.style.visibility = 'hidden';
+              wrap.appendChild(vidEl);
+            };
+            const leave = () => {
+              wrap.dataset.previewActive = '0';
+              if (vidEl) {
+                try { vidEl.pause(); } catch(_) {}
+                vidEl.remove();
+              }
+              if (objURL) {
+                try { URL.revokeObjectURL(objURL); } catch(_) {}
+              }
+              imgEl.style.visibility = '';
+              vidEl = null; objURL='';
+            };
+            wrap.addEventListener('mouseenter', enter);
+            wrap.addEventListener('mouseleave', leave);
+          }
+          const makeThumbUrl = (relPath) => {
+            if (!relPath) return '';
+            const qp = new URLSearchParams(); qp.set('path', relPath);
+            return '/api/thumbnail?' + qp.toString();
+          };
+          const fetchMetaCache = window.__similarMetaCache || (window.__similarMetaCache = new Map());
+          async function ensureMeta(relPath) {
+            if (!relPath) return null;
+            if (fetchMetaCache.has(relPath)) return fetchMetaCache.get(relPath);
+            const qp = new URLSearchParams(); qp.set('path', relPath); qp.set('view','1');
+            try {
+              const r = await fetch('/api/metadata?' + qp.toString(), { headers: { Accept: 'application/json' } });
+              if (!r.ok) throw new Error('HTTP '+r.status);
+              const j = await r.json();
+              const data = j && (j.data || j) || {};
+              fetchMetaCache.set(relPath, data);
+              return data;
+            } catch(e) {
+              fetchMetaCache.set(relPath, null);
+              return null;
+            }
+          }
+          function fmtBytes(bytes){
+            if (!Number.isFinite(bytes) || bytes <= 0) return '—';
+            const units=['B','KB','MB','GB','TB']; let i=0; let v=bytes; while (v>=1024 && i<units.length-1){ v/=1024; i++; } return v.toFixed(v>=100||i===0?0:1)+' '+units[i];
+          }
+          function metaSummary(data){
+            if (!data) return 'No metadata';
+            const size = fmtBytes(data.size);
+            const dur = Number.isFinite(data.duration) ? fmtDuration(data.duration) : '—';
+            const w = Number.isFinite(data.width) ? data.width : '—';
+            const h = Number.isFinite(data.height) ? data.height : '—';
+            return `${size} • ${dur} • ${w}×${h}`;
+          }
+          function applyMetaToImg(imgEl, data){
+            if (!imgEl) return;
+            if (!data){ imgEl.title = 'No metadata'; return; }
+            const size = fmtBytes(data.size);
+            const dur = Number.isFinite(data.duration) ? fmtDuration(data.duration) : '—';
+            const w = Number.isFinite(data.width) ? data.width : '—';
+            const h = Number.isFinite(data.height) ? data.height : '—';
+            imgEl.title = `${size} • ${dur} • ${w}×${h}`;
+          }
+          // Kick off loads (non-blocking)
+          if (imgA && relA){ imgA.src = makeThumbUrl(relA); imgA.onerror=()=>{ imgA.style.opacity='.25'; }; }
+          if (imgB && relB){ imgB.src = makeThumbUrl(relB); imgB.onerror=()=>{ imgB.style.opacity='.25'; }; }
+          (async () => { const d = await ensureMeta(relA); applyMetaToImg(imgA, d); if (metaLineA) metaLineA.textContent = metaSummary(d); })();
+          (async () => { const d = await ensureMeta(relB); applyMetaToImg(imgB, d); if (metaLineB) metaLineB.textContent = metaSummary(d); })();
+          // Attach hover previews (non‑generative)
+          attachHoverPreview(imgA, relA);
+          attachHoverPreview(imgB, relB);
           const openPath = (path) => {
             try { ts.switchToTab('player'); }
             catch (_) { }
@@ -7128,24 +7407,45 @@ try { window.__LazyTabs && window.__LazyTabs.register('similar', setupSimilarTab
 
   // Slider helpers (Edge length / Node repulsion)
   function getEdgeLen() {
-    const v = parseInt(el('graphEdgeLen')?.value || '120', 10);
-    if (!Number.isFinite(v)) return 120;
-    return Math.max(20, Math.min(600, v));
+    const v = parseInt(el('graphEdgeLen')?.value || '160', 10);
+    if (!Number.isFinite(v)) return 160;
+    return Math.max(20, Math.min(800, v));
   }
   function getNodeRepulsion() {
-    const v = parseInt(el('graphRepulsion')?.value || '50000', 10);
-    if (!Number.isFinite(v)) return 50000;
-    return Math.max(500, Math.min(200000, v));
+    const v = parseInt(el('graphRepulsion')?.value || '150000', 10);
+    if (!Number.isFinite(v)) return 150000;
+    return Math.max(1000, Math.min(300000, v));
   }
 
-  function straightPrefGet() {
-    try { return getLocalStorageBoolean('graph:straightEdges', true); }
-    catch (_) { return true; }
-  }
-  function straightPrefSet(v) {
-    try { setLocalStorageBoolean('graph:straightEdges', !!v); }
-    catch (_) {}
+  // Wire performers face detection button (batch client-side detection + persistence)
+  function wirePerformersDetectFacesButton() {
+    const btn = document.getElementById('performersDetectFacesBtn');
+    if (!btn || btn._wired) return;
+    btn._wired = true;
+    btn.addEventListener('click', async () => {
+      const origText = btn.textContent;
+      btn.disabled = true;
+      btn.textContent = 'Detecting…';
+      try {
+        if (typeof window.persistMissingFaceBoxesClientSide === 'function') {
+          await window.persistMissingFaceBoxesClientSide();
+          notify('Face boxes updated for performers', 'success');
+        } else {
+          notify('Face detection helper not available', 'error');
+        }
+        // Refresh performers grid to reflect new boxes
+        try { if (typeof fetchPerformers === 'function') await fetchPerformers(); } catch(_) {}
+      }
+      catch (e) {
+        notify('Detect faces failed: ' + (e && e.message ? e.message : 'error'), 'error');
+      }
+      finally {
+        btn.disabled = false;
+        btn.textContent = origText || 'Detect Faces';
+      }
+    });
   }
+  try { if (typeof window !== 'undefined') window.wirePerformersDetectFacesButton = wirePerformersDetectFacesButton; } catch(_) {}
 
   function nodeSizeForCount(c) {
     const n = Math.max(1, Number(c) || 1);
@@ -7179,8 +7479,8 @@ try { window.__LazyTabs && window.__LazyTabs.register('similar', setupSimilarTab
         id: n.id,
         label: n.name,
         count: Number(n.count || 0),
-        // Optional image URL from API; fallback tries by name if server supports it
-        image: n.image || (n.name ? `/api/performers/image?name=${encodeURIComponent(n.name)}` : ''),
+        // Image URL supplied by API (if available)
+        image: n.image || '',
       },
     }));
     const edges = (data.edges || []).map((e) => ({
@@ -7243,14 +7543,12 @@ try { window.__LazyTabs && window.__LazyTabs.register('similar', setupSimilarTab
       container,
       elements: [],
       style: [
+        // Base node styling (no image)
         {
           selector: 'node',
-            style: {
+          style: {
             'shape': 'ellipse',
             'background-color': '#22324c',
-            'background-image': 'data(image)',
-            'background-fit': 'cover',
-            'background-opacity': 1,
             'border-width': 2,
             'border-color': '#93c5fd',
             'label': 'data(label)',
@@ -7267,12 +7565,22 @@ try { window.__LazyTabs && window.__LazyTabs.register('similar', setupSimilarTab
             'text-margin-y': 8,
           }
         },
+        // Nodes with an image get background-image applied
+        {
+          selector: 'node[image]',
+          style: {
+            'background-image': 'data(image)',
+            'background-fit': 'cover',
+            'background-opacity': 1,
+          }
+        },
         {
           selector: 'edge',
           style: {
             'line-color': '#64748b',
             'target-arrow-color': '#64748b',
             'width': 'data(width)',
+            // Default to straight edges (user preference restored)
             'curve-style': 'straight',
             'opacity': 0.75,
           }
@@ -7294,7 +7602,6 @@ try { window.__LazyTabs && window.__LazyTabs.register('similar', setupSimilarTab
           style: { 'border-width': 3, 'border-color': '#fff' }
         },
       ],
-      wheelSensitivity: 0.2,
       pixelRatio: 1,
     });
     try {
@@ -7302,36 +7609,59 @@ try { window.__LazyTabs && window.__LazyTabs.register('similar', setupSimilarTab
      }
     catch (_) {}
 
-  // Apply preferred edge curvature (straight is default)
-  applyEdgeCurve(straightPrefGet());
+  // Set curved edges by default (straight toggle removed)
+  applyEdgeCurve();
+
+    // -------------------------------
+    // Wine & Cheese style highlight
+    // -------------------------------
+    let __highlightNode = null;
+    function highlightNode(n) {
+      if (!n || n === __highlightNode) return;
+      const nhood = n.closedNeighborhood();
+      // Clear previous
+      cy.elements().removeClass('faded').removeClass('highlighted');
+      __highlightNode = n;
+      // Mark original positions once (reuse existing storePositionsOnce for full graph restore)
+      storePositionsOnce();
+      // Apply classes
+      nhood.addClass('highlighted');
+      cy.elements().not(nhood).addClass('faded');
+      // Run a concentric layout scoped to neighborhood (animated)
+      try {
+        const layout = nhood.layout({
+          name: 'concentric',
+          animate: true,
+          animationDuration: 400,
+          avoidOverlap: true,
+          concentric: (ele) => (ele.id() === n.id() ? 2 : 1),
+          levelWidth: () => 1,
+          fit: true,
+          padding: 60,
+        });
+        layout.run();
+      } catch(_) {}
+    }
+    function unhighlightNode() {
+      if (!__highlightNode) return;
+      __highlightNode = null;
+      cy.elements().removeClass('faded').removeClass('highlighted');
+      // Restore stored positions if we were in neighborhood view
+      restorePositions();
+    }
 
-    // Hover magnify + neighbor highlight
+    // Hover highlight (removed size animation) - keep simple neighbor emphasis
     cy.on('mouseover', 'node', (evt) => {
+      // Skip transient hover fade if a persistent highlight is active
+      if (__highlightNode) return;
       const n = evt.target;
-      const bw = Number(n.data('w') || n.data('size') || 48);
-      const bh = Number(n.data('h') || n.data('size') || 28);
-      try { n.stop(true); n.animate({ style: { width: bw * 1.15, height: bh * 1.15 } }, { duration: 120 }); }
-      catch (_) {}
       const neigh = n.closedNeighborhood();
       cy.elements().addClass('faded');
       neigh.removeClass('faded');
     });
-    cy.on('mouseout', 'node', (evt) => {
-      const n = evt.target;
-      const bw = Number(n.data('w') || n.data('size') || 48);
-      const bh = Number(n.data('h') || n.data('size') || 28);
-      try {
-        n.stop(true);
-        n.animate({
-          style: {
-            width: bw,
-            height: bh
-          }
-        }, {
-          duration: 120
-        });
-      }
-      catch (_) {}
+    cy.on('mouseout', 'node', () => {
+      // Only clear hover fade if no persistent highlight
+      if (__highlightNode) return;
       cy.elements().removeClass('faded');
     });
 
@@ -7406,20 +7736,25 @@ try { window.__LazyTabs && window.__LazyTabs.register('similar', setupSimilarTab
     }
     catch (_) {}
 
-    // Click to select a node
+    // Click background to clear highlight; click node to highlight (Wine & Cheese style)
+    cy.on('tap', (evt) => {
+      if (evt.target === cy) {
+        unhighlightNode();
+        try { cy.nodes(':selected').unselect(); } catch(_) {}
+        return;
+      }
+    });
     cy.on('tap', 'node', (evt) => {
-      try { cy.nodes(':selected').unselect(); }
-      catch (_) {}
-      try { evt.target.select(); }
-      catch (_) {}
+      const n = evt.target;
+      highlightNode(n);
+      try { cy.nodes(':selected').unselect(); } catch(_) {}
+      try { n.select(); } catch(_) {}
     });
   }
 
-  function applyEdgeCurve(straight) {
-    if (!cy) return;
-    const mode = straight ? 'straight' : 'unbundled-bezier';
-    try { cy.style().selector('edge').style('curve-style', mode).update(); }
-    catch (_) {}
+  function applyEdgeCurve() {
+    // Maintain straight edges as default; name retained for minimal intrusive change
+    if (!cy) return; try { cy.style().selector('edge').style('curve-style', 'straight').update(); } catch(_) {}
   }
 
   function applyLayout(kind) {
@@ -7427,39 +7762,42 @@ try { window.__LazyTabs && window.__LazyTabs.register('similar', setupSimilarTab
     const k = (kind || 'fcose').toLowerCase();
     const EDGE_LEN_BASE = getEdgeLen();
     const REPULSION_BASE = getNodeRepulsion();
-    let layout;
-    if (k === 'random') layout = { name: 'random', padding: 20 };
-    else if (k === 'circle') layout = { name: 'circle', padding: 20 };
-    else if (k === 'grid') layout = { name: 'grid', padding: 20 };
-    else if (k === 'cose') {
-      layout = {
-        name: 'cose',
-        animate: 'end',
-        animationDuration: 600,
-        fit: true,
-        padding: 40,
-        nodeOverlap: 10,
-        nodeRepulsion: REPULSION_BASE,
-        idealEdgeLength: (edge) => {
-          const c = Number(edge.data('count') || 1);
-          // Use slider as baseline and compress dense edges slightly
-          return Math.max(30, EDGE_LEN_BASE - Math.log2(1 + c) * 20);
-        },
-        gravity: 80,
-        componentSpacing: 80,
-      };
-    }
-    else {
-      layout = {
+    const build = () => {
+      if (k === 'random') return { name: 'random', padding: 20 };
+      if (k === 'circle') return { name: 'circle', padding: 20 };
+      if (k === 'grid') return { name: 'grid', padding: 20 };
+      if (k === 'concentric') return { name: 'concentric', padding: 40, animate: false };
+      if (k === 'dagre') return { name: 'dagre', padding: 40, animate: false };
+      if (k === 'klay') return { name: 'klay', padding: 40, animate: false };
+      // Fallback for optional plugins not loaded: map to safe built-ins
+      if (k === 'avsdf') return { name: 'dagre', padding: 40, animate: false };
+      if (k === 'cise') return { name: 'dagre', padding: 50, animate: false };
+      if (k === 'cola') return { name: 'cola', padding: 50, animate: false, maxSimulationTime: 3000 };
+      if (k === 'euler') return { name: 'euler', padding: 50, animate: false };
+      if (k === 'cose') {
+        return {
+          name: 'cose',
+          animate: false,
+          fit: true,
+          padding: 40,
+          nodeOverlap: 10,
+          nodeRepulsion: REPULSION_BASE,
+          idealEdgeLength: (edge) => {
+            const c = Number(edge.data('count') || 1);
+            return Math.max(30, EDGE_LEN_BASE - Math.log2(1 + c) * 20);
+          },
+          gravity: 80,
+          componentSpacing: 80,
+        };
+      }
+      return {
         name: 'fcose',
         quality: 'default',
         randomize: false,
-        animate: 'end',
-        animationDuration: 700,
-        animationEasing: 'ease-out-cubic',
+        animate: false,
         fit: true,
         padding: 50,
-        nodeSeparation: 30,
+        nodeSeparation: 60,
         nodeDimensionsIncludeLabels: true,
         packComponents: true,
         idealEdgeLength: (edge) => {
@@ -7472,9 +7810,29 @@ try { window.__LazyTabs && window.__LazyTabs.register('similar', setupSimilarTab
         },
         nodeRepulsion: (_node) => REPULSION_BASE,
       };
-    }
-    try { cy.layout(layout).run(); }
-    catch (_) {}
+    };
+    const startPos = {};
+    cy.nodes().forEach(n => { startPos[n.id()] = { x: n.position('x'), y: n.position('y') }; });
+    let opts = build();
+    let layout;
+    try { layout = cy.layout(opts); layout.run(); }
+    catch (err) {
+      const msg = (err && (err.message || String(err))) || '';
+      try { console.warn('[Graph] layout error, fallback to cose:', msg); } catch(_) {}
+      // Hard fallback: basic cose if selected layout missing
+      try { opts = { name: 'cose', padding: 40, animate: false }; layout = cy.layout(opts); layout.run(); }
+      catch(_) { return; }
+    }
+    const DUR = 700;
+    cy.batch(() => {
+      cy.nodes().forEach(n => {
+        const end = n.position();
+        const start = startPos[n.id()];
+        if (start) n.position(start);
+        n.animate({ position: end }, { duration: DUR, easing: 'ease-out-cubic' });
+      });
+    });
+    setTimeout(() => { try { cy.fit(null, 30); } catch(_) {} }, DUR + 20);
   }
 
   function setStatus(text) {
@@ -7504,6 +7862,23 @@ try { window.__LazyTabs && window.__LazyTabs.register('similar', setupSimilarTab
     if (!cy) return;
     cy.elements().remove();
     cy.add(elements);
+    // Apply dynamic sizing and ensure image data is set; let stylesheet bind it
+    try {
+      cy.nodes().forEach((n) => {
+        const cnt = Number(n.data('count') || 0);
+        const size = Math.max(48, Math.min(110, 40 + Math.sqrt(Math.max(1, cnt)) * 6));
+        const img = n.data('image');
+        // Remove empty image data to prevent invalid blank background-image style
+        if (!img) {
+          try { n.removeData('image'); } catch(_) {}
+        }
+        n.style({ width: size, height: size, 'background-opacity': img ? 1 : 0.65 });
+      });
+      // Center images on faces where possible (async, cached)
+      cy.nodes('[image]').forEach((n) => {
+        try { centerGraphNodeFace(n); } catch(_) {}
+      });
+    } catch(_) {}
     applyLayout(el('graphLayoutSelect')?.value || 'fcose');
     const n = (filtered.nodes || []).length;
     const m = (filtered.edges || []).length;
@@ -7519,6 +7894,57 @@ try { window.__LazyTabs && window.__LazyTabs.register('similar', setupSimilarTab
     catch (_) {} }, isFreshLoad ? 80 : 10);
   }
 
+  // Use detected face box (if any) to center node background image on the face
+  async function centerGraphNodeFace(n) {
+    if (!n) return;
+    const imgUrl = n.data('image');
+    if (!imgUrl) return;
+    try {
+      // Prefer a cached/global detector if exposed by Performers module
+      const detect = (window && window.detectFaceBoxForImage) ? window.detectFaceBoxForImage : null;
+      let box = null;
+      if (typeof detect === 'function') {
+        box = await detect(imgUrl);
+        if (box) box = normalizeSquareBox(box);
+      } else {
+        // Minimal inline fallback: attempt dynamic ESM import and detect on an offscreen image
+        try {
+          const img = await new Promise((res, rej) => { const im = new Image(); im.crossOrigin='anonymous'; im.onload=()=>res(im); im.onerror=rej; im.src=imgUrl; });
+          const W = Math.max(1, img.naturalWidth || img.width || 0);
+          const H = Math.max(1, img.naturalHeight || img.height || 0);
+          const canvas = document.createElement('canvas'); canvas.width = W; canvas.height = H; const ctx = canvas.getContext('2d'); if (ctx) ctx.drawImage(img,0,0,W,H);
+          // Try native FaceDetector first when available
+          if (typeof window !== 'undefined' && 'FaceDetector' in window && typeof window.FaceDetector === 'function') {
+            try {
+              const det = new window.FaceDetector({ fastMode: true, maxDetectedFaces: 1 });
+              const ds = await det.detect(canvas);
+              if (Array.isArray(ds) && ds.length) {
+                let best=null, bestA=-1; for (const d of ds){ const bb=d && d.boundingBox; if(!bb) continue; const x=bb.x|0, y=bb.y|0, w=bb.width|0, h=bb.height|0; if(w>1 && h>1){ const a=w*h; if(a>bestA){bestA=a; best=[x,y,w,h];}}}
+                if (best) box = [best[0]/W, best[1]/H, best[2]/W, best[3]/H].map(v => Math.max(0, Math.min(1, v)));
+                if (box) box = normalizeSquareBox(box);
+              }
+            } catch(_) {}
+          }
+          if (!box) {
+            // TFJS BlazeFace fallback
+            const tfLoaded = window.tf || await import('https://esm.sh/@tensorflow/tfjs@4.14.0');
+            const blz = await import('https://esm.sh/@tensorflow-models/blazeface@0.0.7');
+            const model = await blz.load();
+            const preds = await model.estimateFaces(canvas, false);
+            let best=null, bestA=-1; for (const p of preds||[]){ const tl=p.topLeft||[0,0]; const br=p.bottomRight||[0,0]; const x=Math.floor(tl[0]); const y=Math.floor(tl[1]); const w=Math.floor(br[0]-tl[0]); const h=Math.floor(br[1]-tl[1]); if(w>1 && h>1){ const a=w*h; if(a>bestA){bestA=a; best=[x,y,w,h];}} }
+            if (best) box = [best[0]/W, best[1]/H, best[2]/W, best[3]/H].map(v => Math.max(0, Math.min(1, v)));
+            if (box) box = normalizeSquareBox(box);
+          }
+        } catch(_) { box = null; }
+      }
+      if (!box || box.length !== 4) return;
+      const [fx, fy, fw, fh] = box.map(Number);
+      const cx = fx + fw/2; const cy = fy + fh/2;
+      const px = Math.round(cx * 100); const py = Math.round(cy * 100);
+      try { n.style({ 'background-position-x': px + '%', 'background-position-y': py + '%' }); } catch(_) {}
+    } catch(_) { }
+  }
+
   function openInLibrary(perfNames) {
     try {
       const names = (perfNames || []).filter(Boolean);
@@ -7684,20 +8110,22 @@ try { window.__LazyTabs && window.__LazyTabs.register('similar', setupSimilarTab
   }
 
   function wireControlsOnce() {
-    const refreshBtn = el('graphRefreshBtn');
-    if (refreshBtn && !refreshBtn._wired) { refreshBtn._wired = true; refreshBtn.addEventListener('click', loadGraph); }
     const layoutSel = el('graphLayoutSelect');
     if (layoutSel && !layoutSel._wired) { layoutSel._wired = true; layoutSel.addEventListener('change', () => applyLayout(layoutSel.value)); }
     const fitBtn = el('graphFitBtn');
     if (fitBtn && !fitBtn._wired) { fitBtn._wired = true; fitBtn.addEventListener('click', () => {
       try { cy && cy.fit(null, 30); }
     catch (_) {} }); }
-    const nbBtn = el('graphNeighborhoodBtn');
-    if (nbBtn && !nbBtn._wired) { nbBtn._wired = true; nbBtn.addEventListener('click', () => revealNeighborhood()); }
     const clrBtn = el('graphClearBtn');
     if (clrBtn && !clrBtn._wired) { clrBtn._wired = true; clrBtn.addEventListener('click', clearHighlights); }
     const minInput = el('graphMinCount');
-    if (minInput && !minInput._wired) { minInput._wired = true; minInput.addEventListener('change', loadGraph); }
+    if (minInput && !minInput._wired) {
+      minInput._wired = true;
+      const on = debounce(() => loadGraph(), 200);
+      // Refresh graph on any input change (live), not just on blur/change
+      minInput.addEventListener('input', on);
+      minInput.addEventListener('change', on);
+    }
     const minEdgesInput = el('graphMinEdges');
     if (minEdgesInput && !minEdgesInput._wired) {
       minEdgesInput._wired = true;
@@ -7720,36 +8148,7 @@ try { window.__LazyTabs && window.__LazyTabs.register('similar', setupSimilarTab
       repInput.addEventListener('input', on);
       repInput.addEventListener('change', on);
     }
-    const searchInput = el('graphSearchInput');
-    if (searchInput && !searchInput._wired) {
-      searchInput._wired = true;
-      const on = debounce(() => {
-        const q = String(searchInput.value || '').trim().toLowerCase();
-        if (!cy) return;
-        cy.elements().removeClass('highlight');
-        if (!q) { cy.elements().removeClass('faded'); return; }
-        const matches = cy.nodes().filter((n) => String(n.data('label') || '').toLowerCase().includes(q));
-        cy.elements().addClass('faded');
-        matches.removeClass('faded');
-        matches.connectedEdges().removeClass('faded');
-        matches.addClass('highlight');
-        try { cy.fit(matches.closedNeighborhood(), 40); }
-        catch (_) {}
-      }, 200);
-      searchInput.addEventListener('input', on);
-    }
-    const straightCb = el('graphStraightEdges');
-    if (straightCb && !straightCb._wired) {
-      straightCb._wired = true;
-      // Initialize from pref
-      try { straightCb.checked = !!straightPrefGet(); }
-      catch (_) {}
-      straightCb.addEventListener('change', () => {
-        const useStraight = !!straightCb.checked;
-        straightPrefSet(useStraight);
-        applyEdgeCurve(useStraight);
-      });
-    }
+    // Removed: refresh, neighborhood, search, straight edges controls
   }
 
   function show() {
@@ -11811,8 +12210,8 @@ const Player = (() => {
           const samples = Array.isArray(hm?.samples) ? hm.samples : [];
           if (samples.length && heatmapCanvasEl) {
             drawHeatmapCanvas(samples);
-            // Clear any PNG bg under it
-            heatmapEl.style.backgroundImage = '';
+            // Clear any PNG bg under it (guard element may be absent)
+            if (heatmapEl) heatmapEl.style.backgroundImage = '';
             hasHeatmap = true;
             renderedViaJson = true;
           }
@@ -11829,7 +12228,7 @@ const Player = (() => {
         probe.src = url;
       });
         if (ok) {
-          heatmapEl.style.backgroundImage = `url('${url}')`;
+          if (heatmapEl) heatmapEl.style.backgroundImage = `url('${url}')`;
           if (heatmapCanvasEl) clearHeatmapCanvas();
           hasHeatmap = true;
           // Sidebar heatmap preview
@@ -11843,7 +12242,7 @@ const Player = (() => {
           catch (_) { }
         }
         else {
-          heatmapEl.style.backgroundImage = '';
+          if (heatmapEl) heatmapEl.style.backgroundImage = '';
           if (heatmapCanvasEl) clearHeatmapCanvas();
           hasHeatmap = false;
           try {
@@ -11860,7 +12259,7 @@ const Player = (() => {
       applyTimelineDisplayToggles();
     }
     catch (_) {
-      heatmapEl.style.backgroundImage = '';
+      if (heatmapEl) heatmapEl.style.backgroundImage = '';
       if (heatmapCanvasEl) clearHeatmapCanvas();
       hasHeatmap = false;
       if (badgeHeatmapStatus) badgeHeatmapStatus.textContent = '✗';
@@ -13476,6 +13875,38 @@ const Performers = (() => {
   let pageSizeSelB = null;
   // Browser face-detection cache (per image URL) to avoid repeated work
   const faceBoxCache = new Map(); // url -> [x,y,w,h]
+  // Normalize a normalized box [x,y,w,h] into a square while staying within [0,1]
+  function normalizeSquareBox(box) {
+    // Enlarge the smaller dimension symmetrically (keep center) until it matches the larger.
+    if (!Array.isArray(box) || box.length !== 4) return box;
+    let [x, y, w, h] = box.map(Number);
+    w = Math.max(0, Math.min(1, w));
+    h = Math.max(0, Math.min(1, h));
+    x = Math.max(0, Math.min(1, x));
+    y = Math.max(0, Math.min(1, y));
+    if (w <= 0 || h <= 0) return [x, y, 0, 0];
+    const target = Math.max(w, h); // desired square side length before boundary adjustments
+    let size = target;
+    if (size > 1) size = 1; // global clamp
+    // Center of original rectangle
+    let cx = x + w / 2;
+    let cy = y + h / 2;
+    // Initial candidate top-left keeping center
+    let nx = cx - size / 2;
+    let ny = cy - size / 2;
+    // If out of bounds horizontally/vertically, shift inwards first (prefer not shrinking)
+    if (nx < 0) nx = 0; if (ny < 0) ny = 0;
+    if (nx + size > 1) nx = 1 - size;
+    if (ny + size > 1) ny = 1 - size;
+    // After shifting, if still exceeding because size too large for available space, shrink minimally
+    if (nx < 0 || ny < 0) { nx = Math.max(0, nx); ny = Math.max(0, ny); }
+    if (size > 1 - nx) size = 1 - nx;
+    if (size > 1 - ny) size = Math.min(size, 1 - ny);
+    // Recompute to ensure square fully within bounds
+    if (nx + size > 1) nx = 1 - size;
+    if (ny + size > 1) ny = 1 - size;
+    return [Math.max(0, nx), Math.max(0, ny), Math.max(0, Math.min(1, size)), Math.max(0, Math.min(1, size))];
+  }
   const FaceDetectSupported = (typeof window !== 'undefined' && 'FaceDetector' in window && typeof window.FaceDetector === 'function');
 
   // Lazy loader for TensorFlow.js + BlazeFace (only if FaceDetector is unavailable or returns no faces).
@@ -13551,7 +13982,8 @@ const Performers = (() => {
         return null;
       }
       const [x, y, w, h] = best;
-  const box = [x / W, y / H, w / W, h / H].map(v => Math.max(0, Math.min(1, v)));
+      let box = [x / W, y / H, w / W, h / H].map(v => Math.max(0, Math.min(1, v)));
+      box = normalizeSquareBox(box);
       if (faceDebugEnabled()) {
         try {
           console.info('[FaceBox][TFJS] raw px=['+x+','+y+','+w+','+h+'] final norm=['+box.map(v=>v.toFixed(3)).join(',')+']');
@@ -13662,6 +14094,7 @@ const Performers = (() => {
           if (best) {
             const [x, y, w, h] = best;
             box = [x / W, y / H, w / W, h / H].map(v => Math.max(0, Math.min(1, v)));
+            box = normalizeSquareBox(box);
             if (faceDebugEnabled()) {
               try { console.info('[FaceBox][Native] chosen px=['+x+','+y+','+w+','+h+'] norm=['+box.map(v=>v.toFixed(3)).join(',')+']'); }
               catch(_) { }
@@ -13697,6 +14130,9 @@ const Performers = (() => {
       if (!box) {
         box = await detectFaceBoxWithTF(canvas, W, H);
       }
+      if (box) {
+        box = normalizeSquareBox(box);
+      }
       if (!box) {
         faceBoxCache.set(url, null);
         if (faceDebugEnabled()) {
@@ -13726,6 +14162,13 @@ const Performers = (() => {
       return null;
     }
   }
+  // Expose detector globally for reuse (Graph module, etc.)
+  try {
+    if (typeof window !== 'undefined') {
+      window.detectFaceBoxForImage = detectFaceBoxForImage;
+      window.detectFaceBoxWithTF = detectFaceBoxWithTF;
+    }
+  } catch(_) {}
   // Debounced search trigger (shared helper)
   let searchTimer = null; // retained only if we decide to cancel externally (not used now)
   // Face Box Modal elements (lazy lookup)
@@ -13904,8 +14347,12 @@ const Performers = (() => {
         const maxH = dragState.imgH - (dragState.sy - dragState.imgY);
         newW = Math.min(newW, maxW);
         newH = Math.min(newH, maxH);
-        overlayEl.style.width = newW + 'px';
-        overlayEl.style.height = newH + 'px';
+        // Enforce square by enlarging the smaller side (not shrinking the larger unless boundaries force)
+        let target = Math.max(newW, newH);
+        target = Math.min(target, maxW, maxH); // boundary limit
+        // If boundary prevents enlarging smaller side to full target, reduce both to allowed max maintaining square
+        overlayEl.style.width = target + 'px';
+        overlayEl.style.height = target + 'px';
         changed = true;
       }
       if (changed) {
@@ -13939,14 +14386,15 @@ const Performers = (() => {
       if (!saveBtn._wired) {
         saveBtn.addEventListener('click', async () => {
           const [nx, ny, nw, nh] = currentNormBox();
+          const [snx, sny, snw, snh] = normalizeSquareBox([nx, ny, nw, nh]);
           try {
-            const payload = { x: nx, y: ny, w: nw, h: nh };
+            const payload = { x: snx, y: sny, w: snw, h: snh };
             const url = new URL('/api/performers/face-box', window.location.origin);
             url.searchParams.set('slug', performer.slug || performer.name || '');
             const r = await fetch(url.toString(), { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
             if (!r.ok) throw new Error('HTTP ' + r.status);
             (window.showToast||notify)('Face box saved', 'success');
-            performer.image_face_box = [nx, ny, nw, nh];
+            performer.image_face_box = [snx, sny, snw, snh];
             // Apply to any existing avatar tiles in-place
             try { updatePerformerAvatars(performer); }
             catch(_) { }
@@ -13964,8 +14412,9 @@ const Performers = (() => {
       if (autoSaveTimer) clearTimeout(autoSaveTimer);
       autoSaveTimer = setTimeout(async () => {
         const [nx, ny, nw, nh] = currentNormBox();
+        const [snx, sny, snw, snh] = normalizeSquareBox([nx, ny, nw, nh]);
         try {
-          const payload = { x: nx, y: ny, w: nw, h: nh };
+          const payload = { x: snx, y: sny, w: snw, h: snh };
           const url = new URL('/api/performers/face-box', window.location.origin);
           url.searchParams.set('slug', performer.slug || performer.name || '');
           const r = await fetch(url.toString(), {
@@ -13974,7 +14423,7 @@ const Performers = (() => {
             body: JSON.stringify(payload)
           });
           if (!r.ok) return;
-          performer.image_face_box = [nx, ny, nw, nh];
+          performer.image_face_box = [snx, sny, snw, snh];
           try { updatePerformerAvatars(performer); }
           catch(_) { }
         }
@@ -14700,6 +15149,8 @@ const Performers = (() => {
       catch(_) { }
     }
   }
+  // Expose helper for manual runs from console or other modules
+  try { if (typeof window !== 'undefined') window.persistMissingFaceBoxesClientSide = persistMissingFaceBoxesClientSide; } catch(_) {}
   async function fetchPerformers() {
     initDom();
     ensureControlsVisible();
@@ -15964,10 +16415,11 @@ window.addEventListener('DOMContentLoaded', () => {
   if (document.readyState === 'loading') {
     document.addEventListener('DOMContentLoaded', wire, {once: true});
     document.addEventListener('DOMContentLoaded', wirePerformerAutoMatch, {once: true});
-  }
-  else {
+    document.addEventListener('DOMContentLoaded', () => { try { (window.wirePerformersDetectFacesButton || (()=>{}))(); } catch(_) {} }, {once: true});
+  } else {
     wire();
     wirePerformerAutoMatch();
+    try { (window.wirePerformersDetectFacesButton || (()=>{}))(); } catch(_) {}
   }
 })();
 
