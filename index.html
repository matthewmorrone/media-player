<!doctype html>
<html>

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Local Media</title>
	<style>
		body {
			font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
			margin: 0;
			display: grid;
			grid-template-rows: auto 1fr auto;
			height: 100vh;
		}

		header, footer {
			padding: 12px 16px;
			border-bottom: 1px solid #ddd;
		}

		footer {
			border-top: 1px solid #ddd;
			border-bottom: 0;
		}

		#container {
			display: grid;
			grid-template-columns: 320px 1fr;
			height: 100%;
		}

		#sidebar {
			border-right: 1px solid #eee;
			padding: 18px 16px 16px 16px;
			background: #f9f9fc;
			min-width: 260px;
			box-shadow: 2px 0 8px #0001;
			display: flex;
			flex-direction: column;
			gap: 18px;
		}

		#infoPanel {
			background: #fff;
			border-radius: 10px;
			box-shadow: 0 2px 8px #0001;
			padding: 16px 14px;
			margin-top: 0;
			border: 1px solid #eee;
			font-size: 14px;
			color: #222;
			line-height: 1.7;
		}

		.infoTitle {
			font-size: 18px;
			font-weight: 600;
			margin-bottom: 2px;
			color: #222;
		}

		.infoRow {
			display: flex;
			gap: 8px;
			align-items: center;
			margin-bottom: 2px;
		}

		.infoLabel {
			color: #888;
			font-size: 13px;
			min-width: 70px;
		}

		.infoValue {
			color: #222;
			font-size: 14px;
			font-family: monospace;
		}

		#main {
			padding: 12px;
			overflow: auto;
		}

		ul {
			list-style: none;
			padding: 0;
			margin: 0;
		}

		li {
			padding: 6px 4px;
			cursor: pointer;
		}

		li:hover {
			background: #f6f6f6;
		}

		.badge {
			font-size: 11px;
			padding: 2px 6px;
			border: 1px solid #ccc;
			border-radius: 999px;
			margin-left: 6px;
		}

		#video {
			width: 100%;
			max-height: 70vh;
			background: #000;
			display: block;
			cursor: pointer;
		}

		/* Remove reserved padding; controls are absolutely positioned */
		/* #player.player {padding-bottom: 84px; } */
		.file {
			display: flex;
			justify-content: space-between;
			gap: 8px;
			align-items: center;
		}

		.small {
			color: #666;
			font-size: 12px;
		}

		/* Utility classes for layout/spacing/typography */
		.flex {
			display: flex;
		}

		.flex-col {
			display: flex;
			flex-direction: column;
		}

		.items-center {
			align-items: center;
		}

		.items-start {
			align-items: flex-start;
		}

		.justify-between {
			justify-content: space-between;
		}

		.gap-6 {
			gap: 6px;
		}

		.gap-8 {
			gap: 8px;
		}

		.gap-12 {
			gap: 12px;
		}

		.gap-16 {
			gap: 16px;
		}

		.wrap {
			flex-wrap: wrap;
		}

		.mb-8 {
			margin-bottom: 8px;
		}

		.mb-18 {
			margin-bottom: 18px;
		}

		.mt-8 {
			margin-top: 8px;
		}

		.mt-12 {
			margin-top: 12px;
		}

		.w-80 {
			width: 80px;
		}

		.w-120 {
			width: 120px;
		}

		.w-220 {
			width: 220px;
		}

		.block {
			display: block;
		}

		.prewrap {
			white-space: pre-wrap;
		}

		.stat-val {
			font-size: 20px;
			font-weight: 600;
		}

		.grid-auto-180 {
			grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
		}

		.player-actions {
			display: flex;
			gap: 8px;
			align-items: center;
			margin: 8px 0;
		}

		.header-bar {
			display: flex;
			align-items: center;
			justify-content: space-between;
		}

		.tab-bar {
			display: flex;
			gap: 8px;
			align-items: center;
		}

		.scroll-60 {
			overflow: auto;
			max-height: 60vh;
		}

		.tile-no-pad {
			padding: 0;
		}

		.image-cover {
			max-width: 360px;
			max-height: 240px;
			border: 1px solid #ddd;
			border-radius: 8px;
			background: #111;
		}

		.progress-lg {
			width: 220px;
			margin-right: 8px;
			vertical-align: middle;
		}

		.fixed-menu {
			position: fixed;
			z-index: 1000;
			background: #fff;
			border: 1px solid #ccc;
			padding: 12px;
			border-radius: 8px;
			box-shadow: 0 2px 8px #0002;
		}

		.meta-extra {
			margin-top: 4px;
			white-space: pre-wrap;
			line-height: 1.4;
		}

		.thumb-img {
			width: 100%;
			max-width: 220px;
			border-radius: 8px;
			margin-bottom: 10px;
			object-fit: cover;
		}

		.thumb-placeholder {
			width: 100%;
			max-width: 220px;
			height: 120px;
			margin-bottom: 10px;
			display: flex;
			align-items: center;
			justify-content: center;
			background: #f0f0f0;
			color: #666;
			border-radius: 8px;
		}

		.w-full {
			width: 100%;
		}

		.table-collapse {
			border-collapse: collapse;
		}

		.thead-sticky {
			position: sticky;
			top: 0;
			background: #fafafa;
		}

		/* List column config + resizing */
		#listControls {
			display: flex;
			align-items: center;
			gap: 8px;
			flex-wrap: wrap;
		}
		#listColumnsPanel {
			background: #fff;
			border: 1px solid #e5e5e5;
			border-radius: 8px;
			padding: 8px 10px;
			box-shadow: 0 4px 16px #0002;
			display: none;
			position: absolute;
			z-index: 10;
			margin-top: 6px;
		}
		#listColumnsPanel .row {gap: 10px; }
		#listColumnsPanel label {font-size: 12px; color: #333; }
		#listColumnsPanel .muted {color: #777; }
		#listColumnsPanel .section {margin: 8px 0; }
		#listColumnsPanel .section strong {display:block; margin-bottom:6px; }
		#listColumnsPanel .choices {max-height: 220px; overflow: auto; border: 1px solid #eee; padding: 6px; border-radius: 6px; }
		#listColumnsPanel input[type="text"] {width: 220px; }

		#listTable {
			table-layout: fixed;
			width: 100%;
		}
		#listTable th {position: relative; user-select: none; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
		#listTable td {white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
		.col-resizer {
			position: absolute;
			right: 0;
			top: 0;
			width: 6px;
			height: 100%;
			cursor: col-resize;
			background: transparent;
		}
		.col-resizer:hover {background: #eaeaea; }
		.dragging-col {opacity: 0.5; }

		.text-left {
			text-align: left;
		}

		.text-right {
			text-align: right;
		}

		.th {
			padding: 8px;
			border-bottom: 1px solid #eee;
		}

		.td {
			padding: 6px 8px;
			border-bottom: 1px solid #f0f0f0;
		}

		.back-btn {
			margin: 8px 8px 8px 0;
			font-size: 18px;
			font-weight: 700;
			padding: 10px 14px;
			display: inline-flex;
			align-items: center;
			gap: 10px;
		}

		.back-icon {
			font-size: 20px;
			opacity: 0.8;
		}

		.player-title {
			font-size: 22px;
			font-weight: 800;
			letter-spacing: -0.2px;
			max-width: 60vw;
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
		}

		/* Ensure controls anchor to the video box */
		.player-media {
			position: relative;
		}

		.sprite-preview {
			position: absolute;
			bottom: 48px;
			/* float above controls bar */
			left: 0;
			width: 160px;
			height: 90px;
			background: #000 no-repeat;
			background-size: cover;
			border: 1px solid #333;
			border-radius: 6px;
			box-shadow: 0 2px 8px #0006;
			pointer-events: none;
			transform: translateX(-50%);
			display: none;
			z-index: 7;
		}

		/* #infoPanel spacing handled in main panel styles */

		.controls {
			display: flex;
			gap: 8px;
			align-items: center;
			margin-bottom: 12px;
		}

		.controls input[type="text"] {
			flex: 1;
			padding: 6px 8px;
			font-size: 14px;
		}

		.controls button {
			padding: 6px 10px;
			font-size: 14px;
			cursor: pointer;
		}

		.grid {
			display: grid;
			grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
			gap: 12px;
			align-items: start;
		}

		.tile {
			border: 1px solid #eee;
			border-radius: 8px;
			padding: 8px;
			background: #fff;
			display: flex;
			flex-direction: column;
			gap: 6px;
		}

		.tile.selected {
			outline: 2px solid #06f;
			box-shadow: 0 0 0 2px #06f inset;
		}

		.tile video {
			width: 100%;
			height: 120px;
			background: #000;
			object-fit: cover;
		}

		.tile .name {
			font-size: 12px;
			color: #333;
			word-break: break-word;
		}

		.tile .thumb {
			width: 100%;
			height: 120px;
			object-fit: cover;
			background: #111;
			display: block;
		}

		.btn {
			font-size: 12px;
			padding: 4px 8px;
			border: 1px solid #ccc;
			border-radius: 6px;
			background: #f8f8f8;
			cursor: pointer;
		}

		.row {
			display: flex;
			gap: 8px;
			align-items: end;
			flex-wrap: wrap;
		}

		.pager {
			display: flex;
			gap: 8px;
			align-items: center;
			justify-content: flex-start;
			margin: 8px 0;
		}

		.pager input[type="number"] {
			width: 72px;
			padding: 4px 6px;
			font-size: 12px;
		}

		.hidden {
			display: none !important;
		}

		.placeholder {
			width: 100%;
			height: 120px;
			background: #151515;
			color: #888;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 11px;
			border-radius: 4px;
			border: 1px dashed #333;
		}

		.swatch {
			width: 20px;
			height: 20px;
			border-radius: 4px;
			border: 1px solid #ccc;
			display: inline-block;
			vertical-align: middle;
			margin-right: 6px;
		}

		/* Player overlays */
		.player {
			position: relative;
		}

		/* Scrub visuals sit inside the progress bar now */
		#heatmapStripe {
			position: absolute;
			left: 0;
			right: 0;
			top: 0;
			bottom: 0;
			background-size: 100% 100%;
			image-rendering: pixelated;
			opacity: 0.9;
			border-radius: 10px;
			background-color: transparent;
		}

		#chaptersBar {
			position: absolute;
			left: 0;
			right: 0;
			top: 0;
			bottom: 0;
			pointer-events: none;
		}

		#chaptersBar .marker {
			position: absolute;
			top: 0;
			bottom: 0;
			width: 2px;
			background: #ff4081;
			opacity: 0.9;
		}

		#chaptersBar .marker::after {
			content: "";
			position: absolute;
			top: 0;
			bottom: 0;
			left: -1px;
			right: -1px;
			background: linear-gradient(to bottom, #ff4081, #ffc107);
			opacity: 0.5;
		}

		/* Custom player controls */
		#controlsBar {
			position: absolute;
			left: 8px;
			right: 8px;
			bottom: 8px;
			display: flex;
			align-items: center;
			gap: 10px;
			user-select: none;
			padding: 8px 10px;
			background: linear-gradient(to top,
			rgba(0, 0, 0, 0.55),
			rgba(0, 0, 0, 0.35));
			border-radius: 8px;
			color: #fff;
			z-index: 6;
			opacity: 1;
			transition: opacity 0.15s ease;
		}

		#btnPlayPause,
		#btnCC {
			padding: 6px 10px;
			font-size: 13px;
			border: 1px solid #fff3;
			background: #ffffff22;
			color: #fff;
			border-radius: 6px;
			cursor: pointer;
		}

		#btnPlayPause:hover,
		#btnCC:hover {
			background: #ffffff33;
		}

		#timeLabel {
			font-size: 12px;
			color: #fff;
			min-width: 100px;
			text-align: right;
		}

		#controlsProgress {
			position: relative;
			height: 10px;
			background: #ffffff2a;
			border-radius: 999px;
			flex: 1;
			cursor: pointer;
			overflow: hidden;
		}

		#controlsProgressFill {
			position: absolute;
			left: 0;
			top: 0;
			bottom: 0;
			width: 0;
			background: #2e8cff;
			border-radius: 999px;
		}

		/* Right-side queue panel */
		/* queue removed */
		/* Generic tiny progress bar */
		.progress {
			width: 100%;
			height: 4px;
			background: #eee;
			border-radius: 999px;
			overflow: hidden;
		}

		.progress .bar {
			height: 100%;
			width: 0;
			background: #06f;
			transition: width 0.15s linear;
		}

		/* Indeterminate animation */
		.indeterminate {
			position: relative;
			overflow: hidden;
		}

		.indeterminate::before {
			content: "";
			position: absolute;
			left: -40%;
			top: 0;
			height: 100%;
			width: 40%;
			background: linear-gradient(90deg,
			transparent,
			rgba(0, 0, 0, 0.15),
			transparent);
			animation: slide 1s linear infinite;
		}

		@keyframes slide {
			0% {
				left: -40%;
			}

			100% {
				left: 100%;
			}
		}
	</style>
</head>

<body>
	<header class="header-bar">
		<strong>Local Media</strong>
		<div id="tabBar" class="tab-bar">
			<button class="btn" id="tabPlayer">Player</button>
			<button class="btn" id="tabGrid">Grid</button>
			<button class="btn" id="tabList">List</button>
			<button class="btn" id="tabTasks">Tasks</button>
			<button class="btn" id="tabStats">Stats</button>
			<button class="btn" id="tabSettings">Settings</button>
			<button class="btn" id="playRandomBtn">Random</button>
			<button class="btn" id="tabImage">Image</button>
			<button class="btn" id="toggleHoversBtn">Hovers: On</button>
		</div>
	</header>
	<div id="container">
		<div id="sidebar">
			<div class="controls">
				<input id="rootInput" type="text" value="/Volumes/media/PornMin" placeholder="Root folder" />
				<input id="hiddenDirPicker" type="file" style="display:none;" webkitdirectory directory />
				<button id="setRootBtn">Set</button>
			</div>
			<div id="infoPanel" class="small"></div>
			<ul id="dirs"></ul>
		</div>
		<div id="main">
			<!-- Static Back button (shown in Player tab) -->
			<button id="backBtn" class="btn back-btn" style="display:none">
				<span class="back-icon">←</span>
				<span id="playerTitle" class="player-title">Back</span>
			</button>
			<div id="player" class="player">
				<h1>
					<div id="meta"></div>
				</h1>
				<div class="player-media">
					<video id="video" class="hidden" preload="metadata"></video>
					<!-- Scrub visuals inside progress bar -->
					<div id="controlsBar" class="hidden">
						<button id="btnPlayPause" title="Play/Pause (space)">▶︎</button>
						<div id="controlsProgress">
							<div id="heatmapStripe"></div>
							<div id="chaptersBar"></div>
							<div id="controlsProgressFill"></div>
						</div>
						<span id="timeLabel">0:00 / 0:00</span>
						<button id="btnCC" title="Toggle captions">CC</button>
						<button id="btnFS" title="Fullscreen (f)">⤢</button>
					</div>
				</div>
				<div id="playerActions" class="player-actions">
					<button id="setThumbBtn" class="btn">Set Thumbnail from Current Frame</button>
					<button id="setMarkerBtn" class="btn">Add Marker (m)</button>
				</div>
			</div>
			<!-- Stats Tab Content -->
			<div id="statsTab" class="hidden flex-col gap-12">
				<div class="grid grid-auto-180">
					<div class="tile">
						<div class="small">SCENES SIZE</div>
						<div id="statScenesSize" class="stat-val">—</div>
					</div>
					<div class="tile">
						<div class="small">SCENES</div>
						<div id="statScenes" class="stat-val">—</div>
					</div>
					<div class="tile">
						<div class="small">SCENES DURATION</div>
						<div id="statScenesDuration" class="stat-val">—</div>
					</div>
					<div class="tile">
						<div class="small">COVERS</div>
						<div id="statCovers" class="stat-val">—</div>
					</div>
					<div class="tile">
						<div class="small">HOVERS</div>
						<div id="statHovers" class="stat-val">—</div>
					</div>
					<div class="tile">
						<div class="small">SUBTITLES</div>
						<div id="statSubs" class="stat-val">—</div>
					</div>
					<div class="tile">
						<div class="small">METADATA</div>
						<div id="statMeta" class="stat-val">—</div>
					</div>
					<!-- Performers -->
					<!-- Studios -->
					<!-- Tags -->
				</div>
				<div class="small" id="statsNote"></div>
			</div>
			<!-- Settings Tab Content -->
			<div id="settingsTab" class="hidden flex-col gap-12">
				<div class="tile">
					<div class="small"><strong>Server Health</strong></div>
					<pre id="healthInfo" class="small prewrap"></pre>
				</div>
				<div class="tile">
					<div class="small"><strong>Config</strong></div>
					<pre id="configInfo" class="small prewrap"></pre>
				</div>
			</div>
			<!-- List Tab -->
			<div id="listTab" class="hidden flex-col gap-8">
				<div class="row" id="listControls">
					<button id="reloadListBtn" class="btn">Reload</button>
					<div style="position:relative;">
						<button id="toggleListColumnsBtn" class="btn">Columns</button>
						<div id="listColumnsPanel" class="small"></div>
					</div>
				</div>
				<div class="tile tile-no-pad">
					<div class="scroll-60">
						<table id="listTable" class="small w-full table-collapse">
							<thead class="thead-sticky"><tr id="listHeaderRow"></tr></thead>
							<tbody></tbody>
						</table>
					</div>
				</div>
			</div>
			<!-- Image Tab Content (FaceLab) -->
			<div id="imageTab" class="hidden flex-col gap-12">
				<div class="row items-center gap-12 wrap">
					<strong>FaceLab</strong>
					<button id="refreshFacesBtn" class="btn">Refresh</button>
					<button id="createFacesBtn" class="btn">Compute faces</button>
					<span class="small" id="imageStatus"></span>
				</div>
				<!-- Face tuning knobs (per-file) -->
				<div class="tile">
					<div class="small"><strong>Face detection & embedding – per-file</strong></div>
					<div class="row items-center gap-12 wrap mt-8">
						<label class="small">Backend
							<select id="faceBackendSelect" class="w-80">
								<option value="auto" selected>Auto</option>
								<option value="insightface">InsightFace (SCRFD+ArcFace)</option>
								<option value="opencv">OpenCV (Haar+OpenFace)</option>
							</select>
						</label>
						<label class="small">Interval (s)
							<input id="faceIntervalInput" type="number" min="0.05" step="0.05" value="1.0" class="w-80" />
						</label>
						<label class="small">Scale factor
							<input id="faceScaleFactorInput" type="number" min="1.01" step="0.05" value="1.2" class="w-80" />
						</label>
						<label class="small">Min neighbors
							<input id="faceMinNeighborsInput" type="number" min="1" step="1" value="7" class="w-80" />
						</label>
						<label class="small">Min size (fraction)
							<input id="faceMinSizeFracInput" type="number" min="0.01" max="0.9" step="0.01" value="0.10" class="w-80" />
						</label>
						<label class="small">Similarity (0-1)
							<input id="faceSimThreshInput" type="number" min="0" max="1" step="0.01" value="0.90" class="w-80" />
						</label>
					</div>
					<div class="small muted mt-8">Tip: Higher similarity merges more detections; lower interval detects more frames but is slower.</div>
				</div>
				<div id="facesList" class="row wrap gap-16"></div>
			</div>
			<!-- Grid Tab Wrapper -->
			<div id="gridTab">
				<div id="gridControls" class="controls mb-8 wrap">
					<span class="small">Grid columns</span>
					<select id="gridSize">
						<option value="3">3</option>
						<option value="4" selected>4</option>
						<option value="5">5</option>
						<option value="8">8</option>
						<option value="16">16</option>
						<option value="32">32</option>
					</select>
					<span class="small">Page size</span>
					<input id="pageSize" type="number" min="4" max="500" step="4" value="16" />
					<input id="searchInput" type="text" placeholder="Search…" class="w-120" />
					<select id="sortBy">
						<option value="name">Name</option>
						<option value="size">Size</option>
						<option value="date">Date</option>
						<option value="random">Random</option>
					</select>
					<select id="sortOrder">
						<option value="asc">Asc</option>
						<option value="desc">Desc</option>
					</select>
					<button id="prevBtn" class="btn">Prev</button>
					<div id="pageInfo" class="small"></div>
					<button id="nextBtn" class="btn">Next</button>
				</div>
				<div id="files" class="grid"></div>
				<div id="fileMenu" class="hidden fixed-menu">
					<button id="coverBtn" class="btn">Generate cover</button>
					<button id="closeMenuBtn" class="btn">Close</button>
				</div>
			</div>
			<div id="tasksDiv" class="hidden mt-12">
				<div class="mb-18" id="taskSection-metadata" data-task-section="metadata">
					<div class="small"><strong>JSON Metadata</strong></div>
					<progress id="metaProgress" max="100" value="0" class="progress-lg"></progress>
					<span id="metaPct" class="small"></span>
					<button id="generateMissingMetaBtn" class="btn">
						Generate missing metadata
					</button>
					<button id="recomputeAllMetaBtn" class="btn btn-secondary">Recompute all metadata</button>
					<button id="clearMetaBtn" class="btn">Clear all metadata</button>
				</div>
				<div class="mb-18" id="taskSection-covers" data-task-section="covers">
					<div class="small flex items-center gap-8 wrap">
						<strong>Covers</strong>
						<span class="small">Offset (s)</span>
						<input id="coverOffset" type="number" min="0" step="0.1" value="10" class="w-80" />
					</div>
					<progress id="coverProgress" max="100" value="0" class="progress-lg"></progress>
					<span id="coverPct" class="small"></span>
					<button id="generateMissingCoversBtn" class="btn">Generate missing covers</button>
					<button id="clearCoversBtn" class="btn">Clear all covers</button>
				</div>
				<div class="mb-18" id="taskSection-hovers" data-task-section="hovers">
					<div class="small"><strong>Hover Previews</strong></div>
					<progress id="hoverProgress" max="100" value="0" class="progress-lg"></progress>
					<span id="hoverPct" class="small"></span>
					<button id="generateMissingHoversBtn" class="btn">Generate missing hovers</button>
					<button id="clearHoversBtn" class="btn">Clear all hovers</button>
				</div>
				<div class="mb-18" id="taskSection-phash" data-task-section="phash">
					<div class="small"><strong>pHash</strong></div>
					<progress id="phashProgress" max="100" value="0" class="progress-lg"></progress>
					<span id="phashPct" class="small"></span>
					<button id="generateMissingPhashBtn" class="btn">Generate missing pHash</button>
					<button id="clearPhashBtn" class="btn">Clear all pHash</button>
				</div>
				<div class="mb-18" id="taskSection-scenes" data-task-section="scenes">
					<div class="small"><strong>Chapter Markers</strong></div>
					<progress id="scenesProgress" max="100" value="0" class="progress-lg"></progress>
					<span id="scenesPct" class="small"></span>
					<button id="generateMissingScenesBtn" class="btn">Generate missing scenes</button>
					<button id="clearScenesBtn" class="btn">Clear all scenes</button>
				</div>
				<div class="mb-18" id="taskSection-sprites" data-task-section="sprites">
					<div class="small"><strong>Scrubbing Thumbnails</strong></div>
					<progress id="spritesProgress" max="100" value="0" class="progress-lg"></progress>
					<span id="spritesPct" class="small"></span>
					<button id="generateMissingSpritesBtn" class="btn">Generate missing sprites</button>
					<button id="clearSpritesBtn" class="btn">Clear all sprites</button>
				</div>
				<div class="mb-18" id="taskSection-heatmaps" data-task-section="heatmaps">
					<div class="small"><strong>Heatmaps</strong></div>
					<progress id="heatmapsProgress" max="100" value="0" class="progress-lg"></progress>
					<span id="heatmapsPct" class="small"></span>
					<button id="generateMissingHeatmapsBtn" class="btn">Generate missing heatmaps</button>
					<button id="clearHeatmapsBtn" class="btn">Clear all heatmaps</button>
				</div>
				<div class="mb-18" id="taskSection-subtitles" data-task-section="subtitles">
					<div class="small"><strong>Subtitles</strong></div>
					<progress id="subsProgress" max="100" value="0" class="progress-lg"></progress>
					<span id="subsPct" class="small"></span>
					<button id="generateMissingSubsBtn" class="btn">Generate missing subtitles</button>
					<button id="clearSubsBtn" class="btn">Clear all subtitles</button>
				</div>
				<div class="mb-18" id="taskSection-faces" data-task-section="faces">
					<div class="small"><strong>Face Embeddings</strong><span class="muted">(Generate missing or recompute all)</span></div>
					<div class="row items-center gap-12 wrap mt-6">
						<label class="small">Backend
							<select id="faceBatchBackendSelect" class="w-80">
								<option value="auto" selected>Auto</option>
								<option value="insightface">InsightFace (SCRFD+ArcFace)</option>
								<option value="opencv">OpenCV (Haar+OpenFace)</option>
							</select>
						</label>
						<label class="small">Interval (s)
							<input id="faceBatchIntervalInput" type="number" min="0.05" step="0.05" value="1.0" class="w-80" />
						</label>
						<label class="small">Scale factor
							<input id="faceBatchScaleFactorInput" type="number" min="1.01" step="0.05" value="1.2" class="w-80" />
						</label>
						<label class="small">Min neighbors
							<input id="faceBatchMinNeighborsInput" type="number" min="1" step="1" value="7" class="w-80" />
						</label>
						<label class="small">Min size (fraction)
							<input id="faceBatchMinSizeFracInput" type="number" min="0.01" max="0.9" step="0.01" value="0.10" class="w-80" />
						</label>
						<label class="small">Similarity (0-1)
							<input id="faceBatchSimThreshInput" type="number" min="0" max="1" step="0.01" value="0.90" class="w-80" />
						</label>
					</div>
					<progress id="facesProgress" max="100" value="0" class="progress-lg"></progress>
					<span id="facesPct" class="small"></span>
					<button id="generateMissingFacesBtn" class="btn">Generate missing embeddings</button>
					<button id="recomputeAllFacesBtn" class="btn btn-secondary">Recompute all embeddings</button>
					<button id="clearFacesBtn" class="btn">Clear all embeddings</button>
				</div>
				<div class="mb-18" id="taskSection-cleanup" data-task-section="cleanup">
					<div class="small"><strong>Artifacts Cleanup</strong><span class="muted">(rename artifacts for renamed media; delete orphans)</span></div>
					<progress id="cleanupProgress" max="100" value="0" class="progress-lg"></progress>
					<span id="cleanupPct" class="small"></span>
					<div class="row items-center gap-8 wrap mt-6">
						<label class="row items-center gap-6 small"><input type="checkbox" id="keepOrphansChk" />Keep orphans</label>
						<button id="cleanupDryRunBtn" class="btn">Dry-run cleanup</button>
						<button id="cleanupRunBtn" class="btn btn-secondary">Run cleanup</button>
					</div>
					<div id="cleanupSummary" class="small mt-8 prewrap"></div>
				</div>
				<!--<button class="btn" disabled>Find end of intro</button>-->
				<!--<button class="btn" disabled>Facial recognition of actors</button>-->
			</div>
		</div>
	</div>
	<footer>
		<span id="status"></span>
	</footer>
	<script>
		const videoEl = document.getElementById("video");
		const metaEl = document.getElementById("meta");
		const playerEl = document.getElementById("player");
		const controlsBar = document.getElementById("controlsBar");
		const heatmapStripe = document.getElementById("heatmapStripe");
		const chaptersBar = document.getElementById("chaptersBar");
		const gridControls = document.getElementById("gridControls");
		const filesGrid = document.getElementById("files");
		const tasksDiv = document.getElementById("tasksDiv");
		const toggleHoversBtn = document.getElementById("toggleHoversBtn");
		let hoverPreviewsEnabled = true; // default enabled

		const TAB_SLUGS = {
			Player: "player",
			Grid: "grid",
			List: "list",
			Tasks: "tasks",
			Stats: "stats",
			Image: "image",
			Settings: "settings",
		};
		const SLUG_TO_TAB = Object.fromEntries(Object.entries(TAB_SLUGS).map(([k, v]) => [v, k]));
		// Paging helpers: keep ?page in the URL
		function getPageFromLocation() {
			try {
				const u = new URL(location.href);
				const p = parseInt(u.searchParams.get('page') || '1', 10);
				return isFinite(p) && p > 0 ? p : 1;
			} catch (_) { return 1; }
		}
		function setPageInLocation(page, replace = false) {
			try {
				const u = new URL(location.href);
				if (page && page > 1) u.searchParams.set('page', String(page));
				else u.searchParams.delete('page');
				const target = u.pathname + u.search + u.hash;
				if (replace) history.replaceState({ page }, '', target);
				else history.pushState({ page }, '', target);
			} catch (_) { }
		}
		function getTabFromLocation() {
			const slug = (location.hash || "").replace(/^#/, "").toLowerCase();
			return SLUG_TO_TAB[slug] || null;
		}
		function setRouteForTab(tab, replace = false) {
			const slug = TAB_SLUGS[tab] || "grid";
			const target = `#${slug}`;
			if (replace) {
				history.replaceState({tab }, "", target);
			}
			else {
				history.pushState({tab }, "", target);
			}
		}

		// DRY tab switching: hide all, then show the requested one
		// TODO @copilot: these should be standardized
		const TAB_CONTAINERS = {
			Player: "player",
			Grid: "gridTab",
			List: "listTab",
			Tasks: "tasksDiv",
			Stats: "statsTab",
			Settings: "settingsTab",
			Image: "imageTab",
		};
		function hideAllTabs() {
			Object.values(TAB_CONTAINERS).forEach((id) => {
				const el = document.getElementById(id);
				if (el) {
					el.classList.add("hidden");
				}
			});
			// Hide Player-only UI by default
			const _bb = document.getElementById("backBtn");
			if (_bb) {
				_bb.style.display = "none";
			}
			if (controlsBar) {
				controlsBar.classList.add("hidden");
			}
			const setThumbBtn = document.getElementById("setThumbBtn");
			if (setThumbBtn) { setThumbBtn.style.display = "none"; }
			const setMarkerBtn = document.getElementById("setMarkerBtn");
			if (setMarkerBtn) { setMarkerBtn.style.display = "none"; }
			// Stop Tasks refresh + SSE when leaving
			if (typeof tasksRefreshTimer !== "undefined" && tasksRefreshTimer) {
				clearInterval(tasksRefreshTimer);
				tasksRefreshTimer = null;
			}
			try {
				if (jobsEvtSrc) {
					jobsEvtSrc.close();
					jobsEvtSrc = null;
				}
			}
			catch (_) {
			}
			try {
				setIndeterminateActive(false);
			}
			catch (_) {
			}
		}
		function showTab(tab, fromRouter) {
			hideAllTabs();
			const id = TAB_CONTAINERS[tab] || TAB_CONTAINERS.Grid;
			const container = document.getElementById(id);
			if (container) {
				container.classList.remove("hidden");
			}
			// Per-tab actions
			if (tab === "Player") {
				// Show back + player UI and ensure a file is loaded
				const _bb = document.getElementById("backBtn");
				if (_bb) {
					_bb.style.display = "";
				}
				const setThumbBtn = document.getElementById("setThumbBtn");
				if (setThumbBtn) { setThumbBtn.style.display = ""; }
				const setMarkerBtn = document.getElementById("setMarkerBtn");
				if (setMarkerBtn) { setMarkerBtn.style.display = ""; }
				if (selectedFile) {
					const currentSrc = videoEl.querySelector("source")?.src || "";
					const shouldLoad = !currentSrc.endsWith(encodeURIComponent(selectedFile.path)) && !currentSrc.endsWith(selectedFile.path);
					if (shouldLoad) {
						play(selectedFile);
					}
				}
			}
			else if (tab === "Tasks") {
				try {
					startJobsSSE();
				}
				catch (_) { }
				try {
					updateTasksStats();
				}
				catch (_) { }
				try {
					updatePollingInterval();
				}
				catch (_) { }
				try {
					setIndeterminateActive(window.__jobsActive === true);
				}
				catch (_) { }
			}
			else if (tab === "Stats") {
				try {
					loadStats();
				}
				catch (_) { }
			}
			else if (tab === "List") {
				try {
					loadList();
				}
				catch (_) { }
			}
			else if (tab === "Image") {
				try {
					loadFaces();
				}
				catch (_) { }
			}
			else if (tab === "Settings") {
				try {
					loadSettings();
				}
				catch (_) { }
			}
			// Update URL route after switching (unless invoked by popstate)
			try {
				if (!fromRouter) {
					setRouteForTab(tab);
				}
			}
			catch (_) {
			}
		}

		// Ensure sprite preview is positioned within player-media for z-index stacking
		function mountSpritePreviewInPlayer() {
			const preview = document.querySelector('.sprite-preview');
			const wrap = document.querySelector('.player-media');
			if (preview && wrap && preview.parentElement !== wrap) {
				wrap.appendChild(preview);
			}
		}

		// DRY bindings for top nav; detailed side effects live in showTab
		document.getElementById("tabPlayer").onclick = () => {showTab("Player"); };
		document.getElementById("tabGrid").onclick = () => {showTab("Grid"); };
		document.getElementById("tabTasks").onclick = () => {showTab("Tasks"); };
		document.getElementById("tabStats").onclick = () => {showTab("Stats"); };
		document.getElementById("tabImage").onclick = () => {showTab("Image"); };
		const _tabListBtn = document.getElementById("tabList");
		if (_tabListBtn) {
			_tabListBtn.onclick = () => {showTab("List"); };
		}
		// Static Back button behavior
		const _backBtn = document.getElementById("backBtn");
		if (_backBtn) {
			_backBtn.onclick = () => {
				showTab("Grid");
				if (window._lastGridTile) {
					window._lastGridTile.classList.add("selected");
					try {
						window._lastGridTile.scrollIntoView({block: "nearest", inline: "nearest" });
					}
					catch (_) { }
				}
			};
		}
		document.getElementById("tabSettings").onclick = () => {
			showTab("Settings");
		};
		document.getElementById("playRandomBtn").onclick = async () => {
			let allMediaFiles = [];
			let page = 1;
			let pageSize = 500;
			let totalPages = 1;
			do {
				const params = new URLSearchParams();
				params.set("page", String(page));
				params.set("page_size", String(pageSize));
				const searchVal = document.getElementById("searchInput")?.value?.trim();
				if (searchVal) params.set("search", searchVal);
				params.set("sort", "name");
				const res = await fetch("/api/library?" + params.toString(), {
					method: "GET",
				});
				if (!res.ok) break;
				const body = await res.json();
				const data = body.data || body;
				allMediaFiles = allMediaFiles.concat(data.files || []);
				totalPages = data.total_pages || 1;
				page++;
			}
			while (page <= totalPages);
			if (allMediaFiles.length === 0) {
				alert("No videos found!");
				return;
			}
			const randomIdx = Math.floor(Math.random() * allMediaFiles.length);
			const file = allMediaFiles[randomIdx];
			selectedFile = file;
			showTab("Player");
			play(file);
		};

		// --- TASKS PAGE LOGIC ---
		const coverProgress = document.getElementById("coverProgress");
		const coverPct = document.getElementById("coverPct");
		const hoverProgress = document.getElementById("hoverProgress");
		const hoverPct = document.getElementById("hoverPct");
		const metaProgress = document.getElementById("metaProgress");
		const metaPct = document.getElementById("metaPct");
		const phashProgress = document.getElementById("phashProgress");
		const phashPct = document.getElementById("phashPct");
		const scenesProgress = document.getElementById("scenesProgress");
		const scenesPct = document.getElementById("scenesPct");
		const spritesProgress = document.getElementById("spritesProgress");
		const spritesPct = document.getElementById("spritesPct");
		const subsProgress = document.getElementById("subsProgress");
		const subsPct = document.getElementById("subsPct");
		const generateMissingCoversBtn = document.getElementById("generateMissingCoversBtn");
		const clearCoversBtn = document.getElementById("clearCoversBtn");
		const generateMissingHoversBtn = document.getElementById("generateMissingHoversBtn");
		const clearHoversBtn = document.getElementById("clearHoversBtn");
		const generateMissingMetaBtn = document.getElementById("generateMissingMetaBtn");
		const recomputeAllMetaBtn = document.getElementById("recomputeAllMetaBtn");
		const clearMetaBtn = document.getElementById("clearMetaBtn");
		const generateMissingPhashBtn = document.getElementById("generateMissingPhashBtn");
		const clearPhashBtn = document.getElementById("clearPhashBtn");
		const generateMissingScenesBtn = document.getElementById("generateMissingScenesBtn");
		const clearScenesBtn = document.getElementById("clearScenesBtn");
		const heatmapsProgress = document.getElementById("heatmapsProgress");
		const heatmapsPct = document.getElementById("heatmapsPct");
		const generateMissingHeatmapsBtn = document.getElementById("generateMissingHeatmapsBtn");
		const clearHeatmapsBtn = document.getElementById("clearHeatmapsBtn");
		const generateMissingSpritesBtn = document.getElementById("generateMissingSpritesBtn");
		const clearSpritesBtn = document.getElementById("clearSpritesBtn");
		const generateMissingSubsBtn = document.getElementById("generateMissingSubsBtn");
		const clearSubsBtn = document.getElementById("clearSubsBtn");
		const facesProgress = document.getElementById("facesProgress");
		const facesPct = document.getElementById("facesPct");
		const generateMissingFacesBtn = document.getElementById("generateMissingFacesBtn");
		const recomputeAllFacesBtn = document.getElementById("recomputeAllFacesBtn");
		const clearFacesBtn = document.getElementById("clearFacesBtn");
		// Cleanup controls
		const cleanupProgress = document.getElementById("cleanupProgress");
		const cleanupPct = document.getElementById("cleanupPct");
		const keepOrphansChk = document.getElementById("keepOrphansChk");
		const cleanupDryRunBtn = document.getElementById("cleanupDryRunBtn");
		const cleanupRunBtn = document.getElementById("cleanupRunBtn");
		const cleanupSummary = document.getElementById("cleanupSummary");
		let tasksRefreshTimer = null;
		// Collect all Tasks progress elements for animation toggling
		const _allProgressEls = [
			coverProgress,
			facesProgress,
			hoverProgress,
			metaProgress,
			phashProgress,
			scenesProgress,
			heatmapsProgress,
			subsProgress,
			spritesProgress,
			cleanupProgress,
		].filter(Boolean);
		function setIndeterminateActive(active) {
			_allProgressEls.forEach((el) =>
				el.classList.toggle("indeterminate", !!active),
			);
		}
		// Scope indeterminate animation to a specific task section by name
		function setTaskIndeterminate(taskName, active) {
			const section = document.querySelector(
				`[data-task-section="${taskName}"] .progress-lg`,
			);
			if (!section) return;
			section.classList.toggle("indeterminate", !!active);
		}
		// DRY: Single mapping for job type -> task section name (base types only)
		const JOB_SECTION_BY_TYPE = {
			"metadata": "metadata",
			"cover": "covers",
			"hover": "hovers",
			"phash": "phash",
			"scenes": "scenes",
			"sprites": "sprites",
			"heatmaps": "heatmaps",
			"subtitles": "subtitles",
			"faces": "faces",
		};
		// TODO @copilot: this should no longer be necessary
		function normalizeJobType(type) {
			let t = (type || "").toLowerCase();
			// Collapse batch variants to their base type
			if (t.endsWith("-batch")) {
				t = t.slice(0, -6);
			}
			// Collapse any hover variants (e.g., hover-concat) to "hover"
			if (t.startsWith("hover")) {
				t = "hover";
			}
			return t;
		}
		function getTaskSectionFromJobType(type) {
			const t = normalizeJobType(type);
			return JOB_SECTION_BY_TYPE[t] || null;
		}
		function setIndeterminateForJobType(type, active) {
			const section = getTaskSectionFromJobType(type);
			if (section) {
				setTaskIndeterminate(section, active);
			}
		}
		async function updateTasksStats() {
			try {
				const res = await fetch("/api/stats?fast=1");
				if (!res.ok) return;
				const body = await res.json();
				const s = body.data || body;
				const total = s.total_files || 0;
				const pct = (n, t) => (t ? Math.floor((n / t) * 100) : 0);

				// TODO @copilot: seems like this section could be DRYer
				// Covers
				const covers = s.covers || 0;
				if (coverProgress) coverProgress.value = pct(covers, total);
				if (coverPct) coverPct.textContent = `${covers}/${total} (${pct(covers, total)}%)`;
				// Hovers
				const hovers = s.hovers || 0;
				if (hoverProgress) hoverProgress.value = pct(hovers, total);
				if (hoverPct) hoverPct.textContent = `${hovers}/${total} (${pct(hovers, total)}%)`;
				// Metadata
				const metas = s.metadata || 0;
				if (metaProgress) metaProgress.value = pct(metas, total);
				if (metaPct) metaPct.textContent = `${metas}/${total} (${pct(metas, total)}%)`;
				// pHash
				const phashes = s.phash || 0;
				if (phashProgress) phashProgress.value = pct(phashes, total);
				if (phashPct) phashPct.textContent = `${phashes}/${total} (${pct(phashes, total)}%)`;
				// Scenes
				const scenes = s.scenes || 0;
				if (scenesProgress) scenesProgress.value = pct(scenes, total);
				if (scenesPct) scenesPct.textContent = `${scenes}/${total} (${pct(scenes, total)}%)`;
				// Sprites
				const sprites = s.sprites || 0;
				if (spritesProgress) spritesProgress.value = pct(sprites, total);
				if (spritesPct) spritesPct.textContent = `${sprites}/${total} (${pct(sprites, total)}%)`;
				// Heatmaps
				const heatmaps = s.heatmaps || 0;
				if (heatmapsProgress) heatmapsProgress.value = pct(heatmaps, total);
				if (heatmapsPct) heatmapsPct.textContent = `${heatmaps}/${total} (${pct(heatmaps, total)}%)`;
				// Subtitles
				const subs = s.subtitles || 0;
				if (subsProgress) subsProgress.value = pct(subs, total);
				if (subsPct) subsPct.textContent = `${subs}/${total} (${pct(subs, total)}%)`;
				// Faces
				const faces = s.faces || 0;
				if (facesProgress) facesProgress.value = pct(faces, total);
				if (facesPct) facesPct.textContent = `${faces}/${total} (${pct(faces, total)}%)`;
			}
			catch (_) {
				/* ignore */
			}
		}
		if (clearCoversBtn) {
			clearCoversBtn.onclick = async () => {
				clearCoversBtn.disabled = true;
				let allMediaFiles = [];
				let page = 1;
				let pageSize = 500;
				let totalPages = 1;
				do {
					const params = new URLSearchParams();
					params.set("page", String(page));
					params.set("page_size", String(pageSize));
					const res = await fetch("/api/library?" + params.toString(), {
						method: "GET",
					});
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					allMediaFiles = allMediaFiles.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (let i = 0; i< allMediaFiles.length; i++) {
					const file = allMediaFiles[i];
					if (file.cover) {
						// Remove cover file via API (needs backend endpoint)
						await fetch(`/api/cover/delete?path=${encodeURIComponent(file.path)}`, {method: "DELETE"});
					}
				}
				clearCoversBtn.disabled = false;
				updateTasksStats();
				// Also refresh Stats so the COVERS count drops immediately
				try {
					await loadStats();
				}
				catch (_) { }
				// Refresh grid so removed covers disappear
				try {
					await load(cwd);
				}
				catch (_) { }
			};
		}
		if (generateMissingHoversBtn) {
			generateMissingHoversBtn.onclick = async () => {
				generateMissingHoversBtn.disabled = true;
				await fetch("/api/hover/create/batch", {method: "POST" });
				generateMissingHoversBtn.disabled = false;
				updateTasksStats();
				try {
					await loadStats();
				}
				catch (_) { }
				// Refresh grid to reflect hover availability flags
				try {
					await load(cwd);
				}
				catch (_) { }
			};
		}
		if (clearHoversBtn) {
			clearHoversBtn.onclick = async () => {
				clearHoversBtn.disabled = true;
				let allMediaFiles = [];
				let page = 1;
				let pageSize = 500;
				let totalPages = 1;
				do {
					const params = new URLSearchParams();
					params.set("page", String(page));
					params.set("page_size", String(pageSize));
					const res = await fetch("/api/library?" + params.toString(), {
						method: "GET",
					});
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					allMediaFiles = allMediaFiles.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (let i = 0; i< allMediaFiles.length; i++) {
					const file = allMediaFiles[i];
					if (file.hoverPreview) {
						// Remove hover file via API (needs backend endpoint)
						await fetch(`/api/hover/delete?path=${encodeURIComponent(file.path)}`, {method: "DELETE"});
					}
				}
				clearHoversBtn.disabled = false;
				updateTasksStats();
				try {
					await loadStats();
				}
				catch (_) { }
				// Refresh grid to reflect hover removal
				try {
					await load(cwd);
				}
				catch (_) { }
			};
		}
		if (generateMissingMetaBtn) {
			generateMissingMetaBtn.onclick = async () => {
				generateMissingMetaBtn.disabled = true;
				let allMediaFiles = [];
				let page = 1;
				let pageSize = 500;
				let totalPages = 1;
				do {
					const params = new URLSearchParams();
					params.set("page", String(page));
					params.set("page_size", String(pageSize));
					const res = await fetch("/api/library?" + params.toString(), {
						method: "GET",
					});
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					allMediaFiles = allMediaFiles.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (let i = 0; i< allMediaFiles.length; i++) {
					const file = allMediaFiles[i];
					if (file.duration == null) {
						// Regenerate metadata by calling /api/metadata (GET)
						await fetch(`/api/metadata/create?path=${encodeURIComponent(file.path)}`, {method: "POST"});
					}
				}
				generateMissingMetaBtn.disabled = false;
				updateTasksStats();
				try {
					await loadStats();
				}
				catch (_) { }
				// Refresh grid for updated duration/flags
				try {
					await load(cwd);
				}
				catch (_) { }
			};
		}
		if (recomputeAllMetaBtn) {
			recomputeAllMetaBtn.onclick = async () => {
				recomputeAllMetaBtn.disabled = true;
				try {
					// Use jobs API to recompute metadata with force=true across library
					const base = {task: "metadata", directory: "", recursive: true, force: true };
					const r = await fetch("/jobs", {method: "POST", headers: {"Content-Type": "application/json" }, body: JSON.stringify(base) });
					if (r.ok) {
						try {startJobsSSE(); }
						catch (_) { }
						// Nudge Tasks stats quickly
						let ticks = 0;
						const burst = setInterval(() => {
							try {updateTasksStats(); }
							catch (_) { }
							if (++ticks >= 10) {
								clearInterval(burst);
							}
						}, 1000);
					}
				}
				finally {
					recomputeAllMetaBtn.disabled = false;
					updateTasksStats();
					try {await loadStats(); }
					catch (_) { }
				}
			};
		}
		if (clearMetaBtn) {
			clearMetaBtn.onclick = async () => {
				clearMetaBtn.disabled = true;
				let allMediaFiles = [];
				let page = 1;
				let pageSize = 500;
				let totalPages = 1;
				do {
					const params = new URLSearchParams();
					params.set("page", String(page));
					params.set("page_size", String(pageSize));
					const res = await fetch("/api/library?" + params.toString(), {
						method: "GET",
					});
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					allMediaFiles = allMediaFiles.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (let i = 0; i< allMediaFiles.length; i++) {
					const file = allMediaFiles[i];
					// Remove meta file via API (needs backend endpoint)
					await fetch(`/api/metadata/delete?path=${encodeURIComponent(file.path)}`, {method: "DELETE"});
				}
				clearMetaBtn.disabled = false;
				updateTasksStats();
				try {
					await loadStats();
				}
				catch (_) { }
				// Refresh grid after clearing metadata
				try {
					await load(cwd);
				}
				catch (_) { }
			};
		}

		// --- Artifacts Cleanup wiring ---
		async function pollJobUntilDone(jobId, onProgress) {
			// Poll /jobs/{id} for status and results
			const get = async () => {
				try {
					const res = await fetch(`/jobs/${encodeURIComponent(jobId)}`);
					if (!res.ok) {
						return null;
					}
					return await res.json();
				}
				catch (_) {
					return null;
				}
			};
			let info = await get();
			// Best-effort quick loop; backend also emits SSE events we already subscribe to
			const start = Date.now();
			while (info && info.status && ["queued","running","cancel_requested"].includes(info.status)) {
				if (typeof onProgress === "function") {
					try {onProgress(info); }
					catch (_) { }
				}
				await new Promise(r => setTimeout(r, 500));
				info = await get();
				if (Date.now() - start >5 * 60 * 1000) break; // cap at 5 minutes
			}
			if (typeof onProgress === "function" && info) {
				try {onProgress(info); }
				catch (_) { }
			}
			return info;
		}
		function setCleanupProgress(processed, total) {
			if (!cleanupProgress || !cleanupPct) return;
			const t = Math.max(0, Number(total) || 0);
			const p = Math.max(0, Math.min(t, Number(processed) || 0));
			const pct = t ? Math.floor((p / t) * 100) : 0;
			cleanupProgress.value = pct;
			cleanupPct.textContent = `${p}/${t} (${pct}%)`;
		}
		async function runArtifactsCleanup(dryRun) {
			if (cleanupDryRunBtn) cleanupDryRunBtn.disabled = true;
			if (cleanupRunBtn) cleanupRunBtn.disabled = true;
			if (cleanupSummary) cleanupSummary.textContent = "";
			try {
				const params = new URLSearchParams({dry_run: String(!!dryRun), keep_orphans: String(!!(keepOrphansChk && keepOrphansChk.checked)) });
				const res = await fetch(`/api/artifacts/cleanup?${params.toString()}`, {method: "POST" });
				if (!res.ok) return;
				const j = await res.json();
				const jobId = (j.data && j.data.job) || j.job;
				if (!jobId) return;
				try {startJobsSSE(); }
				catch (_) { }
				setTaskIndeterminate("cleanup", true);
				await pollJobUntilDone(jobId, (info) => {
					if (!info) return;
					setCleanupProgress(info.processed || 0, info.total || 0);
				});
				// Fetch final result one more time
				try {
					const s = await fetch(`/jobs/${encodeURIComponent(jobId)}`);
					if (s.ok) {
						const body = await s.json();
						const result = body.result || {};
						const renamed = result.renamed || [];
						const deleted = result.deleted || [];
						const kept = result.kept || [];
						const isDry = !!result.dry_run;
						const lines = [];
						lines.push(isDry ? "Dry-run results:" : "Cleanup results:");
						lines.push(`Renamed: ${renamed.length}, Deleted: ${deleted.length}, Kept: ${kept.length}`);
						if (renamed.length) {
							lines.push("\nRenamed:");
							renamed.slice(0, 20).forEach(r => lines.push(`- ${r.from} ->${r.to}`));
							if (renamed.length >20) lines.push(`… and ${renamed.length - 20} more`);
						}
						if (deleted.length) {
							lines.push("\nDeleted:");
							deleted.slice(0, 20).forEach(d => lines.push(`- ${d}`));
							if (deleted.length >20) lines.push(`… and ${deleted.length - 20} more`);
						}
						if (kept.length && isDry) {
							lines.push("\nKept (dry-run or keep-orphans):");
							kept.slice(0, 20).forEach(k => lines.push(`- ${k}`));
							if (kept.length >20) lines.push(`… and ${kept.length - 20} more`);
						}
						if (cleanupSummary) cleanupSummary.textContent = lines.join("\n");
					}
				}
				catch (_) { }
			}
			finally {
				if (cleanupDryRunBtn) cleanupDryRunBtn.disabled = false;
				if (cleanupRunBtn) cleanupRunBtn.disabled = false;
				setTaskIndeterminate("cleanup", false);
				updateTasksStats();
				try {await loadStats(); }
				catch (_) { }
				try {await load(cwd); }
				catch (_) { }
			}
		}
		if (cleanupDryRunBtn) cleanupDryRunBtn.onclick = () => runArtifactsCleanup(true);
		if (cleanupRunBtn) cleanupRunBtn.onclick = () => runArtifactsCleanup(false);

		// pHash buttons
		if (generateMissingPhashBtn) {
			generateMissingPhashBtn.onclick = async () => {
				generateMissingPhashBtn.disabled = true;
				let page = 1,
				pageSize = 500,
				totalPages = 1,
				files = [];
				do {
					const params = new URLSearchParams({
						page: String(page),
						page_size: String(pageSize),
					});
					const res = await fetch("/api/library?" + params.toString());
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					files = files.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (const f of files) {
					if (!f.phash) {
						await fetch(`/api/phash/create?path=${encodeURIComponent(f.path)}`, {method: "POST"});
					}
				}
				generateMissingPhashBtn.disabled = false;
				updateTasksStats();
				try {
					await loadStats();
				}
				catch (_) { }
			};
		}
		if (clearPhashBtn) {
			clearPhashBtn.onclick = async () => {
				clearPhashBtn.disabled = true;
				let page = 1,
				pageSize = 500,
				totalPages = 1,
				files = [];
				do {
					const params = new URLSearchParams({
						page: String(page),
						page_size: String(pageSize),
					});
					const res = await fetch("/api/library?" + params.toString());
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					files = files.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (const f of files) {
					if (f.phash) {
						await fetch(`/api/phash/delete?path=${encodeURIComponent(f.path)}`, {method: "DELETE" });
					}
				}
				clearPhashBtn.disabled = false;
				updateTasksStats();
				try {
					await loadStats();
				}
				catch (_) { }
			};
		}

		// Scenes buttons
		if (generateMissingScenesBtn) {
			generateMissingScenesBtn.onclick = async () => {
				generateMissingScenesBtn.disabled = true;
				let page = 1,
				pageSize = 500,
				totalPages = 1,
				files = [];
				do {
					const params = new URLSearchParams({
						page: String(page),
						page_size: String(pageSize),
					});
					const res = await fetch("/api/library?" + params.toString());
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					files = files.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (const f of files) {
					if (!f.chapters) {
						await fetch(`/api/scenes/create?path=${encodeURIComponent(f.path)}`, {method: "POST" });
					}
				}
				generateMissingScenesBtn.disabled = false;
				updateTasksStats();
				try {
					await loadStats();
				}
				catch (_) { }
			};
		}
		if (clearScenesBtn) {
			clearScenesBtn.onclick = async () => {
				clearScenesBtn.disabled = true;
				let page = 1,
				pageSize = 500,
				totalPages = 1,
				files = [];
				do {
					const params = new URLSearchParams({
						page: String(page),
						page_size: String(pageSize),
					});
					const res = await fetch("/api/library?" + params.toString());
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					files = files.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (const f of files) {
					if (f.chapters) {
						await fetch(`/api/scenes/delete?path=${encodeURIComponent(f.path)}`, {method: "DELETE"});
					}
				}
				clearScenesBtn.disabled = false;
				updateTasksStats();
				try {
					await loadStats();
				}
				catch (_) { }
			};
		}

		// Sprites buttons
		if (generateMissingSpritesBtn) {
			generateMissingSpritesBtn.onclick = async () => {
				generateMissingSpritesBtn.disabled = true;
				await fetch("/api/sprites/create/batch", {method: "POST" });
				generateMissingSpritesBtn.disabled = false;
				updateTasksStats();
				try {
					await loadStats();
				}
				catch (_) { }
			};
		}

		// Heatmaps buttons
		if (generateMissingHeatmapsBtn) {
			generateMissingHeatmapsBtn.onclick = async () => {
				generateMissingHeatmapsBtn.disabled = true;
				await fetch("/api/heatmaps/create/batch", {method: "POST" });
				generateMissingHeatmapsBtn.disabled = false;
				updateTasksStats();
				try {
					await loadStats();
				}
				catch (_) { }
			};
		}

		// Subtitles buttons
		if (generateMissingSubsBtn) {
			generateMissingSubsBtn.onclick = async () => {
				generateMissingSubsBtn.disabled = true;
				await fetch("/api/subtitles/create/batch", {method: "POST" });
				generateMissingSubsBtn.disabled = false;
				updateTasksStats();
				try {await loadStats(); }
				catch (_) { }
			};
		}

		if (clearSubsBtn) {
			clearSubsBtn.onclick = async () => {
				clearSubsBtn.disabled = true;
				let page = 1,
				pageSize = 500,
				totalPages = 1,
				files = [];
				do {
					const params = new URLSearchParams({
						page: String(page),
						page_size: String(pageSize),
					});
					const res = await fetch("/api/library?" + params.toString());
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					files = files.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (const f of files) {
					if (f.subtitles) {
						await fetch(`/api/subtitles/delete?path=${encodeURIComponent(f.path)}`, {method: "DELETE"});
					}
				}
				clearSubsBtn.disabled = false;
				updateTasksStats();
				try {
					await loadStats();
				}
				catch (_) { }
			};
		}
		if (clearHeatmapsBtn) {
			clearHeatmapsBtn.onclick = async () => {
				clearHeatmapsBtn.disabled = true;
				let page = 1,
				pageSize = 500,
				totalPages = 1,
				files = [];
				do {
					const params = new URLSearchParams({
						page: String(page),
						page_size: String(pageSize),
					});
					const res = await fetch("/api/library?" + params.toString());
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					files = files.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (const f of files) {
					if (f.heatmaps) {
						await fetch(`/api/heatmaps/delete?path=${encodeURIComponent(f.path)}`, {method: "DELETE"});
					}
				}
				clearHeatmapsBtn.disabled = false;
				updateTasksStats();
				try {
					await loadStats();
				}
				catch (_) { }
			};
		}
		if (clearSpritesBtn) {
			clearSpritesBtn.onclick = async () => {
				clearSpritesBtn.disabled = true;
				let page = 1,
				pageSize = 500,
				totalPages = 1,
				files = [];
				do {
					const params = new URLSearchParams({
						page: String(page),
						page_size: String(pageSize),
					});
					const res = await fetch("/api/library?" + params.toString());
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					files = files.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (const f of files) {
					if (f.scrubThumbs) {
						await fetch(`/api/sprites/delete?path=${encodeURIComponent(f.path)}`, {method: "DELETE"});
					}
				}
				clearSpritesBtn.disabled = false;
				updateTasksStats();
				try {
					await loadStats();
				}
				catch (_) { }
			};
		}

		// Faces buttons
		if (generateMissingFacesBtn) {
			generateMissingFacesBtn.onclick = async () => {
				generateMissingFacesBtn.disabled = true;
				if (recomputeAllFacesBtn) recomputeAllFacesBtn.disabled = true;
				try {
					const k = readBatchFaceKnobs();
					const qs = new URLSearchParams({
						"backend": String(k.backend || 'auto'),
						"interval": String(k.interval),
						"scale_factor": String(k.scale_factor),
						"min_neighbors": String(k.min_neighbors),
						"min_size_frac": String(k.min_size_frac),
						"sim_thresh": String(k.sim_thresh),
						"only_missing": "true",
					});
					await fetch(`/api/faces/create/batch?${qs.toString()}`, {method: "POST" });
					// Ensure jobs SSE is connected so we see events immediately
					try {startJobsSSE(); }
					catch (_) { }
					// Fast refresh for a short burst
					let ticks = 0;
					const burst = setInterval(() => {
						try {updateTasksStats(); }
						catch (_) { }
						if (++ticks >= 10) clearInterval(burst);
					}, 1000);
					// Poll active jobs briefly to reflect activity even if SSE is delayed
					let sawFaces = false;
					for (let i = 0; i< 5; i++) {
						try {
							const r = await fetch("/api/jobs?state=active");
							if (r.ok) {
								const body = await r.json();
								const list = (body.data && body.data.jobs) || body.jobs || [];
								if (Array.isArray(list) && list.some(j => (j.type||"").toLowerCase().includes("faces"))) {sawFaces = true; break; }
							}
						}
						catch (_) { }
						await new Promise(res => setTimeout(res, 500));
					}
					if (!sawFaces) {
						try {setTaskIndeterminate("faces", true); }
						catch (_) { }
					}
				}
				finally {
					generateMissingFacesBtn.disabled = false;
					if (recomputeAllFacesBtn) recomputeAllFacesBtn.disabled = false;
					updateTasksStats();
					try {await loadStats(); }
					catch (_) { }
				}
			};
		}
		if (recomputeAllFacesBtn) {
			recomputeAllFacesBtn.onclick = async () => {
				recomputeAllFacesBtn.disabled = true;
				if (generateMissingFacesBtn) generateMissingFacesBtn.disabled = true;
				try {
					const k = readBatchFaceKnobs();
					const qs = new URLSearchParams({
						"backend": String(k.backend || 'auto'),
						"interval": String(k.interval),
						"scale_factor": String(k.scale_factor),
						"min_neighbors": String(k.min_neighbors),
						"min_size_frac": String(k.min_size_frac),
						"sim_thresh": String(k.sim_thresh),
						"only_missing": "false",
					});
					await fetch(`/api/faces/create/batch?${qs.toString()}`, {method: "POST" });
					try {startJobsSSE(); }
					catch (_) { }
					let ticks = 0;
					const burst = setInterval(() => {
						try {updateTasksStats(); }
						catch (_) { }
						if (++ticks >= 10) clearInterval(burst);
					}, 1000);
					let sawFaces = false;
					for (let i = 0; i< 5; i++) {
						try {
							const r = await fetch("/api/jobs?state=active");
							if (r.ok) {
								const body = await r.json();
								const list = (body.data && body.data.jobs) || body.jobs || [];
								if (Array.isArray(list) && list.some(j => (j.type||"").toLowerCase().includes("faces"))) {sawFaces = true; break; }
							}
						}
						catch (_) { }
						await new Promise(res => setTimeout(res, 500));
					}
					if (!sawFaces) {
						try {setTaskIndeterminate("faces", true); }
						catch (_) { }
					}
				}
				finally {
					recomputeAllFacesBtn.disabled = false;
					if (generateMissingFacesBtn) generateMissingFacesBtn.disabled = false;
					updateTasksStats();
					try {await loadStats(); }
					catch (_) { }
				}
			};
		}
		if (clearFacesBtn) {
			clearFacesBtn.onclick = async () => {
				clearFacesBtn.disabled = true;
				let page = 1,
				pageSize = 500,
				totalPages = 1,
				files = [];
				do {
					const params = new URLSearchParams({
						page: String(page),
						page_size: String(pageSize),
					});
					const res = await fetch("/api/library?" + params.toString());
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					files = files.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (const f of files) {
					if (f.faces) {
						await fetch(`/api/faces/delete?path=${encodeURIComponent(f.path)}`, {method: "DELETE"});
					}
				}
				clearFacesBtn.disabled = false;
				updateTasksStats();
				try {
					await loadStats();
				}
				catch (_) { }
			};
		}

		let jobsEvtSrc = null;
		// Track active job IDs to switch polling cadence and animations
		let __runningJobIds = new Set();
		window.__jobsActive = false;
		function startJobsSSE() {
			if (jobsEvtSrc) {
				try {jobsEvtSrc.close(); }
				catch (_) { }
				jobsEvtSrc = null;
			}
			let triedApiAlias = false;
			const openEs = (url) => {
				const es = new EventSource(url);
				jobsEvtSrc = es;
				es.onmessage = (ev) => {
					try {
						const data = JSON.parse(ev.data || "{}");
						const line = `[${new Date().toLocaleTimeString()}] ${data.event || "msg"} ${data.id || ""}`;
						if (typeof jobsBox !== "undefined" && jobsBox) {
							jobsBox.textContent = (jobsBox.textContent + "\n" + line).trim();
							jobsBox.scrollTop = jobsBox.scrollHeight;
						}
						// Maintain set of running jobs and update UI cadence
						const evt = (data.event || "").toLowerCase();
						const jid = data.id;
						if ((evt === "started" || evt === "queued" || evt === "created") && jid) {
							__runningJobIds.add(jid);
							// toggle only that task section's animation if known
							setIndeterminateForJobType(data.type, true);
						}
						else if (evt === "progress" && jid && !__runningJobIds.has(jid)) {
							// If we refreshed after a job started, the first event we see may be progress
							__runningJobIds.add(jid);
							setIndeterminateForJobType(data.type, true);
						}
						else if ((evt === "finished" || evt === "cancel") && jid) {
							__runningJobIds.delete(jid);
							setIndeterminateForJobType(data.type, false);
						}
						const newActive = __runningJobIds.size >0;
						if (window.__jobsActive !== newActive) {
							window.__jobsActive = newActive;
							try {
								updatePollingInterval();
							}
							catch (_) { }
							try {
								setIndeterminateActive(newActive);
							}
							catch (_) { }
						}
						// Nudge a quick stats refresh on any event for snappier feedback
						try {
							updateTasksStats();
						}
						catch (_) { }
					}
					catch (_) { }
				};
				es.onerror = () => {
					// First failure: try API alias once, then let browser retry
					if (!triedApiAlias) {
						triedApiAlias = true;
						try {es.close(); }
						catch (_) { }
						openEs("/api/jobs/events");
					}
				};
			};
			openEs("/jobs/events");
			// After connecting, fetch current active jobs to restore UI state on refresh
			(async () => {
				try {
					const res = await fetch("/api/jobs?state=active");
					if (res.ok) {
						const body = await res.json();
						const list = (body.data && body.data.jobs) || body.jobs || [];
						let anyActive = false;
						for (const j of list) {
							if (!j || (j.state !== "queued" && j.state !== "running")) continue;
							const jid = j.id;
							if (jid && !__runningJobIds.has(jid)) __runningJobIds.add(jid);
							setIndeterminateForJobType(j.type, true);
							anyActive = true;
						}
						if (anyActive) {
							if (window.__jobsActive !== true) {
								window.__jobsActive = true;
								try {updatePollingInterval(); }
								catch (_) { }
								try {setIndeterminateActive(true); }
								catch (_) { }
							}
						}
					}
				}
				catch (_) { }
			})();
		}

		// Refresh stats and jobs every 1 second in Tasks tab
		function startTasksRefresh() {
			updateTasksStats();
			updatePollingInterval();
		}
		// Update polling cadence based on job activity (fast when active, slow when idle)
		function updatePollingInterval() {
			if (tasksRefreshTimer) clearInterval(tasksRefreshTimer);
			// Only poll if Tasks tab is visible
			if (!tasksDiv || tasksDiv.classList.contains("hidden")) return;
			const intervalMs = window.__jobsActive === true ? 1000 : 5000;
			tasksRefreshTimer = setInterval(() => {
				updateTasksStats();
			}, intervalMs);
		}
	// Wire up tabs: use DRY showTab; per-tab side effects happen inside showTab
	document.getElementById("tabTasks").onclick = () => {showTab("Tasks"); };
		// --- IMAGE TAB LOGIC (FaceLab) ---
		const imageStatus = document.getElementById("imageStatus");
		const facesList = document.getElementById("facesList");
		const refreshFacesBtn = document.getElementById("refreshFacesBtn");
		const createFacesBtn = document.getElementById("createFacesBtn");
	const faceBackendSelect = document.getElementById("faceBackendSelect");
	const faceBatchBackendSelect = document.getElementById("faceBatchBackendSelect");

		// Face tuning inputs and helpers
		const faceIntervalInput = document.getElementById("faceIntervalInput");
		const faceScaleFactorInput = document.getElementById("faceScaleFactorInput");
		const faceMinNeighborsInput = document.getElementById("faceMinNeighborsInput");
		const faceMinSizeFracInput = document.getElementById("faceMinSizeFracInput");
		const faceSimThreshInput = document.getElementById("faceSimThreshInput");
		const faceBatchIntervalInput = document.getElementById("faceBatchIntervalInput");
		const faceBatchScaleFactorInput = document.getElementById("faceBatchScaleFactorInput");
		const faceBatchMinNeighborsInput = document.getElementById("faceBatchMinNeighborsInput");
		const faceBatchMinSizeFracInput = document.getElementById("faceBatchMinSizeFracInput");
		const faceBatchSimThreshInput = document.getElementById("faceBatchSimThreshInput");

	const FACE_SINGLE_KEY = "face.knobs.single.v1";
	const FACE_BATCH_KEY = "face.knobs.batch.v1";
	const FACE_BACKEND_SINGLE_KEY = "face.backend.single.v1";
	const FACE_BACKEND_BATCH_KEY = "face.backend.batch.v1";
		function _num(v, d, min, max) {
			let n = parseFloat(String(v));
			if (!isFinite(n)) n = d;
			if (min != null) n = Math.max(min, n);
			if (max != null) n = Math.min(max, n);
			return n;
		}
	function readSingleFaceKnobs() {
			return {
		backend: (faceBackendSelect && faceBackendSelect.value) || "auto",
				interval: _num(faceIntervalInput?.value, 1.0, 0.01, 999),
				scale_factor: _num(faceScaleFactorInput?.value, 1.2, 1.01, 10),
				min_neighbors: Math.max(1, parseInt(faceMinNeighborsInput?.value || "7", 10) || 7),
				min_size_frac: _num(faceMinSizeFracInput?.value, 0.10, 0.01, 0.9),
				sim_thresh: _num(faceSimThreshInput?.value, 0.90, 0, 1),
			};
		}
	function readBatchFaceKnobs() {
			return {
		backend: (faceBatchBackendSelect && faceBatchBackendSelect.value) || "auto",
				interval: _num(faceBatchIntervalInput?.value, 1.0, 0.01, 999),
				scale_factor: _num(faceBatchScaleFactorInput?.value, 1.2, 1.01, 10),
				min_neighbors: Math.max(1, parseInt(faceBatchMinNeighborsInput?.value || "7", 10) || 7),
				min_size_frac: _num(faceBatchMinSizeFracInput?.value, 0.10, 0.01, 0.9),
				sim_thresh: _num(faceBatchSimThreshInput?.value, 0.90, 0, 1),
			};
		}
		function saveSingleFaceKnobs() { try { localStorage.setItem(FACE_SINGLE_KEY, JSON.stringify(readSingleFaceKnobs())); } catch (_) {} }
		function saveBatchFaceKnobs() { try { localStorage.setItem(FACE_BATCH_KEY, JSON.stringify(readBatchFaceKnobs())); } catch (_) {} }
	function restoreFaceKnobs() {
			try {
		const beS = localStorage.getItem(FACE_BACKEND_SINGLE_KEY);
		if (beS && faceBackendSelect) faceBackendSelect.value = beS;
				const sraw = localStorage.getItem(FACE_SINGLE_KEY);
				if (sraw) {
					const s = JSON.parse(sraw);
					if (faceIntervalInput && s.interval != null) faceIntervalInput.value = String(s.interval);
					if (faceScaleFactorInput && s.scale_factor != null) faceScaleFactorInput.value = String(s.scale_factor);
					if (faceMinNeighborsInput && s.min_neighbors != null) faceMinNeighborsInput.value = String(s.min_neighbors);
					if (faceMinSizeFracInput && s.min_size_frac != null) faceMinSizeFracInput.value = String(s.min_size_frac);
					if (faceSimThreshInput && s.sim_thresh != null) faceSimThreshInput.value = String(s.sim_thresh);
				}
			}
			catch (_) {}
			try {
				const beB = localStorage.getItem(FACE_BACKEND_BATCH_KEY);
				if (beB && faceBatchBackendSelect) faceBatchBackendSelect.value = beB;
				const braw = localStorage.getItem(FACE_BATCH_KEY);
				if (braw) {
					const b = JSON.parse(braw);
					if (faceBatchIntervalInput && b.interval != null) faceBatchIntervalInput.value = String(b.interval);
					if (faceBatchScaleFactorInput && b.scale_factor != null) faceBatchScaleFactorInput.value = String(b.scale_factor);
					if (faceBatchMinNeighborsInput && b.min_neighbors != null) faceBatchMinNeighborsInput.value = String(b.min_neighbors);
					if (faceBatchMinSizeFracInput && b.min_size_frac != null) faceBatchMinSizeFracInput.value = String(b.min_size_frac);
					if (faceBatchSimThreshInput && b.sim_thresh != null) faceBatchSimThreshInput.value = String(b.sim_thresh);
				}
			}
			catch (_) {}
		}
		// Persist on change and restore once
		[faceIntervalInput, faceScaleFactorInput, faceMinNeighborsInput, faceMinSizeFracInput, faceSimThreshInput].forEach(el => { if (el) el.addEventListener('change', saveSingleFaceKnobs); });
		[faceBatchIntervalInput, faceBatchScaleFactorInput, faceBatchMinNeighborsInput, faceBatchMinSizeFracInput, faceBatchSimThreshInput].forEach(el => { if (el) el.addEventListener('change', saveBatchFaceKnobs); });
	if (faceBackendSelect) faceBackendSelect.addEventListener('change', () => { try { localStorage.setItem(FACE_BACKEND_SINGLE_KEY, faceBackendSelect.value); } catch(_){} });
	if (faceBatchBackendSelect) faceBatchBackendSelect.addEventListener('change', () => { try { localStorage.setItem(FACE_BACKEND_BATCH_KEY, faceBatchBackendSelect.value); } catch(_){} });
		restoreFaceKnobs();

		function setImageStatus(text) {
			if (imageStatus) imageStatus.textContent = text || "";
		}

		function getFaceNameKey(filePath, embedding) {
			// Persist a name per (file, embedding hash) in localStorage
			const sig = Array.isArray(embedding) && embedding.length ? embedding.map(x => Number(x).toFixed(3)).join(",") : "stub";
			return `facelab:name:${filePath}:${sig}`;
		}

		function getFaceName(filePath, embedding) {
			const key = getFaceNameKey(filePath, embedding);
			return localStorage.getItem(key) || "";
		}

		function setFaceName(filePath, embedding, name) {
			const key = getFaceNameKey(filePath, embedding);
			if (name) localStorage.setItem(key, name); else localStorage.removeItem(key);
		}

		async function loadFaces() {
			if (!selectedFile || !selectedFile.path) {
				if (facesList) {
					facesList.textContent = "";
					const em = document.createElement("em");
					em.textContent = "No file selected.";
					facesList.appendChild(em);
				}
				setImageStatus("");
				return;
			}
			const path = selectedFile.path;
			setImageStatus("Loading faces…");
			try {
				const r = await fetch(`/api/faces/json?path=${encodeURIComponent(path)}`);
				if (!r.ok) {
					facesList.textContent = "";
					const em = document.createElement("em");
					em.textContent = "No faces found. Click \"Compute faces\".";
					facesList.appendChild(em);
					setImageStatus("");
					return;
				}
				const data = await r.json();
				const faces = (data && data.data && Array.isArray(data.data.faces)) ? data.data.faces : [];
				if (!faces.length) {
					facesList.textContent = "";
					const em = document.createElement("em");
					em.textContent = "No faces in this file.";
					facesList.appendChild(em);
					setImageStatus("");
					return;
				}
				facesList.textContent = "";
				for (const f of faces) {
					const box = f.box || [0,0,0,0];
					const t = typeof f.first_time === 'number' ? f.first_time : (f.time || 0);
					const url = `/api/frame/boxed?path=${encodeURIComponent(path)}&t=${encodeURIComponent(t)}&x=${box[0]}&y=${box[1]}&w=${box[2]}&h=${box[3]}&scale=256&thickness=3`;
					const nameVal = getFaceName(path, f.embedding);
					const tile = document.createElement('div');
					tile.className = 'tile p-8';
					tile.style.width = '220px';
					const col = document.createElement('div');
					col.className = 'col gap-6';
					const img = document.createElement('img');
					img.src = url;
					img.alt = 'face';
					img.style.width = '128px';
					img.style.height = 'auto';
					img.style.borderRadius = '6px';
					const input = document.createElement('input');
					input.type = 'text';
					input.className = 'w-full';
					input.placeholder = 'Name';
					input.value = nameVal;
					input.addEventListener('change', () => setFaceName(path, f.embedding, input.value.trim()));
					const meta = document.createElement('div');
					meta.className = 'small muted';
					const start = Number(f.first_time ?? f.time ?? 0).toFixed(1);
					const end = Number(f.last_time ?? f.time ?? 0).toFixed(1);
					meta.textContent = `count: ${f.count ?? 1} • span: ${start}–${end}s`;
					col.appendChild(img);
					col.appendChild(input);
					col.appendChild(meta);
					tile.appendChild(col);
					facesList.appendChild(tile);
				}
				setImageStatus("");
			}
			catch (_) {
				if (facesList) {
					facesList.textContent = "";
					const em = document.createElement('em');
					em.textContent = 'Failed to load faces.';
					facesList.appendChild(em);
				}
				setImageStatus("");
			}
		}

		if (refreshFacesBtn) refreshFacesBtn.onclick = loadFaces;
		if (createFacesBtn) createFacesBtn.onclick = async () => {
			if (!selectedFile || !selectedFile.path) return;
			setImageStatus("Computing faces…");
			try {
				const k = readSingleFaceKnobs();
				const qs = new URLSearchParams({
					"path": selectedFile.path,
					"backend": String(k.backend || 'auto'),
					"interval": String(k.interval),
					"scale_factor": String(k.scale_factor),
					"min_neighbors": String(k.min_neighbors),
					"min_size_frac": String(k.min_size_frac),
					"sim_thresh": String(k.sim_thresh),
				});
				const r = await fetch(`/api/faces/create?${qs.toString()}`, {method: 'POST' });
				if (r.ok) {
					// Connect SSE for immediate events
					try {startJobsSSE(); }
					catch (_) { }
					// Tight poll for completion for a short window
					let tries = 0;
					const maxTries = 30; // up to ~15s
					while (tries++< maxTries) {
						try {
							const h = await fetch(`/api/faces/json?path=${encodeURIComponent(selectedFile.path)}`);
							if (h.ok) break;
						}
						catch (_) { }
						await new Promise(res=> setTimeout(res, 500));
					}
					await loadFaces();
				}
				else {
					setImageStatus("Face compute failed");
				}
			}
			catch (_) {
				setImageStatus("Face compute failed");
			}
		};

		// --- STATS TAB LOGIC ---
		function humanBytes(n) {
			if (!n || n <= 0) return "0 B";
			const units = ["B", "KiB", "MiB", "GiB", "TiB"];
			let i = 0;
			let v = n;
			while (v >= 1024 && i< units.length - 1) {
				v /= 1024;
				i++;
			}
			return `${v.toFixed(1)} ${units[i]}`;
		}
		function humanDuration(totalSeconds) {
			if (!totalSeconds && totalSeconds !== 0) return "";
			const s = Math.floor(totalSeconds);
			const weeks = Math.floor(s / (7 * 24 * 3600));
			const days = Math.floor((s % (7 * 24 * 3600)) / (24 * 3600));
			const hours = Math.floor((s % (24 * 3600)) / 3600);
			const minutes = Math.floor((s % 3600) / 60);
			const sec = s % 60;
			const parts = [];
			if (weeks) parts.push(`${weeks}W`);
			if (days) parts.push(`${days}D`);
			if (hours) parts.push(`${hours}h`);
			if (minutes) parts.push(`${minutes}m`);
			if (sec || parts.length === 0) parts.push(`${sec}s`);
			return parts.join(" ");
		}
		async function loadStats() {
			try {
				const res = await fetch("/api/stats", {method: "GET" });
				if (!res.ok) return;
				const body = await res.json();
				const s = body.data || body;
				const scenes = s.total_files || 0;
				const size = humanBytes(s.total_size_bytes || 0);
				const dur = humanDuration(s.total_duration_seconds || 0);
				const covers = s.covers || 0;
				const hovers = s.hovers || 0;
				const subs = s.subtitles || 0;
				const meta = s.metadata || 0;
				const note = [];
				if (s.duration_files_count != null && scenes) {
					note.push(
					`${s.duration_files_count}/${scenes} files have duration`,
					);
				}
				document.getElementById("statScenesSize").textContent = size;
				document.getElementById("statScenes").textContent = scenes;
				document.getElementById("statScenesDuration").textContent = dur;
				document.getElementById("statCovers").textContent = covers;
				document.getElementById("statHovers").textContent = hovers;
				document.getElementById("statSubs").textContent = subs;
				document.getElementById("statMeta").textContent = meta;
				const noteEl = document.getElementById("statsNote");
				if (noteEl) noteEl.textContent = note.join(" • ");
			}
			catch (_) { }
		}

		// SETTINGS TAB
		async function loadSettings() {
			try {
				const [h, c] = await Promise.all([
				fetch("/health")
				.then((r) => r.json())
				.catch(() => ({})),
				fetch("/config")
				.then((r) => r.json())
				.catch(() => ({})),
				]);
				const hi = document.getElementById("healthInfo");
				const ci = document.getElementById("configInfo");
				if (hi) hi.textContent = JSON.stringify(h, null, 2);
				if (ci) ci.textContent = JSON.stringify(c, null, 2);
			}
			catch (_) { }
		}
		// Keyboard controls for video player
		document.addEventListener("keydown", function (e) {
			if (!videoEl || videoEl.classList.contains("hidden")) {
				return;
			}
			if (
			document.activeElement &&
			["INPUT", "TEXTAREA"].includes(document.activeElement.tagName)
			)
			return;
			if (e.code === "ArrowLeft") {
				videoEl.currentTime = Math.max(0, videoEl.currentTime - 10);
				e.preventDefault();
			}
			else if (e.code === "ArrowRight") {
				videoEl.currentTime = Math.min(
				videoEl.duration || 0,
				videoEl.currentTime + 10,
				);
				e.preventDefault();
			}
			else if (e.code === "Space") {
				if (videoEl.paused) {
					videoEl.play();
				}
				else {
					videoEl.pause();
				}
				e.preventDefault();
			}
			else if ((e.key || '').toLowerCase() === 'm') {
				// Add persistent marker at current time
				try {
					if (selectedFile && selectedFile.path) {
						const t = Math.max(0, Math.min(videoEl.duration || 0, videoEl.currentTime || 0));
						fetch(`/api/marker?path=${encodeURIComponent(selectedFile.path)}&time=${encodeURIComponent(t)}`, { method: 'POST' })
							.then(() => { try { renderOverlaysForFile(selectedFile); } catch (_) {} });
					}
				} catch (_) {}
			}
		});
		// Custom controls behavior
		const btnPlayPause = document.getElementById("btnPlayPause");
		const btnCC = document.getElementById("btnCC");
		const btnFS = document.getElementById("btnFS");
		const controlsProgress = document.getElementById("controlsProgress");
		const controlsProgressFill = document.getElementById("controlsProgressFill");
		const timeLabel = document.getElementById("timeLabel");
		function fmtTime(t) {
			if (!isFinite(t) || t< 0) return "0:00";
			const s = Math.floor(t % 60)
			.toString()
			.padStart(2, "0");
			const m = Math.floor((t / 60) % 60);
			const h = Math.floor(t / 3600);
			return h ? `${h}:${m.toString().padStart(2, "0")}:${s}` : `${m}:${s}`;
		}
		function updateControls() {
			if (!videoEl) return;
			const d = videoEl.duration || 0;
			const c = videoEl.currentTime || 0;
			if (timeLabel) timeLabel.textContent = `${fmtTime(c)} / ${fmtTime(d)}`;
			if (controlsProgressFill) {
				const pct = d ? Math.max(0, Math.min(1, c / d)) : 0;
				controlsProgressFill.style.width = `${pct * 100}%`;
			}
			if (btnPlayPause)
			btnPlayPause.textContent = videoEl.paused ? "▶︎" : "❚❚";
		}
		if (btnPlayPause)
		btnPlayPause.onclick = () => {
			if (videoEl.paused) videoEl.play();
			else videoEl.pause();
		};
		// Fullscreen toggle
		function toggleFullscreen() {
			const el = playerEl; // include overlays
			const d = document;
			if (!d.fullscreenElement && !d.webkitFullscreenElement) {
				if (el.requestFullscreen) el.requestFullscreen();
				else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
			}
			else {
				if (d.exitFullscreen) d.exitFullscreen();
				else if (d.webkitExitFullscreen) d.webkitExitFullscreen();
			}
		}
		if (btnFS) btnFS.onclick = toggleFullscreen;
		if (videoEl) {
			videoEl.addEventListener('dblclick', toggleFullscreen);
		}
		if (btnCC)
		btnCC.onclick = () => {
			// Prefer our custom subtitles track
			const tt = videoEl._subsTrack || (videoEl.textTracks && Array.from(videoEl.textTracks).find(t => t.kind === 'subtitles'));
			if (!tt) return;
			const next = tt.mode === 'showing' ? 'disabled' : 'showing';
			try { tt.mode = next; } catch (_) {}
			// Disable others to avoid duplicates
			try { Array.from(videoEl.textTracks || []).forEach(t => { if (t !== tt) t.mode = 'disabled'; }); } catch (_) {}
		};
		if (controlsProgress)
		controlsProgress.addEventListener("click", (e) => {
			const r = controlsProgress.getBoundingClientRect();
			const pct = Math.max(0, Math.min(1, (e.clientX - r.left) / r.width));
			if (isFinite(videoEl.duration))
			videoEl.currentTime = pct * videoEl.duration;
		});
		// Click video to toggle play/pause
		if (videoEl)
		videoEl.addEventListener("click", () => {
			if (videoEl.paused) videoEl.play();
			else videoEl.pause();
		});
		// Space toggles play/pause when focused on document
		document.addEventListener("keydown", (e) => {
			if (e.code === "Space" && !e.repeat) {
				e.preventDefault();
				if (videoEl.paused) videoEl.play();
				else videoEl.pause();
			}
			if ((e.key || '').toLowerCase() === 'f') {
				e.preventDefault();
				toggleFullscreen();
			}
		});
		if (videoEl) {
			videoEl.addEventListener("timeupdate", updateControls);
			videoEl.addEventListener("loadedmetadata", updateControls);
			videoEl.addEventListener("play", updateControls);
			videoEl.addEventListener("pause", updateControls);
		}
		// Keep progress bar responsive with RAF in case timeupdate is throttled
		let _rafId;
		function tickControls() {
			updateControls();
			_rafId = requestAnimationFrame(tickControls);
		}
		if (document.visibilityState !== "hidden") {
			_rafId = requestAnimationFrame(tickControls);
		}
		document.addEventListener("visibilitychange", () => {
			if (document.visibilityState === "hidden") {
				if (_rafId) cancelAnimationFrame(_rafId);
				_rafId = null;
			}
			else {
				if (!_rafId) _rafId = requestAnimationFrame(tickControls);
			}
		});
		function showFileMenu(x, y) {
			const menu = document.getElementById("fileMenu");
			menu.classList.remove("hidden");
			menu.style.left = x + "px";
			menu.style.top = y + "px";
		}

		function hideFileMenu() {
			const menu = document.getElementById("fileMenu");
			menu.classList.add("hidden");
			selectedFile = null;
		}

		document.getElementById("closeMenuBtn").onclick = hideFileMenu;
		document.getElementById("coverBtn").onclick = async () => {
			if (!selectedFile) {
				return;
			}
			const ok = await generateCover(selectedFile);
			if (ok) {
				const cacheBust = `?t=${Date.now()}`;
				const imgs = document.querySelectorAll(`.tile img.thumb`);
				imgs.forEach((img) => {
					// Replace all thumbs for selected file by matching their alt/title if we have it; fallback: reload visible tiles later
					if (
					selectedFile &&
					img.closest(".tile")?.textContent?.includes(selectedFile.name)
					) {
						img.src =
						(selectedFile.cover || img.src).split("?")[0] + cacheBust;
					}
				});
			}
			hideFileMenu();
		};
		const dirsEl = document.getElementById("dirs");
		const filesEl = document.getElementById("files");
		const crumbsEl = document.getElementById("crumbs");
		const infoPanel = document.getElementById("infoPanel");
		const statusEl = document.getElementById("status");
		const rootInput = document.getElementById("rootInput");
		const setRootBtn = document.getElementById("setRootBtn");
		const prevBtn = document.getElementById("prevBtn");
		const nextBtn = document.getElementById("nextBtn");
		const pageInfo = document.getElementById("pageInfo");
		const pageSizeInput = document.getElementById("pageSize");
		// Simple status helper (avoid using window.status)
		const status = (text) => {
			if (statusEl) statusEl.textContent = text || "";
		};

		videoEl.classList.add("hidden");
		metaEl.textContent = "";

		// Removed duplicate declaration of cwd
		let cwd = "";

		let currentPage = 1;
		// Initialize from URL (?page=#)
		currentPage = getPageFromLocation();
		let pageSize =
		parseInt(pageSizeInput ? pageSizeInput.value : 48, 10) || 48;
		let totalPages = 1;
		let totalFiles = 0;
		let loading = false;
		let allFiles = [];
		let selectedFile = null;
		let selectedTile = null;
		const metaCache = new Map();
		let visibleStart = 0,
		visibleEnd = 0;

		function human(n) {
			if (n< 1024) {
				return n + " B";
			}
			const u = ["KB", "MB", "GB", "TB"];
			let i = -1;
			do {
				n = n / 1024;
				i++;
			}
			while (n >= 1024 && i< u.length - 1);
			return n.toFixed(1) + " " + u[i];
		}

		// Allow double-click on the root input to open a folder picker
		if (rootInput) {
			const hiddenDirPicker = document.getElementById("hiddenDirPicker");
			if (hiddenDirPicker) {
				hiddenDirPicker.addEventListener("change", async (ev) => {
					try {
						const files = hiddenDirPicker.files;
						if (!files || files.length === 0) return;
						// Best-effort: derive directory from first file path if available
						// On some browsers, we may have a fake path, but in desktop Safari/Chrome it often contains the directory structure
						const f = files[0];
						let dirGuess = (f.webkitRelativePath || f.name || "").split("/")[0] || "";
						// Prefer full path prompt if available; otherwise use guess
						let chosenPath = dirGuess;
						if (!chosenPath) return;
						rootInput.value = chosenPath;
						status("Setting root…");
						const tp = await fetch("/api/testpath?" + new URLSearchParams({path: chosenPath }).toString(), {method: "POST" });
						let okToSet = false;
						if (tp.ok) {
							const tjson = await tp.json();
							const tdata = tjson.data || tjson;
							okToSet = !!(tdata && tdata.exists && tdata.is_dir);
						}
						if (okToSet) {
							const res = await fetch("/api/setroot?" + new URLSearchParams({root: chosenPath }), {method: "POST" });
							if (res.ok) {
								currentPage = 1;
								cwd = "";
								await load("");
							}
						}
						else {
							alert("Could not set root from selection. Please type the full path.");
						}
					}
					catch (_) {/* ignore */ }
				});
			}
			rootInput.addEventListener("dblclick", async (e) => {
				e.preventDefault();
				e.stopPropagation();
				try {
					// Try modern File System Access API
					if (window.showDirectoryPicker) {
						const dirHandle = await window.showDirectoryPicker();
						// Resolve a path-like string if possible
						// On browsers without local path access (e.g., non-Electron), we can't get absolute path
						// So we fallback to using the name and asking the backend to interpret it relative to current root
						let chosenPath = dirHandle.name || "";
						// Prefer previously typed root as base if present
						if (chosenPath) {
							// Update input and attempt setroot
							rootInput.value = chosenPath;
							status("Setting root…");
							const tp = await fetch("/api/testpath?" + new URLSearchParams({path: chosenPath }).toString(), {method: "POST" });
							let okToSet = false;
							if (tp.ok) {
								const tjson = await tp.json();
								const tdata = tjson.data || tjson;
								okToSet = !!(tdata && tdata.exists && tdata.is_dir);
							}
							if (okToSet) {
								const res = await fetch("/api/setroot?" + new URLSearchParams({root: chosenPath }), {method: "POST" });
								if (res.ok) {
									currentPage = 1;
									cwd = "";
									await load("");
									return;
								}
							}
						}
					}
				}
				catch (_) {/* ignore */ }
				// Fallback: prompt the user for a path
				try {
					// Try hidden file input directory selection on browsers supporting webkitdirectory
					if (hiddenDirPicker) {
						hiddenDirPicker.click();
						return;
					}
					const val = prompt("Enter absolute path for media root:", rootInput.value || "");
					if (val && val.trim()) {
						const v = val.trim();
						rootInput.value = v;
						status("Setting root…");
						const tp = await fetch("/api/testpath?" + new URLSearchParams({path: v }).toString(), {method: "POST" });
						let okToSet = false;
						if (tp.ok) {
							const tjson = await tp.json();
							const tdata = tjson.data || tjson;
							okToSet = !!(tdata && tdata.exists && tdata.is_dir);
						}
						if (okToSet) {
							const res = await fetch("/api/setroot?" + new URLSearchParams({root: v }), {method: "POST" });
							if (res.ok) {
								currentPage = 1;
								cwd = "";
								await load("");
							}
						}
						else {
							alert("Path does not exist or is not a directory.");
						}
					}
				}
				catch (_) {/* ignore */ }
			});
		}

		function esc(s) {
			return String(s == null ? "" : s);
		}

		function baseName(name) {
			const i = name.lastIndexOf(".");
			return i >0 ? name.slice(0, i) : name;
		}
		function hhmmss(sec) {
			if (!sec && sec !== 0) {
				return "";
			}
			sec = Math.floor(sec);
			const h = Math.floor(sec / 3600);
			const m = Math.floor((sec % 3600) / 60);
			const s = sec % 60;
			const pad = (n) => String(n).padStart(2, "0");
			return h >0 ? `${h}:${pad(m)}:${pad(s)}` : `${m}:${pad(s)}`;
		}

		async function showInfo(file) {
			if (!infoPanel) {
				return;
			}
			selectedFile = file;
			try {if (activeTab === 'Image') {await loadFaces(); } }
			catch (_) { }
			const sizeLine = human(file.size || 0);
			const ext = file.name.split(".").pop().toLowerCase();
			// Build info panel with DOM APIs
			infoPanel.textContent = "";
			const frag = document.createDocumentFragment();
			if (file.cover) {
				const img = document.createElement("img");
				img.id = "infoThumb";
				img.src = `${file.cover}?t=${Date.now()}`;
				img.alt = "Thumbnail";
				img.className = "thumb-img";
				frag.appendChild(img);
			}
			else {
				const div = document.createElement("div");
				div.id = "infoThumb";
				div.className = "placeholder thumb-placeholder";
				div.textContent = "No thumbnail";
				frag.appendChild(div);
			}
			const titleDiv = document.createElement("div");
			titleDiv.className = "infoTitle";
			titleDiv.textContent = esc(file.title || baseName(file.name));
			frag.appendChild(titleDiv);
			function row(label, value, id) {
				const r = document.createElement("div");
				r.className = "infoRow";
				const lab = document.createElement("span");
				lab.className = "infoLabel";
				lab.textContent = label;
				const val = document.createElement("span");
				val.className = "infoValue";
				if (id) val.id = id;
				val.textContent = value;
				r.appendChild(lab);
				r.appendChild(val);
				frag.appendChild(r);
				return val;
			}
			row("Type", ext);
			row("Size", sizeLine);
			row("Duration", "Loading…", "infoDuration");
			row("Resolution", "Loading…", "infoRes");
			row("V Codec", "Loading…", "infoCodec");
			row("V Bitrate", "Loading…", "infoVBitrate");
			row("Bitrate", "Loading…", "infoBitrate");
			row("A Codec", "—", "infoACodec");
			row("A Bitrate", "—", "infoABitrate");
			row("Metadata", "Loading…", "infoMetaFile");
			row("Thumbnail", file.cover ? "✅" : "❌", "infoThumbStatus");
			row("Hover Preview", file.hoverPreview ? "✅" : "❌", "infoHoverPreview");
			row("pHash", file.phash ? "✅" : "❌", "infoPhash");
			row("Chapter Markers", file.chapters ? "✅" : "❌", "infoScenes");
			row("Scrubbing Thumbnails", file.scrubThumbs ? "✅" : "❌", "infoSprites");
			row("Heatmaps", "Loading…", "infoHeatmaps");
			row("Subtitles", "Loading…", "infoSubtitles");
			row("Face Embeddings", "Loading…", "infoFaces");
			const extra = document.createElement("div");
			extra.id = "infoMetaExtra";
			extra.className = "small meta-extra";
			frag.appendChild(extra);
			const actions = document.createElement("div");
			actions.className = "row mt-8 gap-6 wrap";
			const playBtnEl = document.createElement("button");
			playBtnEl.className = "btn";
			playBtnEl.id = "infoPlay";
			playBtnEl.textContent = "Play";
			actions.appendChild(playBtnEl);
			frag.appendChild(actions);
			// Make status values clickable to generate artifacts
			const setClickable = (id, title, handler) => {
				const el = document.getElementById(id);
				if (!el) return;
				el.classList.add("clickable");
				el.title = title;
				el.onclick = async () => {
					try { el.textContent = "…"; } catch (_) {}
					try { await handler(); } catch (_) {}
					showInfo(file);
				};
			};
			setClickable("infoThumbStatus", "Click to (re)generate cover", async () => {
				await fetch(`/api/cover/create?path=${encodeURIComponent(file.path)}`, { method: 'POST' });
			});
			setClickable("infoHoverPreview", "Click to (re)generate hover preview", async () => {
				await fetch(`/api/hover/create?path=${encodeURIComponent(file.path)}`, { method: 'POST' });
			});
			setClickable("infoSprites", "Click to (re)generate sprites", async () => {
				await fetch(`/api/sprites/create?path=${encodeURIComponent(file.path)}`, { method: 'POST' });
			});
			setClickable("infoHeatmaps", "Click to (re)generate heatmaps", async () => {
				await fetch(`/api/heatmaps/create?path=${encodeURIComponent(file.path)}`, { method: 'POST' });
			});
			setClickable("infoSubtitles", "Click to (re)generate subtitles", async () => {
				await fetch(`/api/subtitles/create?path=${encodeURIComponent(file.path)}`, { method: 'POST' });
			});
			setClickable("infoPhash", "Click to (re)generate perceptual hash", async () => {
				await fetch(`/api/phash/create?path=${encodeURIComponent(file.path)}`, { method: 'POST' });
			});
			setClickable("infoFaces", "Click to (re)compute faces", async () => {
				const backend = document.getElementById('faceBackendSelect')?.value || 'auto';
				const qs = new URLSearchParams({ path: file.path, backend });
				await fetch(`/api/faces/create?${qs.toString()}`, { method: 'POST' });
			});
			setClickable("infoMetaFile", "Click to (re)generate metadata", async () => {
				await fetch(`/api/metadata/create?path=${encodeURIComponent(file.path)}`, { method: 'POST' });
			});
			setClickable("infoScenes", "Click to (re)generate chapters", async () => {
				await fetch(`/api/scenes/create?path=${encodeURIComponent(file.path)}`, { method: 'POST' });
			});
			infoPanel.appendChild(frag);
			try {
				const res = await fetch(
				`/api/metadata/get?path=${encodeURIComponent(file.path)}`,
				{method: "GET" },
				);
				if (res.ok) {
					const body = await res.json();
					const j = body.data || body;
					document.getElementById("infoMetaFile").textContent = "✅";
					if (j.duration) {
						document.getElementById("infoDuration").textContent = hhmmss(
						j.duration,
						);
					}
					if (j.width && j.height) {
						document.getElementById("infoRes").textContent =
						`${j.width}×${j.height}`;
					}
					if (j.vcodec) {
						document.getElementById("infoCodec").textContent = j.vcodec;
					}
					if (j.vbitrate) {
						document.getElementById("infoVBitrate").textContent = j.vbitrate
						? `${(j.vbitrate / 1e6).toFixed(1)} Mbps`
						: "";
					}
					else {
						document.getElementById("infoVBitrate").textContent = "";
					}
					if (j.bitrate) {
						document.getElementById("infoBitrate").textContent =
						`${(j.bitrate / 1e6).toFixed(1)} Mbps`;
					}
					if (j.acodec) {
						document.getElementById("infoACodec").textContent = j.acodec;
					}
					if (j.abitrate) {
						document.getElementById("infoABitrate").textContent =
						`${(j.abitrate / 1e6).toFixed(1)} Mbps`;
					}
					// Show any extra metadata keys not explicitly displayed
					const known = new Set([
					"duration",
					"width",
					"height",
					"vcodec",
					"vbitrate",
					"bitrate",
					"acodec",
					"abitrate",
					]);
					const extras = Object.keys(j)
					.filter((k) => !known.has(k) && j[k] != null && j[k] !== "")
					.map((k) => `${k}: ${j[k]}`);
					if (extras.length) {
						document.getElementById("infoMetaExtra").textContent =
						extras.join("\n");
					}
				}
				else {
					// TODO @copilot: there must be a dryer was to do this
					document.getElementById("infoDuration").textContent = "";
					document.getElementById("infoRes").textContent = "";
					document.getElementById("infoCodec").textContent = "";
					document.getElementById("infoBitrate").textContent = "";
					document.getElementById("infoVBitrate").textContent = "";
					document.getElementById("infoMetaFile").textContent = "❌";
				}
			}
			catch (_) {
				// TODO @copilot: there must be a dryer was to do this
				document.getElementById("infoDuration").textContent = "";
				document.getElementById("infoRes").textContent = "";
				document.getElementById("infoCodec").textContent = "";
				document.getElementById("infoBitrate").textContent = "";
				document.getElementById("infoVBitrate").textContent = "";
				const mf = document.getElementById("infoMetaFile");
				if (mf) {
					mf.textContent = "❌";
				}
			}
			// Update Heatmaps/Subtitles/Faces indicators dynamically
			(async () => {
				const setFlag = (id, ok) => {
					const el = document.getElementById(id);
					if (el) {
						el.textContent = ok ? "✅" : "❌";
					}
				};
				// Heatmaps: prefer PNG, fallback JSON
				try {
					const hp = await fetch(`/api/heatmaps/png?path=${encodeURIComponent(file.path)}`, {method: 'HEAD' });
					if (hp.ok) {
						setFlag('infoHeatmaps', true);
					}
					else {
						const hj = await fetch(`/api/heatmaps/json?path=${encodeURIComponent(file.path)}`, {method: 'GET' });
						setFlag('infoHeatmaps', hj.ok);
					}
				} 
				catch (_) {
					setFlag('infoHeatmaps', false);
				}
				// Subtitles: SRT only
				try {
					const hs = await fetch(`/api/subtitles/get?path=${encodeURIComponent(file.path)}`, { method: 'HEAD' });
					setFlag('infoSubtitles', hs.ok);
				} catch (_) { setFlag('infoSubtitles', false); }
				// Faces
				try {
					let ok = false;
					try {
						const hf = await fetch(`/api/faces/get?path=${encodeURIComponent(file.path)}`, {method: 'HEAD' });
						ok = hf.ok;
					}
					catch (_) {/* fallback */ }
					if (!ok) {
						const jf = await fetch(`/api/faces/json?path=${encodeURIComponent(file.path)}`, {method: 'GET' });
						ok = jf.ok;
					}
					setFlag('infoFaces', ok);
				}
				catch (_) {setFlag('infoFaces', false); }
			})();
			const playBtn = document.getElementById("infoPlay");
			if (playBtn) {
				playBtn.onclick = () => play(file);
			}
		}

		function selectTile(tile, file) {
			if (selectedTile && selectedTile !== tile) {
				selectedTile.classList.remove("selected");
			}
			selectedTile = tile;
			selectedFile = file;
			tile.classList.add("selected");
			// On demand cover generation and display
			let coverDiv = tile.querySelector(".placeholder");
			if (coverDiv) {
				coverDiv.textContent = "Loading cover…";
				fetch(`/api/cover/get?path=${encodeURIComponent(file.path)}`, {
					method: "GET",
				})
				.then((res) => {
					if (res.ok) return res.blob();
					// If no cover, trigger generation
					return fetch( `/api/cover/create?path=${encodeURIComponent(file.path)}`, {method: "POST" },
					).then((postRes) => {
						if (!postRes.ok) throw new Error("Cover generation failed");
						// After generation, fetch again
						return fetch(
						`/api/cover/get?path=${encodeURIComponent(file.path)}&t=${Date.now()}`,
						{method: "GET" },
						).then((finalRes) => {
							if (!finalRes.ok) throw new Error("Cover fetch failed");
							return finalRes.blob();
						});
					});
				})
				.then((blob) => {
					const url = URL.createObjectURL(blob);
					const img = document.createElement("img");
					img.className = "thumb";
					img.src = url;
					img.onload = () => {
						URL.revokeObjectURL(url);
					};
					coverDiv.replaceWith(img);
				})
				.catch(() => {
					coverDiv.textContent = "No cover";
				});
			}
			showInfo(file);
		}

		// --- Subtitles: SRT parsing and track injection ---
		function parseSrtToCues(srtText) {
			// Returns array of { start, end, text }
			const blocks = srtText.replace(/\r/g, '').split(/\n\n+/);
			const cues = [];
			const ts = (t) => {
				// 00:00:12,345 or 0:12:34,567 -> seconds
				const m = t.trim().replace(',', '.').match(/(?:(\d{1,2}):)?(\d{1,2}):(\d{1,2})\.(\d{1,3})/);
				if (!m) return 0;
				const hh = parseInt(m[1] || '0', 10);
				const mm = parseInt(m[2] || '0', 10);
				const ss = parseInt(m[3] || '0', 10);
				const ms = parseInt((m[4] || '0').padEnd(3, '0'), 10);
				return hh * 3600 + mm * 60 + ss + ms / 1000;
			};
			for (const b of blocks) {
				const lines = b.split('\n').filter(Boolean);
				if (!lines.length) continue;
				// skip index line if numeric
				let i = 0;
				if (/^\d+$/.test(lines[0].trim())) i = 1;
				if (!lines[i]) continue;
				const parts = lines[i].split(new RegExp("\\s*-->\\s*"));
				if (parts.length !== 2) continue;
				const start = ts(parts[0]);
				const end = ts(parts[1]);
				const text = lines.slice(i + 1).join('\n');
				if (end > start) cues.push({ start, end, text });
			}
			return cues;
		}

		function clearAllTextTracks(video) {
			try {
				const tracks = video.textTracks || [];
				for (let ti = 0; ti < tracks.length; ti++) {
					const tr = tracks[ti];
					try { tr.mode = 'disabled'; } catch (_) {}
					const cues = tr.cues || [];
					if (cues && cues.length) {
						// HTMLTextTrackCueList is live; remove from the front
						while (tr.cues && tr.cues.length) {
							try { tr.removeCue(tr.cues[0]); } catch (_) { break; }
						}
					}
				}
				// Also clear our reference to any previously created subtitles track
				try { video._subsTrack = null; } catch (_) {}
			} catch (_) {}
		}

		let _io;
		function observeLazy(el) {
			if (!_io) {
				_io = new IntersectionObserver(
				(entries) => {
					entries.forEach((e) => {
						if (e.isIntersecting) {
							const v = e.target;
							if (!v.src && v.dataset.src) {
								v.src = v.dataset.src;
							}
							_io.unobserve(v);
						}
					});
				},
				{root: null, rootMargin: "200px", threshold: 0.01 },
				);
			}
			_io.observe(el);
		}

		let _ioMeta;
		function observeMeta(el, file) {
			if (!_ioMeta) {
				_ioMeta = new IntersectionObserver(
				(entries) => {
					entries.forEach(async (e) => {
						if (!e.isIntersecting) {
							return;
						}
						const tgt = e.target;
						_ioMeta.unobserve(tgt);
						const key = tgt.dataset.metakey;
						if (!key) {
							return;
						}
						if (metaCache.has(key)) {
							tgt.textContent = metaCache.get(key);
							return;
						}
						if (tgt.dataset.loading) {
							return;
						}
						tgt.dataset.loading = "1";
						try {
							const res = await fetch(
							`/api/metadata/get?path=${encodeURIComponent(key)}`,
							{method: "GET" },
							);
							if (res.ok) {
								const j = await res.json();
								const bits = [];
								if (j.duration) {
									bits.push(hhmmss(j.duration));
								}
								if (j.width && j.height) {
									bits.push(`${j.width}×${j.height}`);
								}
								if (j.vcodec) {
									bits.push(j.vcodec);
								}
								if (j.bitrate) {
									const mbps = (j.bitrate / 1e6).toFixed(1);
									bits.push(`${mbps} Mbps`);
								}
								const line = bits.join(" • ");
								metaCache.set(key, line);
								tgt.textContent = line;
							}
							else {
								tgt.textContent = "";
							}
						}
						catch (_) {
							tgt.textContent = "";
						}
						finally {
							delete tgt.dataset.loading;
						}
					});
				},
				{
					root: null,
					rootMargin: "200px",
					threshold: 0.01,
				},
				);
			}
			el.dataset.metakey = file.path;
			_ioMeta.observe(el);
		}

		async function generateCover(file, overrideOffset) {
			const off = overrideOffset != null ? Number(overrideOffset) : parseFloat(
			document.getElementById("coverOffset")?.value || "0", ) || 0;
			const params = new URLSearchParams({path: file.path, t: String(off) });
			if (off >0) params.set("overwrite", "1");
			const res = await fetch(`/api/cover/create?${params.toString()}`, {
				method: "POST",
			});
			return res.ok;
		}

		async function load(path = "", pageOverride) {
			status("Loading…");
			const params = new URLSearchParams();
			if (path) {
				params.set("path", path);
			}
			// Use pageOverride if provided, else currentPage (seeded from URL)
			const pageToRequest = pageOverride !== undefined ? pageOverride : currentPage;
			params.set("page", String(pageToRequest));
			params.set("page_size", String(pageSize));
			// Add search, filter, and sort params
			const searchVal = document.getElementById("searchInput")?.value?.trim();
			if (searchVal) {
				params.set("search", searchVal);
			}
			const sortVal = document.getElementById("sortBy")?.value;
			if (sortVal) {
				params.set("sort", sortVal);
			}
			const orderVal = document.getElementById("sortOrder")?.value;
			if (orderVal) {
				params.set("order", orderVal);
			}
			// Fetch with timeout to avoid hanging UI on slow network/back-end
			const controller = new AbortController();
			const timer = setTimeout(() => controller.abort(), 10000);
			let res;
			try {
				res = await fetch("/api/library?" + params.toString(), {
					method: "GET",
					signal: controller.signal,
				});
			}
			catch (e) {
				clearTimeout(timer);
				status("Error loading");
				return;
			}
			clearTimeout(timer);
			if (!res.ok) {
				status("Error loading");
				return;
			}
			const body = await res.json();
			const data = body.data || body;
			// pagination info available in `data` if needed for debugging
			cwd = data.cwd || "";
			// Always use backend values for pagination
			currentPage = data.page || pageToRequest;
			// Persist current page in URL (omit ?page=1)
			setPageInLocation(currentPage, true);
			totalPages = data.total_pages || 1;
			totalFiles = data.total_files || 0;
			pageSize = data.page_size || pageSize;
			// Only use current page's files for rendering
			renderFiles(data.files || []);
			// Always display backend's total_files and total_pages in paginator
			renderPager(currentPage, totalPages, totalFiles, pageSize);
			// Update allFiles for bulk operations (fetch all files if needed)
			allFiles = data.files || [];
			selectedTile = null;
			selectedFile = null;
			if (infoPanel) {
				infoPanel.innerHTML = "";
			}
			status("OK");
		}

		async function ensureHover(file) {
			// Fast path: backend reported hover preview exists
			if (file.hoverPreview) return file.hoverPreview + `&t=${Date.now()}`;
			const base = `/api/hover/get?path=${encodeURIComponent(file.path)}`;
			// Check if available now
			try {
				const head = await fetch(base + `&t=${Date.now()}`, {
					method: "HEAD",
					cache: "no-store",
				});
				if (head.ok) return base + `&t=${Date.now()}`;
			}
			catch (_) { }
			// Trigger generation (non-blocking if already exists)
			try {
				await fetch(
				`/api/hover/create?path=${encodeURIComponent(file.path)}`,
				{method: "POST" },
				);
			}
			catch (_) { }
			// Poll briefly for readiness so preview can start on first hover
			const maxTries = 12; // ~1.8s @ 150ms
			for (let i = 0; i< maxTries; i++) {
				try {
					const head2 = await fetch(base + `&t=${Date.now()}`, {
						method: "HEAD",
						cache: "no-store",
					});
					if (head2.ok) return base + `&t=${Date.now()}`;
				}
				catch (_) { }
				await new Promise((r) => setTimeout(r, 150));
			}
			return null;
		}

		// Ensure no tiles are currently showing a hover video
		function stopAllTileHovers(exceptTile = null) {
			try {
				const tiles = document.querySelectorAll(".tile");
				tiles.forEach((t) => {
					if (exceptTile && t === exceptTile) return;
					if (typeof t.onmouseleave === "function") {
						try {
							t.onmouseleave();
						}
						catch (_) { }
					}
					else {
						// Best-effort: pause any inline video
						const v = t.querySelector("video.thumb");
						if (v) {
							try {
								v.pause();
							}
							catch (_) { }
							v.removeAttribute("src");
							try {
								v.load();
							}
							catch (_) { }
						}
					}
					t._hovering = false;
				});
			}
			catch (_) { }
		}

		function renderFiles(files) {
			// Render file tiles with preview (image/video/placeholder)
			if (!Array.isArray(files)) return;
			if (!filesEl) return;
			filesEl.innerHTML = "";
			files.forEach((file) => {
				const tile = document.createElement("div");
				tile.className = "tile";
				// Basic structure: name and placeholder (build with DOM APIs)
				const displayTitle = file.title || file.name;
				const placeholder = document.createElement("div");
				placeholder.className = "placeholder";
				placeholder.textContent = "Loading…";
				const nameDiv = document.createElement("div");
				nameDiv.className = "name";
				nameDiv.textContent = esc(displayTitle || file.title || baseName(file.name));
				tile.appendChild(placeholder);
				tile.appendChild(nameDiv);
				tile.onclick = () => {
					selectTile(tile, file);
					showInfo(file);
					// Save last grid tile for back button
					window._lastGridTile = tile;
				};
				tile.ondblclick = () => {
					selectTile(tile, file);
					showTab("Player");
					play(file);
					// Save last grid tile for back button
					window._lastGridTile = tile;
				};
				filesEl.appendChild(tile);
				// Asynchronously load thumbnail
				setTimeout(() => {
					let previewEl;
					if (file.cover) {
						const img = document.createElement("img");
						img.className = "thumb";
						img.src = file.cover;
						img.alt = "cover";
						previewEl = img;
					}
					else if (file.type && file.type.startsWith("video")) {
						const div = document.createElement("div");
						div.className = "placeholder";
						div.textContent = "VIDEO";
						previewEl = div;
					}
					else if (file.type && file.type.startsWith("audio")) {
						const div = document.createElement("div");
						div.className = "placeholder";
						div.textContent = "AUDIO";
						previewEl = div;
					}
					else {
						const div = document.createElement("div");
						div.className = "placeholder";
						div.textContent = "NO PREVIEW";
						previewEl = div;
					}
					const ph = tile.querySelector(".placeholder");
					if (ph && previewEl) {
						ph.replaceWith(previewEl);
					}
					tile.onmouseenter = async () => {
						if (!hoverPreviewsEnabled) return;
						// Stop any other tile's hover video before starting this one
						stopAllTileHovers(tile);
						// Track hover tokens to avoid late insert after mouse leaves
						const token = (tile._hoverToken || 0) + 1;
						tile._hoverToken = token;
						tile._hovering = true;
						const url = await ensureHover(file);
						// If no preview exists, don't swap out the thumbnail
						if (!url) {
							return;
						}
						if (!tile._hovering || tile._hoverToken !== token) return;
						// Double-check no other tiles are showing hover previews
						stopAllTileHovers(tile);
						const current = tile.querySelector(
						".thumb, .placeholder, video.thumb",
						);
						const v = document.createElement("video");
						v.className = "thumb";
						v.src = url;
						v.muted = true;
						v.autoplay = true;
						v.loop = true;
						v.playsInline = true;
						v.style.pointerEvents = "none";
						if (current) current.replaceWith(v);
						try {
							await v.play();
						}
						catch (_) { }
					};
					tile.onmouseleave = () => {
						tile._hovering = false;
						tile._hoverToken = (tile._hoverToken || 0) + 1;
						if (tile._hoverTimer) {
							clearInterval(tile._hoverTimer);
							tile._hoverTimer = null;
						}
						const current = tile.querySelector("video.thumb");
						if (current) {
							current.pause();
							current.src = "";
							current.load();
							if (file.cover) {
								const img = document.createElement("img");
								img.className = "thumb";
								img.src = file.cover;
								current.replaceWith(img);
							}
							else if (file.type && file.type.startsWith("video")) {
								const div = document.createElement("div");
								div.className = "placeholder";
								div.textContent = "VIDEO";
								current.replaceWith(div);
							}
							else if (file.type && file.type.startsWith("audio")) {
								const div = document.createElement("div");
								div.className = "placeholder";
								div.textContent = "AUDIO";
								current.replaceWith(div);
							}
							else {
								const div = document.createElement("div");
								div.className = "placeholder";
								div.textContent = "NO PREVIEW";
								current.replaceWith(div);
							}
						}
					};
				}, 0);
			});
		}

		if (toggleHoversBtn) {
			toggleHoversBtn.onclick = () => {
				hoverPreviewsEnabled = !hoverPreviewsEnabled;
				toggleHoversBtn.dataset.enabled = hoverPreviewsEnabled ? "1" : "0";
				toggleHoversBtn.textContent = hoverPreviewsEnabled ? "Hovers: On" : "Hovers: Off";
				toggleHoversBtn.classList.toggle("active", hoverPreviewsEnabled);
				if (!hoverPreviewsEnabled) {
					// When disabling, immediately stop any active hover previews
					stopAllTileHovers();
				}
			};
			// Reflect default state on load
			toggleHoversBtn.dataset.enabled = hoverPreviewsEnabled ? "1" : "0";
			toggleHoversBtn.textContent = hoverPreviewsEnabled ? "Hovers: On" : "Hovers: Off";
			toggleHoversBtn.classList.toggle("active", hoverPreviewsEnabled);
		}

		function renderPager() {
			if (!pageInfo) {
				return;
			}
			// Use arguments if provided, fallback to globals
			const args = arguments;
			const page = args.length >0 ? args[0] : currentPage;
			const pages = args.length >1 ? args[1] : totalPages;
			const files = args.length >2 ? args[2] : totalFiles;
			const size = args.length >3 ? args[3] : pageSize;
			pageInfo.textContent = `Page ${page} / ${pages} • ${files} files`;
			if (pageSizeInput) {
				pageSizeInput.value = String(size);
			}
			if (prevBtn) {
				prevBtn.disabled = page <= 1;
			}
			if (nextBtn) {
				nextBtn.disabled = page >= pages;
			}
		}
		// Resume position storage
		function resumeKey(path) {return `resume.v1:${path}`; }
		let _lastSavedPosTs = 0;
		function persistPosition() {
			if (!selectedFile || !selectedFile.path) return;
			const now = Date.now();
			if (now - _lastSavedPosTs< 1500) return; // throttle ~1.5s
			_lastSavedPosTs = now;
			try {
				const pos = Math.floor(videoEl.currentTime || 0);
				if (isFinite(pos) && pos >= 0) {
					localStorage.setItem(resumeKey(selectedFile.path), String(pos));
				}
			}
			catch (_) { }
		}
		if (videoEl) {
			videoEl.addEventListener('timeupdate', persistPosition);
			window.addEventListener('beforeunload', persistPosition);
		}

		async function play(file) {
			selectedFile = file;
			const src = `/api/stream?path=${encodeURIComponent(file.path)}`;
			const srtURL = `/api/subtitles/get?path=${encodeURIComponent(file.path)}`;
			videoEl.pause();
			videoEl.innerHTML = "";
			videoEl.classList.remove("hidden");
			playerEl.classList.remove('hidden');
			const source = document.createElement("source");
			if (!source.src) {
				source.src = src;
			}
			source.src = src;
			videoEl.appendChild(source);
			// Helper to force-enable our subtitles track
			const ensureCaptionsVisible = () => {
				try {
					const tt = videoEl._subsTrack || (videoEl.textTracks && Array.from(videoEl.textTracks).find(t => t.kind === 'subtitles'));
					if (tt) {
						try { tt.mode = 'showing'; } catch (_) {}
						try { Array.from(videoEl.textTracks || []).forEach(t => { if (t !== tt) t.mode = 'disabled'; }); } catch (_) {}
					}
				}
				catch (_) { }
			};
			// Attach subtitles by fetching SRT and injecting cues (SRT-only support)
			try {
				const head = await fetch(srtURL, { method: "HEAD" });
				if (head.ok) {
					// Clear any residual tracks/cues
					clearAllTextTracks(videoEl);
					// Create a new text track and populate with cues
					const track = videoEl.addTextTrack('subtitles', 'English', 'en');
					track.mode = 'showing';
					const res = await fetch(srtURL, { method: 'GET', cache: 'no-store' });
					if (res.ok) {
						const srt = await res.text();
						const cues = parseSrtToCues(srt);
						const Cue = window.VTTCue || window.TextTrackCue || window.WebKitTextTrackCue;
						for (const c of cues) {
							try {
								const cue = new Cue(c.start, c.end, c.text);
								// Push captions further up to avoid overlapping controls/nav
								// Use percentage line if supported
								try { cue.snapToLines = false; } catch (_) {}
								try { cue.line = 88; } catch (_) {}
								try { cue.position = 50; } catch (_) {}
								track.addCue(cue);
							} catch (_) { /* ignore broken cue */ }
						}
						ensureCaptionsVisible();
					}
					// Show CC toggle button
					let toggleSubsBtn = document.getElementById("toggleSubsBtn");
					if (!toggleSubsBtn) {
						toggleSubsBtn = document.createElement("button");
						toggleSubsBtn.id = "toggleSubsBtn";
						toggleSubsBtn.className = "btn mt-8";
						toggleSubsBtn.textContent = "Hide Subtitles";
						const setThumbBtn = document.getElementById("setThumbBtn");
						if (setThumbBtn) {
							setThumbBtn.parentNode.insertBefore(
								toggleSubsBtn,
								setThumbBtn.nextSibling,
							);
						}
					}
					toggleSubsBtn.style.display = "";
					toggleSubsBtn.onclick = () => {
						const tt = videoEl._subsTrack || (videoEl.textTracks && Array.from(videoEl.textTracks).find(t => t.kind === 'subtitles'));
						if (!tt) return;
						const next = tt.mode === 'showing' ? 'disabled' : 'showing';
						try { tt.mode = next; } catch (_) {}
						try { Array.from(videoEl.textTracks || []).forEach(t => { if (t !== tt) t.mode = 'disabled'; }); } catch (_) {}
						toggleSubsBtn.textContent = next === 'showing' ? 'Hide Subtitles' : 'Show Subtitles';
					};
				} else {
					const toggleSubsBtn = document.getElementById("toggleSubsBtn");
					if (toggleSubsBtn) toggleSubsBtn.style.display = "none";
				}
			} catch (_) { }
			// Persist last played video for reload restore
			try {
				// TODO @copilot: reference to versions
				const LAST_VIDEO_KEY = 'lastVideo.v1';
				const name = file.name || (file.path ? file.path.split('/').pop() : '');
				const payload = {path: file.path, name, title: file.title || '' };
				localStorage.setItem(LAST_VIDEO_KEY, JSON.stringify(payload));
			}
			catch (_) { }
			metaEl.textContent = file.title || baseName(file.name);
			videoEl.load();
			// Apply resume position before playback begins
			const applyResume = () => {
				try {
					const key = resumeKey(file.path);
					const saved = parseFloat(localStorage.getItem(key) || '');
					const dur = videoEl.duration || 0;
					if (isFinite(saved) && saved >0 && dur && saved< Math.max(1, dur - 1)) {
						videoEl.currentTime = saved;
					}
				}
				catch (_) { }
			};
			if (videoEl.readyState >= 1) {
				applyResume();
			}
			else {
				await new Promise((resolve) => {
					const onMeta = () => {videoEl.removeEventListener('loadedmetadata', onMeta); resolve(); };
					videoEl.addEventListener('loadedmetadata', onMeta);
				});
				applyResume();
			}
			// Warm up scrubbing sprites so previews are ready
			try {
				if (window.ensureSprites) {
					await window.ensureSprites();
				}
			}
			catch (_) { }
			try {
				await videoEl.play();
			}
			catch (_) { }
			// Load and render scenes and heatmaps overlays
			renderOverlaysForFile(file).catch(() => {});
			// Refresh markers when duration becomes available
			videoEl.onloadedmetadata = () => {
				renderOverlaysForFile(file).catch(() => {});
				// Ensure our subtitles track (if any) is shown and others disabled
				try {
					const tt = videoEl._subsTrack || (videoEl.textTracks && Array.from(videoEl.textTracks).find(t => t.kind === 'subtitles'));
					if (tt) {
						try { tt.mode = 'showing'; } catch (_) {}
						try { Array.from(videoEl.textTracks || []).forEach(t => { if (t !== tt) t.mode = 'disabled'; }); } catch (_) {}
					}
				} catch (_) {}
				if (controlsBar && getTabFromLocation() === "Player")
					controlsBar.classList.remove("hidden");
			};
		}

		async function renderOverlaysForFile(file) {
			if (!file) return;
			// Scenes
			let scenes = null;
			try {
				const res = await fetch(`/api/scenes/get?path=${encodeURIComponent(file.path)}`);
				if (res.ok) {
					const body = await res.json();
					scenes = (body.data && (body.data.markers || body.data.scenes || body.data.markers)) 
						|| body.markers 
						|| null;
					if (Array.isArray(body.data?.markers)) scenes = body.data.markers;
				}
			}
			catch (_) { }
			renderChapters(scenes, file);
			// Heatmaps: prefer PNG for speed; fallback to JSON gradient
			let heatmapURL = null;
			try {
				const resP = await fetch(`/api/heatmaps/png?path=${encodeURIComponent(file.path)}`);
				if (resP.ok) {
					// Blob URL to avoid re-requesting
					const blob = await resP.blob();
					heatmapURL = URL.createObjectURL(blob);
				}
			}
			catch (_) { }
			if (heatmapURL) {
				renderHeatmapStripe({type: "png", url: heatmapURL });
			}
			else {
				try {
					const resJ = await fetch( `/api/heatmaps/json?path=${encodeURIComponent(file.path)}`);
					if (resJ.ok) {
						const body = await resJ.json();
						const data = (body.data && body.data.heatmaps) || body.heatmaps;
						renderHeatmapStripe({type: "json", data });
					}
					else {
						renderHeatmapStripe(null);
					}
				}
				catch (_) {
					renderHeatmapStripe(null);
				}
			}
			if (controlsBar && getTabFromLocation() === "Player")
			controlsBar.classList.remove("hidden");
		}

		function renderChapters(scenes, file) {
			if (!chaptersBar) return;
			chaptersBar.innerHTML = "";
			const duration = videoEl.duration || file?.duration || 0;
			if (!duration || !Array.isArray(scenes)) return;
			// scenes entries could be {time,score} or tuples; normalize
			const times = scenes
			.map((s) => typeof s === "number" ? s : (s.time ?? s[0] ?? s.t ?? null))
			.filter((t) => typeof t === "number");
			times.forEach((t) => {
				const pct = Math.min(99.9, Math.max(0, (t / duration) * 100));
				const m = document.createElement("div");
				m.className = "marker";
				m.style.left = pct + "%";
				// clicking a marker seeks to its time
				m.style.pointerEvents = "auto";
				m.title = `Scene @ ${hhmmss(t)}`;
				m.addEventListener("click", (ev) => {
					ev.stopPropagation();
					try {
						videoEl.currentTime = t;
					}
					catch (_) { }
				});
				chaptersBar.appendChild(m);
			});
		}

		function renderHeatmapStripe(payload) {
			if (!heatmapStripe) return;
			heatmapStripe.style.backgroundImage = "";
			heatmapStripe.style.background = "#111";
			if (!payload) return;
			if (payload.type === "png" && payload.url) {
				heatmapStripe.style.backgroundImage = `url('${payload.url}')`;
				heatmapStripe.style.backgroundRepeat = "no-repeat";
				heatmapStripe.style.backgroundSize = "100% 100%";
				return;
			}
			if (payload.type === "json" && payload.data) {
				const data = payload.data;
				const samples = data.samples || [];
				if (!samples.length) return;
				// Build CSS gradient; use brightness by default, overlay motion as stripes
				const stops = samples.map((s, i) => {
					const t = s.t ?? s.time ?? (i / samples.length) * 100;
					const brightness = Math.max(0, Math.min(255, s.brightness ?? 0));
					const color = `rgb(${brightness},${brightness},${brightness})`;
					const pct = Math.max(0, Math.min(100, (i / (samples.length - 1)) * 100));
					return `${color} ${pct}%`;
				});
				heatmapStripe.style.backgroundImage = `linear-gradient(to right, ${stops.join(",")})`;
			}
		}

		// Seek behavior on overlay
		if (controlsProgress) {
			const seekFromEvent = (ev) => {
				const rect = controlsProgress.getBoundingClientRect();
				const x = (ev.touches ? ev.touches[0].clientX : ev.clientX) - rect.left;
				const pct = Math.max(0, Math.min(1, x / rect.width));
				if (!isNaN(videoEl.duration)) {
					videoEl.currentTime = pct * videoEl.duration;
				}
			};
			// Hover scrubbing preview using sprite sheet when available
			let spriteData = null; // {index:{...}, sheetUrl:string}
			let previewEl = null;
			const spritesRequested = new Set(); // track files we've kicked off generation for
			async function ensureSprites() {
				if (!selectedFile) return null;
				if (spriteData && spriteData.file === selectedFile.path)
				return spriteData;
				// Try to fetch existing sprites first
				const tryFetch = async () => {
					const res = await fetch(`/api/sprites/json?path=${encodeURIComponent(selectedFile.path)}`);
					if (!res.ok) return null;
					const body = await res.json();
					const index = (body.data && body.data.index) || body.index;
					const sheetUrl = (body.data && body.data.sheet) || body.sheet;
					return {index, sheetUrl };
				};
				try {
					let data = await tryFetch();
					if (!data) {
						// If missing, kick off generation once for this file, then poll briefly
						const key = selectedFile.path;
						if (!spritesRequested.has(key)) {
							spritesRequested.add(key);
							try {
								await fetch( `/api/sprites/create?path=${encodeURIComponent(key)}`, {method: "POST" }, );
							}
							catch (_) { }
						}
						// Poll up to ~12s for readiness (sprite extraction can take longer)
						const deadline = Date.now() + 12000;
						while (!data && Date.now()< deadline) {
							await new Promise((r) => setTimeout(r, 300));
							data = await tryFetch();
						}
					}
					if (!data) {
						spriteData = null;
						return null;
					}
					spriteData = {...data, file: selectedFile.path };
					return spriteData;
				}
				catch (_) {
					spriteData = null;
					return null;
				}
			}
			// Expose for warm-up from play()
			try {window.ensureSprites = ensureSprites; }
			catch (_) { }
			function ensurePreviewEl() {
				if (previewEl) return previewEl;
				previewEl = document.createElement("div");
				previewEl.className = "sprite-preview";
				const wrap = document.querySelector('.player-media');
				if (wrap) wrap.appendChild(previewEl);
				else document.body.appendChild(previewEl);
				return previewEl;
			}
			function updatePreviewPosition(clientX) {
				const wrap = document.querySelector('.player-media');
				const wrect = wrap ? wrap.getBoundingClientRect() : {left: 0 };
				const prect = controlsProgress.getBoundingClientRect();
				const clamped = Math.max(prect.left + 8, Math.min(prect.right - 8, clientX));
				const localX = clamped - wrect.left; // position within wrapper relative to controls
				ensurePreviewEl();
				previewEl.style.left = `${localX}px`;
			}
			function showSpriteAt(pct) {
				if (!spriteData) return;
				const idx = spriteData.index;
				const frames = idx.frames || idx.cols * idx.rows;
				if (!frames) return;
				const i = Math.max(0, Math.min(frames - 1, Math.floor(pct * frames)));
				const col = i % idx.cols;
				const row = Math.floor(i / idx.cols);
				const tw = idx.tile_width || 160;
				const th = idx.tile_height || 90;
				const x = -col * tw;
				const y = -row * (idx.tile_height || th);
				previewEl.style.backgroundImage = `url('${spriteData.sheetUrl}')`;
				previewEl.style.backgroundSize = `${idx.cols * tw}px ${idx.rows * (idx.tile_height || th)}px`;
				previewEl.style.backgroundPosition = `${x}px ${y}px`;
				previewEl.style.width = `${tw}px`;
				previewEl.style.height = `${idx.tile_height || th}px`;
				// Must force visible to override CSS .sprite-preview {display: none }
				previewEl.style.display = "block";
			}
			controlsProgress.addEventListener("mousemove", async (e) => {
				const rect = controlsProgress.getBoundingClientRect();
				const x = e.clientX - rect.left;
				const pct = Math.max(0, Math.min(1, x / rect.width));
				updatePreviewPosition(e.clientX);
				const s = await ensureSprites();
				if (s) showSpriteAt(pct);
			});
			controlsProgress.addEventListener("mouseleave", () => {
				if (previewEl) previewEl.style.display = "none";
			});
			controlsProgress.addEventListener("click", seekFromEvent);
			let dragging = false;
			controlsProgress.addEventListener("mousedown", (e) => {
				dragging = true;
				seekFromEvent(e);
			});
			window.addEventListener("mousemove", (e) => {
				if (dragging) seekFromEvent(e);
			});
			window.addEventListener("mouseup", () => (dragging = false));
			controlsProgress.addEventListener("touchstart",
				(e) => {
					dragging = true;
					seekFromEvent(e);
				},
			{passive: true});
			controlsProgress.addEventListener("touchmove",
			(e) => {
				if (dragging) seekFromEvent(e);
			}, {passive: true});
			window.addEventListener("touchend", () => (dragging = false), {
				passive: true,
			});
		}

		/* duplicate startJobsSSE removed: using the primary implementation in Tasks section */

		// Control listeners setup
		function setupControlListeners() {
			document.getElementById("searchInput").addEventListener("input", () => {
				currentPage = 1;
				load(cwd);
			});
			document.getElementById("sortBy").addEventListener("change", () => {
				currentPage = 1;
				load(cwd);
			});
			document.getElementById("sortOrder").addEventListener("change", () => {
				currentPage = 1;
				load(cwd);
			});
			document.getElementById("gridSize").addEventListener("change", () => {
				load(cwd);
			});
			if (pageSizeInput) {
				pageSizeInput.addEventListener("change", () => {
					let v = parseInt(pageSizeInput.value, 10);
					if (v >0) {
						if (v % 4 !== 0) {
							v = Math.round(v / 4) * 4;
						}
						pageSizeInput.value = v;
						pageSize = v;
						currentPage = 1;
						load(cwd);
					}
				});
			}
		}

		// Auto-load root folder on page load
		window.addEventListener("DOMContentLoaded", async () => {
			// Wire up set thumbnail button logic
			const setThumbBtn = document.getElementById("setThumbBtn");
			const setMarkerBtn = document.getElementById("setMarkerBtn");
			if (setThumbBtn) {
				setThumbBtn.onclick = async () => {
					if (!selectedFile) return;
					const currentTime = Math.floor(videoEl.currentTime || 0);
					setThumbBtn.disabled = true;
					setThumbBtn.textContent = "Setting thumbnail…";
					// Use correct API: POST to /api/create_cover?path=...&t=...
					// Always use 't' as the timestamp query param for backend
					const res = await fetch(`/api/cover/create?path=${encodeURIComponent(selectedFile.path)}&t=${currentTime}&overwrite=1`, {method: "POST" });
					if (res.ok) {
						setThumbBtn.textContent = "Thumbnail set!";
						// Use a unique timestamp to force browser to reload the image
						const uniqueTs = Date.now() + Math.floor(Math.random() * 10000);
						const metaRes = await fetch( `/api/metadata/get?path=${encodeURIComponent(selectedFile.path)}`, {method: "GET" } );
						let updatedFile = selectedFile;
						if (metaRes.ok) {
							const meta = await metaRes.json();
							const metaBody = meta.data || meta;
							updatedFile = {
								...selectedFile,
								...metaBody,
								cover: `/api/cover/get?path=${encodeURIComponent(selectedFile.path)}&t=${uniqueTs}`,
							};
						}
						else {
							updatedFile = {
								...selectedFile,
								cover: `/api/cover/get?path=${encodeURIComponent(selectedFile.path)}&t=${uniqueTs}`,
							};
						}
						showInfo(updatedFile);
					}
					else {
						setThumbBtn.textContent = "Failed to set thumbnail";
					}
					setTimeout(() => {
						setThumbBtn.textContent = "Set Thumbnail from Current Frame";
						setThumbBtn.disabled = false;
					}, 2000);
				};
				// Only show button in Player tab
				setThumbBtn.style.display = "none";
			}
			if (setMarkerBtn) {
				setMarkerBtn.onclick = async () => {
					if (!selectedFile || !selectedFile.path) return;
					const t = Math.max(0, Math.min(videoEl.duration || 0, videoEl.currentTime || 0));
					try {
						await fetch(`/api/marker?path=${encodeURIComponent(selectedFile.path)}&time=${encodeURIComponent(t)}`, { method: 'POST' });
						// Refresh scenes overlay to show the new marker immediately
						await renderOverlaysForFile(selectedFile);
					} catch (_) {}
				};
				// Only show button in Player tab
				setMarkerBtn.style.display = "none";
			}
			setupControlListeners();
			mountSpritePreviewInPlayer();
			// Ensure backend root is set before attempting to restore/load; if not provided, proceed with existing backend root
			try {
				const v = (rootInput && rootInput.value) ? rootInput.value.trim() : "";
				if (v) {
					status("Setting root…");
					// Verify path quickly to avoid hanging on bad roots
					const tp = await fetch("/api/testpath?" + new URLSearchParams({path: v }).toString(), {method: "POST" });
					let okToSet = false;
					if (tp.ok) {
						const tjson = await tp.json();
						const tdata = tjson.data || tjson;
						okToSet = !!(tdata && tdata.exists && tdata.is_dir);
					}
					if (okToSet) {
						const params = new URLSearchParams({root: v });
						const res = await fetch("/api/setroot?" + params.toString(), {method: "POST" });
						if (res.ok) {
							currentPage = 1;
							cwd = "";
							await load("");
						}
						else {
							// Fall back to current root
							await load("");
						}
					}
					else {
						// Invalid path typed; just load current root
						await load("");
					}
				}
				else {
					// No root provided; use existing server root
					await load("");
				}
			}
			catch (_) {
				// On any error, attempt to load current root rather than hang
				try {await load(""); }
				catch (_) { }
			}
			// Initialize tab from URL (hash) or default to Grid without pushing a new history entry
			const initialTab = getTabFromLocation() || "Grid";
			showTab(initialTab, true);
			try {setRouteForTab(initialTab, true); }
			catch (_) { }
			// Restore last played video (set selection always; autoplay only when on Player)
			try {
				const LAST_VIDEO_KEY = 'lastVideo.v1';
				const raw = localStorage.getItem(LAST_VIDEO_KEY);
				if (raw) {
					const rec = JSON.parse(raw);
					if (rec && rec.path) {
						const file = {
							path: rec.path,
							name: rec.name || (rec.path.split('/').pop() || rec.path),
							title: rec.title || '',
						};
						selectedFile = file;
						if (initialTab === 'Player') {
							await play(file);
						}
					}
				}
			}
			catch (_) { }
		});

		// Handle back/forward navigation for tabs
		window.addEventListener("popstate", async () => {
			const t = getTabFromLocation() || "Grid";
			const p = getPageFromLocation();
			currentPage = p;
			await showTab(t, true);
			// If grid/list visible, reload to reflect page from URL
			if (t === 'Grid' || t === 'List') {
				await load(cwd, p);
			}
		});
		window.addEventListener("hashchange", async () => {
			const t = getTabFromLocation() || "Grid";
			await showTab(t, true);
		});

		if (prevBtn) {
			prevBtn.onclick = async () => {
				if (currentPage >1) {
					const p = currentPage - 1;
					setPageInLocation(p);
					await load(cwd, p);
				}
			};
		}
		if (nextBtn) {
			nextBtn.onclick = async () => {
				if (currentPage< totalPages) {
					const p = currentPage + 1;
					setPageInLocation(p);
					await load(cwd, p);
				}
			};
		}
		if (pageSizeInput) {
			pageSizeInput.onchange = async () => {
				let v = parseInt(pageSizeInput.value, 10);
				if (v > 0) {
					// Only allow multiples of 4 or 8
					if (v % 4 !== 0) v = Math.round(v / 4) * 4;
					pageSizeInput.value = v;
					pageSize = v;
					currentPage = 1;
					setPageInLocation(currentPage);
					await load(cwd, currentPage);
				}
			};
		}

		const gridSizeInput = document.getElementById("gridSize");
		if (gridSizeInput) {
			gridSizeInput.onchange = () => {
				const cols = parseInt(gridSizeInput.value, 10) || 4;
				// TODO @copilot: there must be a better way to do this
				filesEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
			};
			filesEl.style.gridTemplateColumns = `repeat(${gridSizeInput.value}, 1fr)`;
		}

		document.addEventListener("keydown", (e) => {
			// Always allow space/arrow keys for player and grid navigation
			if (document.activeElement && ["INPUT", "TEXTAREA"].includes(document.activeElement.tagName)) return;
			const tiles = Array.from(document.querySelectorAll(".tile"));
			let idx = tiles.indexOf(selectedTile);
			let cols = parseInt(document.getElementById("gridSize").value, 10) || 4;
			if (e.code === "Space") {
				if (!videoEl.classList.contains("hidden")) {
					e.preventDefault();
					if (videoEl.paused) {
						videoEl.play();
					}
					else {
						videoEl.pause();
					}
				}
				else {
					if (selectedTile && tiles.length) {
						selectedTile.click();
					}
				}
			}
			else if (e.code === "ArrowLeft") {
				if (!videoEl.classList.contains("hidden")) {
					e.preventDefault();
					try {
						videoEl.currentTime = Math.max(0, (videoEl.currentTime || 0) - 5);
					}
					catch (_) { }
				}
				else {
					if (idx >0) {
						tiles[idx - 1].click();
						tiles[idx - 1].scrollIntoView({
							block: "nearest",
							inline: "nearest",
						});
						e.preventDefault();
					}
				}
			}
			else if (e.code === "ArrowRight") {
				if (!videoEl.classList.contains("hidden")) {
					e.preventDefault();
					try {
						videoEl.currentTime = (videoEl.currentTime || 0) + 5;
					}
					catch (_) { }
				}
				else {
					if (idx< tiles.length - 1) {
						tiles[idx + 1].click();
						tiles[idx + 1].scrollIntoView({
							block: "nearest",
							inline: "nearest",
						});
						e.preventDefault();
					}
				}
			}
			else if (e.code === "ArrowDown") {
				if (idx + cols< tiles.length) {
					tiles[idx + cols].click();
					tiles[idx + cols].scrollIntoView({
						block: "nearest",
						inline: "nearest",
					});
					e.preventDefault();
				}
			}
			else if (e.code === "ArrowUp") {
				if (idx - cols >= 0) {
					tiles[idx - cols].click();
					tiles[idx - cols].scrollIntoView({
						block: "nearest",
						inline: "nearest",
					});
					e.preventDefault();
				}
			}
		});

		// Add 'Random' to sort dropdown
		const sortBySelect = document.getElementById("sortBy");
		if ( sortBySelect && !Array.from(sortBySelect.options).some((opt) => opt.value === "random") ) {
			const randomOption = document.createElement("option");
			randomOption.value = "random";
			randomOption.textContent = "Random";
			sortBySelect.appendChild(randomOption);
		}
		// Add 'Play Random Video' button at the top
		const controlsDiv = document.getElementById("gridControls");
		if (controlsDiv && !document.getElementById("playRandomBtn")) {
			const playRandomBtn = document.createElement("button");
			playRandomBtn.id = "playRandomBtn";
			playRandomBtn.className = "btn";
			playRandomBtn.textContent = "Random";
			controlsDiv.insertBefore(playRandomBtn, controlsDiv.firstChild);
			playRandomBtn.onclick = async () => {
				// Fetch all files (all pages)
				let allMediaFiles = [];
				let page = 1;
				let pageSize = 500;
				let totalPages = 1;
				do {
					const params = new URLSearchParams();
					params.set("page", String(page));
					params.set("page_size", String(pageSize));
					// Use current filters (search only)
					const searchVal = document
					.getElementById("searchInput")
					?.value?.trim();
					if (searchVal) params.set("search", searchVal);
					params.set("sort", "name"); // Always fetch all, don't sort random here
					const res = await fetch("/api/library?" + params.toString(), {
						method: "GET",
					});
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					allMediaFiles = allMediaFiles.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				if (allMediaFiles.length === 0) {
					alert("No videos found!");
					return;
				}
				const randomIdx = Math.floor(Math.random() * allMediaFiles.length);
				const file = allMediaFiles[randomIdx];
				play(file);
			};
		}

		// List tab logic
		// Column config
		const LIST_COLS_KEY = "listCols.v2";
		const defaultListCols = [
			{key: "name", label: "Name", align: "left", width: 320, visible: true, source: "basic" },
			{key: "size", label: "Size", align: "right", width: 100, visible: true, source: "basic" },
			{key: "duration", label: "Duration", align: "right", width: 110, visible: true, source: "basic" },
			{key: "codecs", label: "Codecs", align: "left", width: 160, visible: true, source: "basic" },
			{key: "tags", label: "Tags", align: "left", width: 200, visible: true, source: "basic" },
			// Artifacts (hidden by default)
			{key: "art.cover", label: "Cover", align: "center", width: 80, visible: false, source: "artifact" },
			{key: "art.hover", label: "Hover", align: "center", width: 80, visible: false, source: "artifact" },
			{key: "art.sprites", label: "Sprites", align: "center", width: 80, visible: false, source: "artifact" },
			{key: "art.subtitles", label: "Subtitles", align: "center", width: 92, visible: false, source: "artifact" },
			{key: "art.phash", label: "pHash", align: "center", width: 80, visible: false, source: "artifact" },
			{key: "art.heatmaps", label: "Heatmaps", align: "center", width: 92, visible: false, source: "artifact" },
			{key: "art.scenes", label: "Scenes", align: "center", width: 80, visible: false, source: "artifact" },
			{key: "art.faces", label: "Faces", align: "center", width: 80, visible: false, source: "artifact" },
		];
		function getListCols() {
			try {
				const raw = localStorage.getItem(LIST_COLS_KEY);
				if (!raw) return defaultListCols.slice();
				const parsed = JSON.parse(raw);
				if (!Array.isArray(parsed)) return defaultListCols.slice();
				// merge to ensure any new defaults are included
				const byKey = Object.fromEntries(parsed.map(c => [c.key, c]));
				const merged = defaultListCols.map(d => ({...d, ...(byKey[d.key] || {}) }));
				// include any legacy/custom keys
				parsed.forEach(c => {if (!merged.find(m => m.key === c.key)) merged.push(c); });
				return merged;
			}
			catch {
				return defaultListCols.slice();
			}
		}
		function setListCols(cols) {
			localStorage.setItem(LIST_COLS_KEY, JSON.stringify(cols));
		}
		// Metadata discovery cache
		const metaRawCache = new Map(); // path ->raw ffprobe json
		let discoveredMetaKeys = new Set();

		function renderListColumnsPanel() {
			const panel = document.getElementById("listColumnsPanel");
			if (!panel) return;
			const cols = getListCols();
			// TODO @copilot: avoid this. use static html that's hidden until needed
			panel.innerHTML = `
				<div class="row"><strong>Columns</strong><span class="muted">(drag to reorder)</span></div>
				<div class="section">
					<div class="muted">Basics & Artifacts</div>
					<div id="listColsChoices" class="choices"></div>
				</div>
				<div class="section">
					<div class="row">
						<strong>ffprobe metadata</strong>
						<input id="metaFilter" type="text" placeholder="filter…" />
						<button id="discoverMetaBtn" class="btn">Discover ffprobe keys</button>
					</div>
					<div id="metaColsChoices" class="choices"></div>
				</div>
				<div class="row">
					<button id="resetListColsBtn" class="btn">Reset</button>
				</div>
			`;
			const choices = panel.querySelector("#listColsChoices");
			cols.forEach((c, idx) => {
				const id = `col_${c.key}`;
				const wrap = document.createElement("div");
				wrap.className = "row";
				wrap.style.alignItems = "center";
				wrap.style.gap = "8px";
				wrap.draggable = true;
				wrap.dataset.index = String(idx);
				// TODO @copilot: avoid this. use static html that's hidden until needed
				wrap.innerHTML = `<input type="checkbox" id="${id}" ${c.visible ? "checked" : ""}/><label for="${id}">${esc(c.label)}</label>`;
				// drag to reorder
				wrap.addEventListener("dragstart", (e) => {
					wrap.classList.add("dragging-col");
					e.dataTransfer?.setData("text/plain", String(wrap.dataset.index || idx));
				});
				wrap.addEventListener("dragend", () => wrap.classList.remove("dragging-col"));
				wrap.addEventListener("dragover", (e) => e.preventDefault());
				wrap.addEventListener("drop", (e) => {
					e.preventDefault();
					const from = parseInt(e.dataTransfer?.getData("text/plain") || "-1", 10);
					const to = parseInt(wrap.dataset.index || String(idx), 10);
					if (from >= 0 && from !== to) {
						const cur = getListCols();
						const [moved] = cur.splice(from, 1);
						cur.splice(to, 0, moved);
						setListCols(cur);
						renderListHeader();
						// re-open panel to reflect order
						renderListColumnsPanel();
						loadListRows(lastListDataCache || []);
					}
				});
				choices.appendChild(wrap);
				const cb = wrap.querySelector("input");
				cb.addEventListener("change", () => {
					const cur = getListCols();
					cur[idx].visible = cb.checked;
					setListCols(cur);
					renderListHeader();
					loadListRows(lastListDataCache || []);
				});
			});
			// metadata choices
			const metaChoices = panel.querySelector('#metaColsChoices');
			function renderMetaChoices() {
				if (!metaChoices) return;
				metaChoices.innerHTML = '';
				const filterVal = (panel.querySelector('#metaFilter')?.value || '').toLowerCase();
				const keys = Array.from(discoveredMetaKeys).sort();
				keys.forEach((k) => {
					if (filterVal && !k.toLowerCase().includes(filterVal)) return;
					const id = `mcol_${k.replace(/[^a-zA-Z0-9_.-]/g,'_')}`;
					const row = document.createElement('div');
					row.className = 'row';
					row.style.alignItems = 'center';
					row.style.gap = '8px';
					const existing = getListCols().find(c => c.source === 'meta' && c.key === k);
					// TODO @copilot: avoid this. use static html that's hidden until needed
					row.innerHTML = `<input type="checkbox" id="${id}" ${existing ? 'checked' : ''}/><label for="${id}">${esc(k)}</label>`;
					metaChoices.appendChild(row);
					const cb = row.querySelector('input');
					cb.addEventListener('change', () => {
						const cur = getListCols();
						if (cb.checked) {
							if (!existing) {
								cur.push({key: k, label: k, align: 'left', width: 160, visible: true, source: 'meta' });
							}
						}
						else {
							const idx = cur.findIndex(c => c.source === 'meta' && c.key === k);
							if (idx >= 0) cur.splice(idx, 1);
						}
						setListCols(cur);
						renderListHeader();
						loadListRows(lastListDataCache || []);
						renderMetaChoices();
					});
				});
			}
			panel.querySelector('#metaFilter')?.addEventListener('input', renderMetaChoices);
			const discoverBtn = panel.querySelector('#discoverMetaBtn');
			if (discoverBtn) {
				discoverBtn.addEventListener('click', async () => {
					await discoverMetadataKeys();
					renderMetaChoices();
				});
			}
			renderMetaChoices();
			const resetBtn = panel.querySelector("#resetListColsBtn");
			resetBtn.addEventListener("click", () => {
				setListCols(defaultListCols);
				renderListHeader();
				renderListColumnsPanel();
				loadListRows(lastListDataCache || []);
			});
		}
		function renderListHeader() {
			const row = document.getElementById("listHeaderRow");
			if (!row) return;
			row.innerHTML = "";
			const cols = getListCols().filter(c => c.visible !== false);
			cols.forEach((c, idx) => {
				const th = document.createElement("th");
				th.className = `th text-${c.align || "left"}`;
				th.draggable = true;
				th.dataset.key = c.key;
				th.dataset.index = String(idx);
				if (c.width) th.style.width = c.width + "px";
				// TODO @copilot: avoid this. use static html that's hidden until needed
				th.innerHTML = `<span>${esc(c.label)}</span><span class="col-resizer" data-idx="${idx}"></span>`;
				// drag reorder
				th.addEventListener("dragstart", (e) => {
					th.classList.add("dragging-col");
					e.dataTransfer?.setData("text/plain", String(th.dataset.index || idx));
				});
				th.addEventListener("dragend", () => th.classList.remove("dragging-col"));
				th.addEventListener("dragover", (e) => e.preventDefault());
				th.addEventListener("drop", (e) => {
					e.preventDefault();
					const from = parseInt(e.dataTransfer?.getData("text/plain") || "-1", 10);
					let to = parseInt(th.dataset.index || String(idx), 10);
					// If dropped on right half, insert after
					const rect = th.getBoundingClientRect();
					const mid = rect.left + rect.width / 2;
					if ((e.clientX || 0) >mid) to = to + 1;
					if (from >= 0 && from !== to) {
						// reorder on full config preserving hidden columns order
						const curAll = getListCols();
						const visible = curAll.filter(c => c.visible !== false);
						const hidden = curAll.filter(c => c.visible === false);
						const [moved] = visible.splice(from, 1);
						// Clamp to bounds
						const toIdx = Math.max(0, Math.min(visible.length, to));
						visible.splice(toIdx, 0, moved);
						const merged = [];
						// maintain original order but with new visible ordering
						visible.forEach(v => merged.push(v));
						hidden.forEach(h => merged.push(h));
						setListCols(merged);
						renderListHeader();
						loadListRows(lastListDataCache || []);
					}
				});
				// resize handle
				const handle = th.querySelector(".col-resizer");
				handle.addEventListener("mousedown", (e) => {
					e.preventDefault();
					e.stopPropagation();
					const startX = e.clientX;
					const startW = th.getBoundingClientRect().width;
					function onMove(ev) {
						const dx = ev.clientX - startX;
						const newW = Math.max(60, Math.round(startW + dx));
						th.style.width = newW + "px";
					}
					function onUp() {
						window.removeEventListener("mousemove", onMove);
						window.removeEventListener("mouseup", onUp);
						// persist width to config
						const key = th.dataset.key;
						const cur = getListCols();
						const found = cur.find(c => c.key === key);
						if (found) {
							const w = Math.round(th.getBoundingClientRect().width);
							found.width = w;
							setListCols(cur);
						}
					}
					window.addEventListener("mousemove", onMove);
					window.addEventListener("mouseup", onUp);
				});
				row.appendChild(th);
			});
		}
		function cellText(col, v) {
			if (col.source === 'artifact') {
				const art = v.artifacts || {};
				const key = col.key.replace('art.', '');
				// TODO @copilot: fix these. hover as hover, scenes as scenes. is this even necessary? 
				const alt = v[key] || v[{
					cover: 'cover', 
					hover: 'hoverPreview', 
					sprites: 'scrubThumbs', 
					subtitles: 'subtitles', 
					phash: 'phash', 
					heatmaps: 'heatmaps', 
					scenes: 'chapters', 
					faces: 'faces'
				}[key]];
				const val = (art[key] !== undefined ? art[key] : (alt !== undefined ? alt : false));
				return val ? '✅' : '—';
			}
			if (col.source === 'meta') {
				return '…'; // will be filled asynchronously
			}
			switch (col.key) {
				case "name": return esc(v.name);
				case "size": return human(v.size || 0);
				case "duration": return hhmmss(v.duration || 0);
				case "codecs": return [v.vcodec || "", v.acodec || ""].filter(Boolean).join(" / ");
				case "tags": return Array.isArray(v.tags) ? v.tags.join(", ") : "";
				default: return esc(v[col.key] ?? "");
			}
		}
		function getByPath(obj, path) {
			try {
				const parts = String(path).split('.');
				let cur = obj;
				for (const p of parts) {
					const m = p.match(/^(\w+)(?:\[(\d+)\])?$/);
					if (!m) return undefined;
					const key = m[1];
					const idx = m[2] != null ? parseInt(m[2], 10) : null;
					cur = cur?.[key];
					if (idx != null) cur = Array.isArray(cur) ? cur[idx] : undefined;
					if (cur == null) return undefined;
				}
				return cur;
			}
			catch {return undefined; }
		}
		async function ensureMetadata(path) {
			if (metaRawCache.has(path)) return metaRawCache.get(path);
			try {
				const res = await fetch(`/api/metadata/get?path=${encodeURIComponent(path)}&view=1`);
				if (!res.ok) return null;
				const j = await res.json();
				const raw = j?.data?.raw ?? j?.raw ?? null;
				if (raw) metaRawCache.set(path, raw);
				return raw;
			}
			catch {return null; }
		}
		async function fillMetaCellsForRow(tr, v) {
			const cells = tr.querySelectorAll('[data-meta-path]');
			if (!cells.length) return;
			const raw = await ensureMetadata(v.path);
			cells.forEach((td) => {
				const p = td.getAttribute('data-meta-path');
				let val = raw ? getByPath(raw, p) : undefined;
				if (val == null) td.textContent = '';
				else if (typeof val === 'object') td.textContent = JSON.stringify(val);
				else td.textContent = String(val);
			});
		}
		function _listRow(v) {
			const tr = document.createElement("tr");
			const cols = getListCols().filter(c => c.visible !== false);
			cols.forEach((c) => {
				const td = document.createElement("td");
				td.className = `td text-${c.align || "left"}`;
				if (c.width) td.style.width = c.width + "px";
				const txt = cellText(c, v);
				if (c.source === 'meta') {
					td.textContent = txt;
					td.dataset.metaPath = c.key; // meta path key
				}
				else {
					td.textContent = txt;
				}
				tr.appendChild(td);
			});
			tr.addEventListener("click", () => {
				selectedFile = {
					path: v.path,
					name: v.name,
					size: v.size,
					duration: v.duration,
					cover: v.cover,
					title: v.title,
				};
				showInfo(selectedFile);
			});
			tr.addEventListener("dblclick", () => {
				if (!selectedFile || selectedFile.path !== v.path) {
					selectedFile = {
						path: v.path,
						name: v.name,
						size: v.size,
						duration: v.duration,
					};
				}
				showTab("Player");
				play(selectedFile);
			});
			// async fill meta cells
			fillMetaCellsForRow(tr, v);
			return tr;
		}
		let lastListDataCache = null;
		function loadListRows(vids) {
			const tbody = document.querySelector("#listTable tbody");
			if (!tbody) return;
			tbody.innerHTML = "";
			vids.forEach((v) => tbody.appendChild(_listRow(v)));
		}
		async function loadList() {
			// Use the same directory that Grid is currently showing (cwd), falling back to rootInput or '.'
			const dir = typeof cwd === "string" && cwd.length > 0 ? cwd : rootInput?.value?.trim() || ".";
			const url = `/videos?directory=${encodeURIComponent(dir)}&recursive=false&limit=1000&detail=true`;
			renderListHeader();
			const tbody = document.querySelector("#listTable tbody");
			if (tbody) tbody.innerHTML = "";
			try {
				const res = await fetch(url);
				if (!res.ok) return;
				const j = await res.json();
				const vids = j.videos || [];
				lastListDataCache = vids;
				loadListRows(vids);
			}
			catch (_) { }
		}
		const reloadListBtn = document.getElementById("reloadListBtn");
		if (reloadListBtn) reloadListBtn.onclick = () => loadList();

		// Columns control
		const toggleListColumnsBtn = document.getElementById("toggleListColumnsBtn");
		if (toggleListColumnsBtn) {
			toggleListColumnsBtn.addEventListener("click", (e) => {
				const panel = document.getElementById("listColumnsPanel");
				if (!panel) return;
				const isVisible = panel.style.display === "block";
				if (!isVisible) {
					renderListColumnsPanel();
					const rect = toggleListColumnsBtn.getBoundingClientRect();
					panel.style.position = "absolute";
					panel.style.top = rect.bottom + 6 + "px";
					panel.style.left = rect.left + "px";
				}
				panel.style.display = isVisible ? "none" : "block";
				const onDocClick = (ev) => {
					const within = panel.contains(ev.target) || toggleListColumnsBtn.contains(ev.target);
					if (!within) {
						panel.style.display = "none";
						document.removeEventListener("click", onDocClick);
					}
				};
				document.addEventListener("click", onDocClick);
			});
		}
		async function discoverMetadataKeys() {
			// Scan current video list (up to 50) for ffprobe keys
			const vids = (lastListDataCache || []).slice(0, 50);
			const found = new Set(discoveredMetaKeys);
			for (const v of vids) {
				const raw = await ensureMetadata(v.path);
				if (!raw) continue;
				function walk(obj, prefix) {
					if (obj == null) return;
					if (Array.isArray(obj)) {
						obj.forEach((item, i) => walk(item, `${prefix}[${i}]`));
					}
					else if (typeof obj === 'object') {
						for (const k of Object.keys(obj)) {
							const np = prefix ? `${prefix}.${k}` : k;
							const val = obj[k];
							if (val && typeof val === 'object') walk(val, np);
							else found.add(np);
						}
					}
					else {
						if (prefix) found.add(prefix);
					}
				}
				walk(raw, '');
			}
			discoveredMetaKeys = found;
			return found;
		}

		load();
	</script>
</body>

</html>