<!doctype html>
<html>

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Local Media</title>

	<style>
		body {
			font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
			margin: 0;
			display: grid;
			grid-template-rows: auto 1fr auto;
			height: 100vh;
		}
		
		header, footer {
			padding: 12px 16px;
			border-bottom: 1px solid #ddd;
		}
		
		footer {
			border-top: 1px solid #ddd;
			border-bottom: 0;
		}
		
		#container {
			display: grid;
			grid-template-columns: 320px 1fr;
			height: 100%;
		}
		
		#sidebar {
			border-right: 1px solid #eee;
			padding: 18px 16px 16px 16px;
			background: #f9f9fc;
			min-width: 260px;
			box-shadow: 2px 0 8px #0001;
			display: flex;
			flex-direction: column;
			gap: 18px;
		}
		
		#infoPanel {
			background: #fff;
			border-radius: 10px;
			box-shadow: 0 2px 8px #0001;
			padding: 16px 14px;
			margin-top: 0;
			border: 1px solid #eee;
			font-size: 14px;
			color: #222;
			line-height: 1.7;
		}
		
		.infoTitle {
			font-size: 18px;
			font-weight: 600;
			margin-bottom: 2px;
			color: #222;
		}
		
		.infoRow {
			display: flex;
			gap: 8px;
			align-items: center;
			margin-bottom: 2px;
		}
		
		.infoLabel {
			color: #888;
			font-size: 13px;
			min-width: 70px;
		}
		
		.infoValue {
			color: #222;
			font-size: 14px;
			font-family: monospace;
		}
		
		/* Simple chips input (vanilla replacement for tagsinput) */
		.chips {
			min-height: 32px;
			border: 1px solid #ddd;
			border-radius: 6px;
			padding: 4px 6px;
			background: #fff;
			display: flex;
			flex-wrap: wrap;
			gap: 6px;
		}
		.chips input {
			border: none;
			outline: none;
			flex: 1;
			min-width: 120px;
			font-size: 14px;
			padding: 4px 2px;
		}
		.chip {
			display: inline-flex;
			align-items: center;
			gap: 6px;
			background: #f0f3ff;
			border: 1px solid #cfd8ff;
			color: #223;
			border-radius: 999px;
			padding: 2px 8px;
			font-size: 12px;
		}
		.chip button {
			border: none;
			background: transparent;
			cursor: pointer;
			color: #667;
			padding: 0 2px;
			font-size: 14px;
			line-height: 1;
		}
		
		.star {
			cursor: pointer;
			font-size: 20px;
			color: #ccc;
		}
		
		.star.selected {
			color: gold;
		}
		
		#main {
			padding: 12px;
			overflow: auto;
		}
		
		ul {
			list-style: none;
			padding: 0;
			margin: 0;
		}
		
		li {
			padding: 6px 4px;
			cursor: pointer;
		}
		
		li:hover {
			background: #f6f6f6;
		}
		
		.badge {
			font-size: 11px;
			padding: 2px 6px;
			border: 1px solid #ccc;
			border-radius: 999px;
			margin-left: 6px;
		}
		
		#video {
			width: 100%;
			max-height: 70vh;
			background: #000;
			display: block;
			cursor: pointer;
		}
		
		/* Remove reserved padding; controls are absolutely positioned */
		/* #player.player {padding-bottom: 84px; } */
		.file {
			display: flex;
			justify-content: space-between;
			gap: 8px;
			align-items: center;
		}
		
		.small {
			color: #666;
			font-size: 12px;
		}
		
		/* Utility classes for layout/spacing/typography */
		.flex {
			display: flex;
		}
		
		.flex-col {
			display: flex;
			flex-direction: column;
		}
		
		.items-center {
			align-items: center;
		}
		
		.items-start {
			align-items: flex-start;
		}
		
		.justify-between {
			justify-content: space-between;
		}
		
		.gap-6 {
			gap: 6px;
		}
		
		.gap-8 {
			gap: 8px;
		}
		
		.gap-12 {
			gap: 12px;
		}
		
		.gap-16 {
			gap: 16px;
		}
		
		.wrap {
			flex-wrap: wrap;
		}
		
		.mb-8 {
			margin-bottom: 8px;
		}
		
		.mb-18 {
			margin-bottom: 18px;
		}
		
		.mt-8 {
			margin-top: 8px;
		}
		
		.mt-12 {
			margin-top: 12px;
		}
		
		.w-80 {
			width: 80px;
		}
		
		.w-120 {
			width: 120px;
		}
		
		.w-220 {
			width: 220px;
		}
		
		.block {
			display: block;
		}
		
		.prewrap {
			white-space: pre-wrap;
		}
		
		.stat-val {
			font-size: 20px;
			font-weight: 600;
		}
		
		.grid-auto-180 {
			grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
		}
		
		.player-actions {
			display: flex;
			gap: 8px;
			align-items: center;
			margin: 8px 0;
		}
		
		.header-bar {
			display: flex;
			align-items: center;
			justify-content: space-between;
		}
		
		.tab-bar {
			display: flex;
			gap: 8px;
			align-items: center;
		}
		
		.scroll-60 {
			overflow: auto;
			max-height: 60vh;
		}
		
		.tile-no-pad {
			padding: 0;
		}
		
		.image-cover {
			max-width: 360px;
			max-height: 240px;
			border: 1px solid #ddd;
			border-radius: 8px;
			background: #111;
		}
		
		.progress-lg {
			width: 220px;
			margin-right: 8px;
			vertical-align: middle;
		}
		
		.fixed-menu {
			position: fixed;
			z-index: 1000;
			background: #fff;
			border: 1px solid #ccc;
			padding: 12px;
			border-radius: 8px;
			box-shadow: 0 2px 8px #0002;
		}
		
		.meta-extra {
			margin-top: 4px;
			white-space: pre-wrap;
			line-height: 1.4;
		}
		
		.thumb-img {
			width: 100%;
			max-width: 220px;
			border-radius: 8px;
			margin-bottom: 10px;
			object-fit: cover;
		}
		
		.thumb-placeholder {
			width: 100%;
			max-width: 220px;
			height: 120px;
			margin-bottom: 10px;
			display: flex;
			align-items: center;
			justify-content: center;
			background: #f0f0f0;
			color: #666;
			border-radius: 8px;
		}
		
		.w-full {
			width: 100%;
		}
		
		.table-collapse {
			border-collapse: collapse;
		}
		
		.thead-sticky {
			position: sticky;
			top: 0;
			background: #fafafa;
		}
		
		/* List column config + resizing */
		#listControls {
			display: flex;
			align-items: center;
			gap: 8px;
			flex-wrap: wrap;
		}
		#listColumnsPanel {
			background: #fff;
			border: 1px solid #e5e5e5;
			border-radius: 8px;
			padding: 8px 10px;
			box-shadow: 0 4px 16px #0002;
			display: none;
			position: absolute;
			z-index: 10;
			margin-top: 6px;
		}
		#listColumnsPanel .row {gap: 10px; }
		#listColumnsPanel label {font-size: 12px; color: #333; }
		#listColumnsPanel .muted {color: #777; }
		#listColumnsPanel .section {margin: 8px 0; }
		#listColumnsPanel .section strong {display:block; margin-bottom:6px; }
		#listColumnsPanel .choices {max-height: 220px; overflow: auto; border: 1px solid #eee; padding: 6px; border-radius: 6px; }
		#listColumnsPanel input[type="text"] {width: 220px; }
		
		#listTable {
			table-layout: fixed;
			width: 100%;
		}
		#listTable th {position: relative; user-select: none; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
		#listTable td {white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
		/* Vertical column borders for List */
		#listTable th:not(:last-child),
		#listTable td:not(:last-child) { border-right: 1px solid #eee; }
		/* Column/row selection visuals */
		#listTable th.col-selected, #listTable td.col-selected { background: #eef6ff; box-shadow: inset 0 0 0 1px #cfe6ff; }
		#listTable tr.row-selected td { background: #fff3cd; }
		/* Drag feedback: highlight target column */
		#listTable th.drag-hover, #listTable td.drag-hover { background: #fff0e0; }
		/* Optional: rotate headers 90deg CCW for dense views */
		#listTable.rotate-headers th { height: 160px; vertical-align: bottom; overflow: visible; }
		#listTable.rotate-headers th .th-label { position: absolute; left: 10px; bottom: 8px; display: inline-block; transform: rotate(-90deg); transform-origin: bottom left; white-space: nowrap; }
		#listTable.rotate-headers th .col-resizer { height: calc(100% - 8px); }
		.col-resizer {
			position: absolute;
			right: 0;
			top: 0;
			width: 6px;
			height: 100%;
			cursor: col-resize;
			background: transparent;
		}
		.col-resizer:hover {background: #eaeaea; }
		.dragging-col {opacity: 0.6; cursor: grabbing; }
		/* Drop indicator for clearer reordering targets */
		#listTable th.drop-left::before,
		#listTable th.drop-right::after { content: ""; position: absolute; top: 0; bottom: 0; width: 4px; background: #ff7a00; }
		#listTable th.drop-left::before { left: 0; }
		#listTable th.drop-right::after { right: 0; }
		/* Drag indicators in the Columns panel */
		#listColumnsPanel .drop-before { border-top: 3px solid #2e8cff; }
		#listColumnsPanel .drop-after { border-bottom: 3px solid #2e8cff; }
		
		.text-left {
			text-align: left;
		}
		
		.text-right {
			text-align: right;
		}
		
		.th {
			padding: 8px;
			border-bottom: 1px solid #eee;
		}
		
		.td {
			padding: 6px 8px;
			border-bottom: 1px solid #f0f0f0;
		}
		
		.back-btn {
			margin: 8px 8px 8px 0;
			font-size: 18px;
			font-weight: 700;
			padding: 10px 14px;
			display: inline-flex;
			align-items: center;
			gap: 10px;
		}
		
		.back-icon {
			font-size: 20px;
			opacity: 0.8;
		}
		
		.player-title {
			font-size: 22px;
			font-weight: 800;
			letter-spacing: -0.2px;
			max-width: 60vw;
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
		}
		
		/* Ensure controls anchor to the video box */
		.player-media {
			position: relative;
		}
		
		.sprite-preview {
			position: absolute;
			bottom: 48px;
			/* float above controls bar */
			left: 0;
			width: 160px;
			height: 90px;
			background: #000 no-repeat;
			background-size: cover;
			border: 1px solid #333;
			border-radius: 6px;
			box-shadow: 0 2px 8px #0006;
			pointer-events: none;
			transform: translateX(-50%);
			display: none;
			z-index: 7;
		}
		
		/* #infoPanel spacing handled in main panel styles */
		
		.controls {
			display: flex;
			gap: 8px;
			align-items: center;
			margin-bottom: 12px;
		}
		
		.controls input[type="text"] {
			flex: 1;
			padding: 6px 8px;
			font-size: 14px;
		}
		
		.controls button {
			padding: 6px 10px;
			font-size: 14px;
			cursor: pointer;
		}
		
		.grid {
			display: grid;
			grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
			gap: 12px;
			align-items: start;
		}
		
		.tile {
			border: 1px solid #eee;
			border-radius: 8px;
			padding: 8px;
			background: #fff;
			display: flex;
			flex-direction: column;
			gap: 6px;
		}
		
		.tile.selected {
			outline: 2px solid #06f;
			box-shadow: 0 0 0 2px #06f inset;
		}
		
		.tile video {
			width: 100%;
			height: 120px;
			background: #000;
			object-fit: cover;
		}
		
		.tile .name {
			font-size: 12px;
			color: #333;
			word-break: break-word;
		}
		
		.tile .thumb {
			width: 100%;
			height: 120px;
			object-fit: cover;
			background: #111;
			display: block;
		}
		
		.btn {
			font-size: 12px;
			padding: 4px 8px;
			border: 1px solid #ccc;
			border-radius: 6px;
			background: #f8f8f8;
			cursor: pointer;
		}
		
		.row {
			display: flex;
			gap: 8px;
			align-items: end;
			flex-wrap: wrap;
		}
		
		.pager {
			display: flex;
			gap: 8px;
			align-items: center;
			justify-content: flex-start;
			margin: 8px 0;
		}
		
		.pager input[type="number"] {
			width: 72px;
			padding: 4px 6px;
			font-size: 12px;
		}
		
		.hidden {
			display: none !important;
		}
		
		.placeholder {
			width: 100%;
			height: 120px;
			background: #151515;
			color: #888;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 11px;
			border-radius: 4px;
			border: 1px dashed #333;
		}
		
		.swatch {
			width: 20px;
			height: 20px;
			border-radius: 4px;
			border: 1px solid #ccc;
			display: inline-block;
			vertical-align: middle;
			margin-right: 6px;
		}
		
		/* Player overlays */
		.player {
			position: relative;
		}
		
		/* Scrub visuals sit inside the progress bar now */
		#heatmapStripe {
			position: absolute;
			left: 0;
			right: 0;
			top: 0;
			bottom: 0;
			background-size: 100% 100%;
			image-rendering: pixelated;
			opacity: 0.9;
			border-radius: 10px;
			background-color: transparent;
		}
		
		#chaptersBar {
			position: absolute;
			left: 0;
			right: 0;
			top: 0;
			bottom: 0;
			pointer-events: none;
		}
		
		#chaptersBar .marker {
			position: absolute;
			top: 0;
			bottom: 0;
			width: 2px;
			background: #ff4081;
			opacity: 0.9;
		}
		
		#chaptersBar .marker::after {
			content: "";
			position: absolute;
			top: 0;
			bottom: 0;
			left: -1px;
			right: -1px;
			background: linear-gradient(to bottom, #ff4081, #ffc107);
			opacity: 0.5;
		}
		
		/* Custom player controls */
		#controlsBar {
			position: absolute;
			left: 8px;
			right: 8px;
			bottom: 8px;
			display: flex;
			align-items: center;
			gap: 10px;
			user-select: none;
			padding: 8px 10px;
			background: linear-gradient(to top,
			rgba(0, 0, 0, 0.55),
			rgba(0, 0, 0, 0.35));
			border-radius: 8px;
			color: #fff;
			z-index: 6;
			opacity: 1;
			transition: opacity 0.15s ease;
		}
		
		#btnPlayPause,
		#btnCC {
			padding: 6px 10px;
			font-size: 13px;
			border: 1px solid #fff3;
			background: #ffffff22;
			color: #fff;
			border-radius: 6px;
			cursor: pointer;
		}
		
		#btnPlayPause:hover,
		#btnCC:hover {
			background: #ffffff33;
		}
		
		#timeLabel {
			font-size: 12px;
			color: #fff;
			min-width: 100px;
			text-align: right;
		}
		
		#controlsProgress {
			position: relative;
			height: 10px;
			background: #ffffff2a;
			border-radius: 999px;
			flex: 1;
			cursor: pointer;
			overflow: hidden;
		}
		
		#controlsProgressFill {
			position: absolute;
			left: 0;
			top: 0;
			bottom: 0;
			width: 0;
			background: #2e8cff;
			border-radius: 999px;
		}
		
		/* Right-side queue panel */
		/* queue removed */
		/* Generic tiny progress bar */
		.progress {
			width: 100%;
			height: 4px;
			background: #eee;
			border-radius: 999px;
			overflow: hidden;
		}
		
		.progress .bar {
			height: 100%;
			width: 0;
			background: #06f;
			transition: width 0.15s linear;
		}
		
		/* Filter chips */
		.filter-chips { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; }
		.chip { display: inline-flex; align-items: center; gap: 6px; padding: 2px 8px; border: 1px solid #ddd; border-radius: 999px; font-size: 12px; background: #f7f7f7; }
		.chip .x { cursor: pointer; color: #a00; font-weight: 700; }
		
		/* Indeterminate animation */
		.indeterminate {
			position: relative;
			overflow: hidden;
		}
		
		.indeterminate::before {
			content: "";
			position: absolute;
			left: -40%;
			top: 0;
			height: 100%;
			width: 40%;
			background: linear-gradient(90deg,
			transparent,
			rgba(0, 0, 0, 0.15),
			transparent);
			animation: slide 1s linear infinite;
		}
		
		@keyframes slide {
			0% {
				left: -40%;
			}
			
			100% {
				left: 100%;
			}
		}
	</style>
</head>

<body>
	<header class="header-bar">
		<strong>Local Media</strong>
		<div id="tabBar" class="tab-bar">
			<button class="btn" id="tabPlayer">Player</button>
			<button class="btn" id="tabGrid">Grid</button>
			<button class="btn" id="tabList">List</button>
			<button class="btn" id="tabTasks">Tasks</button>
			<button class="btn" id="tabStats">Stats</button>
			<button class="btn" id="tabSimilar">Similar</button>
			<button class="btn" id="tabSettings">Settings</button>
			<button class="btn" id="tabSetup">Setup</button>
			<button class="btn" id="tabRegistry">Registry</button>
			<button class="btn" id="playRandomBtn">Random</button>
			<button class="btn" id="tabImage">Image</button>
		</div>
	</header>
	<div id="container">
		<div id="sidebar">
			<div class="controls">
				<input id="rootInput" type="text" value="/Volumes/media/PornMin" placeholder="Root folder" />
				<input id="hiddenDirPicker" type="file" style="display:none;" webkitdirectory directory />
				<button id="setRootBtn">Set</button>
			</div>
			<div id="infoPanel" class="small"></div>
			<ul id="dirs"></ul>
		</div>
		<div id="main">
			<!-- Static Back button (shown in Player tab) -->
			<button id="backBtn" class="btn back-btn" style="display:none">
				<span class="back-icon">←</span>
				<span id="playerTitle" class="player-title">Back</span>
			</button>
			<div id="player" class="player">
				<h1>
					<div id="meta"></div>
				</h1>
				<div class="player-media">
					<video id="video" class="hidden" preload="metadata"></video>
					<!-- Scrub visuals inside progress bar -->
					<div id="controlsBar" class="hidden">
						<button id="btnPlayPause" title="Play/Pause (space)">▶︎</button>
						<div id="controlsProgress">
							<div id="heatmapStripe"></div>
							<div id="chaptersBar"></div>
							<div id="controlsProgressFill"></div>
						</div>
						<span id="timeLabel">0:00 / 0:00</span>
						<button id="btnCC" title="Toggle captions">CC</button>
						<button id="btnFS" title="Fullscreen (f)">⤢</button>
					</div>
				</div>
				<div id="playerActions" class="player-actions">
					<button id="setThumbBtn" class="btn">Set Thumbnail from Current Frame</button>
					<button id="setMarkerBtn" class="btn">Add Marker (m)</button>
				</div>
			</div>
			<!-- Stats Tab Content -->
			<div id="statsTab" class="hidden flex-col gap-12">
				<div class="grid grid-auto-180">
					<div class="tile">
						<div class="small">SCENES SIZE</div>
						<div id="statScenesSize" class="stat-val">—</div>
					</div>
					<div class="tile">
						<div class="small">SCENES</div>
						<div id="statScenes" class="stat-val">—</div>
					</div>
					<div class="tile">
						<div class="small">SCENES DURATION</div>
						<div id="statScenesDuration" class="stat-val">—</div>
					</div>
					<div class="tile">
						<div class="small">COVERS</div>
						<div id="statCovers" class="stat-val">—</div>
					</div>
					<div class="tile">
						<div class="small">HOVERS</div>
						<div id="statHovers" class="stat-val">—</div>
					</div>
					<div class="tile">
						<div class="small">SUBTITLES</div>
						<div id="statSubs" class="stat-val">—</div>
					</div>
					<div class="tile">
						<div class="small">METADATA</div>
						<div id="statMeta" class="stat-val">—</div>
					</div>
					<!-- Performers -->
					<!-- Studios -->
					<!-- Tags -->
				</div>
				<div class="small" id="statsNote"></div>
			</div>
			<!-- Similar Tab Content (pHash duplicates) -->
			<div id="similarTab" class="hidden flex-col gap-12">
				<div class="row items-center gap-12 wrap">
					<strong>Similar (pHash)</strong>
					<label class="small">Threshold
						<input id="similarThresh" type="number" min="0" max="1" step="0.01" value="0.90" class="w-80" />
					</label>
					<label class="small">Limit
						<input id="similarLimit" type="number" min="0" step="1" value="50" class="w-80" />
					</label>
					<label class="small">
						<input id="similarRecursive" type="checkbox" /> Recursive
					</label>
					<button id="similarRefreshBtn" class="btn">Refresh</button>
					<span id="similarStatus" class="small"></span>
				</div>
				<div id="similarResults" class="grid"></div>
			</div>
			<!-- Settings Tab Content -->
			<div id="settingsTab" class="hidden flex-col gap-12">
				<div class="tile">
					<div class="small"><strong>Server Health</strong></div>
					<pre id="healthInfo" class="small prewrap"></pre>
				</div>
				<div class="tile">
					<div class="small"><strong>Config</strong></div>
					<pre id="configInfo" class="small prewrap"></pre>
				</div>
			</div>
			<!-- Setup Tab Content -->
			<div id="setupTab" class="hidden flex-col gap-12">
				<div class="tile">
					<div class="small"><strong>Auto-tag by filename</strong></div>
					<div class="row wrap gap-12 mt-8">
						<label class="small flex-col">
							<span>Performers (one per line)</span>
							<textarea id="setupPerformers" rows="6" style="width: 320px;"></textarea>
						</label>
						<label class="small flex-col">
							<span>Tag keywords (one per line)</span>
							<textarea id="setupTags" rows="6" style="width: 320px;"></textarea>
						</label>
					</div>
					<div class="row gap-8 mt-8">
						<button id="setupSaveBtn" class="btn">Save lists (local)</button>
						<button id="setupRunBtn" class="btn">Run scan</button>
						<span id="setupStatus" class="small"></span>
					</div>
				</div>
			</div>
			<!-- List Tab -->
			<div id="listTab" class="hidden flex-col gap-8">
				<div class="row" id="listControls">
					<button id="reloadListBtn" class="btn">Reload</button>
					<button id="toggleRotateHeadersBtn" class="btn" title="Rotate column headers 90° for compact view">Rotate headers: Off</button>
					<label class="small" style="display:inline-flex; align-items:center; gap:6px;">
						<input type="checkbox" id="enableColSelectChk" /> Columns selectable
					</label>
					<label class="small" style="display:inline-flex; align-items:center; gap:6px;">
						<input type="checkbox" id="enableRowSelectChk" /> Rows selectable
					</label>
					<div style="position:relative;">
						<button id="toggleListColumnsBtn" class="btn">Columns</button>
						<div id="listColumnsPanel" class="small"></div>
					</div>
				</div>
				<div class="tile tile-no-pad">
					<div class="scroll-60">
						<table id="listTable" class="small w-full table-collapse">
							<thead class="thead-sticky"><tr id="listHeaderRow"></tr></thead>
							<tbody></tbody>
						</table>
					</div>
				</div>
			</div>
			<!-- Image Tab Content (FaceLab) -->
			<div id="imageTab" class="hidden flex-col gap-12">
				<div class="row items-center gap-12 wrap">
					<strong>FaceLab</strong>
					<button id="refreshFacesBtn" class="btn">Refresh</button>
					<button id="createFacesBtn" class="btn">Compute faces</button>
					<span class="small" id="imageStatus"></span>
				</div>
				<!-- Face tuning knobs (per-file) -->
				<div class="tile">
					<div class="small"><strong>Face detection & embedding – per-file</strong></div>
					<div class="row items-center gap-12 wrap mt-8">
						<label class="small">Backend
							<select id="faceBackendSelect" class="w-80">
								<option value="auto" selected>Auto</option>
								<option value="insightface">InsightFace (SCRFD+ArcFace)</option>
								<option value="opencv">OpenCV (Haar+OpenFace)</option>
							</select>
						</label>
						<label class="small">Interval (s)
							<input id="faceIntervalInput" type="number" min="0.05" step="0.05" value="1.0" class="w-80" />
						</label>
						<label class="small">Scale factor
							<input id="faceScaleFactorInput" type="number" min="1.01" step="0.05" value="1.2" class="w-80" />
						</label>
						<label class="small">Min neighbors
							<input id="faceMinNeighborsInput" type="number" min="1" step="1" value="7" class="w-80" />
						</label>
						<label class="small">Min size (fraction)
							<input id="faceMinSizeFracInput" type="number" min="0.01" max="0.9" step="0.01" value="0.10" class="w-80" />
						</label>
						<label class="small">Similarity (0-1)
							<input id="faceSimThreshInput" type="number" min="0" max="1" step="0.01" value="0.90" class="w-80" />
						</label>
					</div>
					<div class="small muted mt-8">Tip: Higher similarity merges more detections; lower interval detects more frames but is slower.</div>
				</div>
				<div id="facesList" class="row wrap gap-16"></div>
			</div>
			<!-- Grid Tab Wrapper -->
			<div id="gridTab">
				<button class="btn" id="toggleHoversBtn">Hovers: On</button>
				<div id="gridControls" class="controls mb-8 wrap">
					<span class="small">Grid columns</span>
					<select id="gridSize">
						<option value="3">3</option>
						<option value="4" selected>4</option>
						<option value="5">5</option>
						<option value="8">8</option>
						<option value="16">16</option>
						<option value="32">32</option>
					</select>
					<span class="small">Page size</span>
					<input id="pageSize" type="number" min="4" max="500" step="4" value="16" />
					<input id="searchInput" type="text" placeholder="Search…" class="w-120" />
					<select id="sortBy">
						<option value="name">Name</option>
						<option value="size">Size</option>
						<option value="date">Date</option>
						<option value="random">Random</option>
					</select>
					<!-- Sort order toggle: replaces asc/desc dropdown -->
					<button id="sortOrderToggle" class="btn" title="Toggle sort order (Asc/Desc)">↑</button>
					<!-- Tag/Performer filters -->
					<input id="filterTagInput" type="text" placeholder="Add tag…" list="filterTagsList" class="w-120" />
					<datalist id="filterTagsList"></datalist>
					<input id="filterPerfInput" type="text" placeholder="Add performer…" list="filterPerfsList" class="w-120" />
					<datalist id="filterPerfsList"></datalist>
					<div id="filterChips" class="filter-chips"></div>
					<button id="prevBtn" class="btn">Prev</button>
					<div id="pageInfo" class="small"></div>
					<button id="nextBtn" class="btn">Next</button>
				</div>
				<div id="files" class="grid"></div>
				<div id="fileMenu" class="hidden fixed-menu">
					<button id="coverBtn" class="btn">Generate cover</button>
					<button id="closeMenuBtn" class="btn">Close</button>
				</div>
			</div>
			<div id="tasksDiv" class="hidden mt-12">
				<!-- Jobs Activity: live, one-row-per-job table updated via SSE -->
				<div class="mb-18" id="taskSection-jobs" data-task-section="jobs">
					<div class="small flex items-center gap-8 wrap">
						<strong>Jobs Activity</strong>
						<span class="muted small">Live updates as jobs are queued and completed</span>
					</div>
					<div class="mt-6" style="max-height: 220px; overflow: auto; border: 1px solid #333; border-radius: 6px;">
						<table id="jobsTable" class="small" style="width: 100%; border-collapse: collapse;">
							<thead style="position: sticky; top: 0; background: #111;">
								<tr>
									<th class="small" style="text-align:left; padding: 6px 8px; border-bottom: 1px solid #333; width: 10rem;">When</th>
									<th class="small" style="text-align:left; padding: 6px 8px; border-bottom: 1px solid #333; width: 8rem;">Task</th>
									<th class="small" style="text-align:left; padding: 6px 8px; border-bottom: 1px solid #333;">File</th>
									<th class="small" style="text-align:left; padding: 6px 8px; border-bottom: 1px solid #333; width: 7rem;">State</th>
									<th class="small" style="text-align:left; padding: 6px 8px; border-bottom: 1px solid #333; width: 14rem;">Progress</th>
								</tr>
							</thead>
							<tbody id="jobsTableBody"></tbody>
						</table>
					</div>
				</div>
				<!-- Registry Tab Content -->
				<div id="registryTab" class="hidden flex-col gap-12">
					<div class="row items-center gap-12 wrap">
						<strong>Registry</strong>
						<button id="refreshRegistryBtn" class="btn">Refresh</button>
					</div>
					<div class="tile">
						<div class="small"><strong>Tags</strong></div>
						<div class="row gap-8 mt-8">
							<input id="newTagName" type="text" placeholder="New tag…" class="w-220" />
							<button id="createTagBtn" class="btn">Create</button>
							<input id="renameTagFrom" type="text" placeholder="Rename from…" class="w-220" />
							<input id="renameTagTo" type="text" placeholder="…to" class="w-220" />
							<button id="renameTagBtn" class="btn">Rename</button>
							<input id="mergeTagFrom" type="text" placeholder="Merge from…" class="w-220" />
							<input id="mergeTagTo" type="text" placeholder="…into" class="w-220" />
							<button id="mergeTagBtn" class="btn">Merge</button>
							<input id="deleteTagName" type="text" placeholder="Delete tag…" class="w-220" />
							<button id="deleteTagBtn" class="btn">Delete</button>
						</div>
						<div id="tagsRegistryList" class="mt-12 small" style="max-height:240px; overflow:auto;"></div>
					</div>
					<div class="tile">
						<div class="small"><strong>Performers</strong></div>
						<div class="row gap-8 mt-8">
							<input id="newPerfName" type="text" placeholder="New performer…" class="w-220" />
							<button id="createPerfBtn" class="btn">Create</button>
							<input id="renamePerfFrom" type="text" placeholder="Rename from…" class="w-220" />
							<input id="renamePerfTo" type="text" placeholder="…to" class="w-220" />
							<button id="renamePerfBtn" class="btn">Rename</button>
							<input id="mergePerfFrom" type="text" placeholder="Merge from…" class="w-220" />
							<input id="mergePerfTo" type="text" placeholder="…into" class="w-220" />
							<button id="mergePerfBtn" class="btn">Merge</button>
							<input id="deletePerfName" type="text" placeholder="Delete performer…" class="w-220" />
							<button id="deletePerfBtn" class="btn">Delete</button>
						</div>
						<div id="performersRegistryList" class="mt-12 small" style="max-height:240px; overflow:auto;"></div>
					</div>
				</div>
				<div class="mb-18" id="taskSection-metadata" data-task-section="metadata">
					<div class="small"><strong>JSON Metadata</strong></div>
					<progress id="metaProgress" max="100" value="0" class="progress-lg"></progress>
					<span id="metaPct" class="small"></span>
					<button id="generateMissingMetaBtn" class="btn"> Generate missing metadata </button>
					<button id="recomputeAllMetaBtn" class="btn btn-secondary">Recompute all metadata</button>
					<button id="clearMetaBtn" class="btn">Clear all metadata</button>
				</div>
				<div class="mb-18" id="taskSection-covers" data-task-section="covers">
					<div class="small flex items-center gap-8 wrap">
						<strong>Covers</strong>
						<span class="small">Offset (s)</span>
						<input id="coverOffset" type="number" min="0" step="0.1" value="10" class="w-80" />
					</div>
					<progress id="coverProgress" max="100" value="0" class="progress-lg"></progress>
					<span id="coverPct" class="small"></span>
					<button id="generateMissingCoversBtn" class="btn">Generate missing covers</button>
					<button id="recomputeAllCoversBtn" class="btn btn-secondary">Recompute all covers</button>
					<button id="clearCoversBtn" class="btn">Clear all covers</button>
				</div>
				<div class="mb-18" id="taskSection-hovers" data-task-section="hovers">
					<div class="small"><strong>Hover Previews</strong></div>
					<div class="row items-center gap-12 wrap mt-6">
						<label class="small">Segments
							<input id="hoverSegmentsInput" type="number" min="3" max="30" step="1" value="9" class="w-80" />
						</label>
						<label class="small">Segment duration (s)
							<input id="hoverSegDurInput" type="number" min="0.2" max="10" step="0.1" value="1.0" class="w-80" />
						</label>
						<label class="small">Width (px)
							<input id="hoverWidthInput" type="number" min="120" max="1280" step="10" value="320" class="w-80" />
						</label>
					</div>
					<progress id="hoverProgress" max="100" value="0" class="progress-lg"></progress>
					<span id="hoverPct" class="small"></span>
					<button id="generateMissingHoversBtn" class="btn">Generate missing hovers</button>
					<button id="recomputeAllHoversBtn" class="btn btn-secondary">Recompute all hovers</button>
					<button id="clearHoversBtn" class="btn">Clear all hovers</button>
				</div>
				<div class="mb-18" id="taskSection-phash" data-task-section="phash">
					<div class="small"><strong>pHash</strong></div>
					<progress id="phashProgress" max="100" value="0" class="progress-lg"></progress>
					<span id="phashPct" class="small"></span>
					<button id="generateMissingPhashBtn" class="btn">Generate missing pHash</button>
					<button id="recomputeAllPhashBtn" class="btn btn-secondary">Recompute all pHash</button>
					<button id="clearPhashBtn" class="btn">Clear all pHash</button>
				</div>
				<div class="mb-18" id="taskSection-scenes" data-task-section="scenes">
					<div class="small"><strong>Chapter Markers</strong></div>
					<progress id="scenesProgress" max="100" value="0" class="progress-lg"></progress>
					<span id="scenesPct" class="small"></span>
					<button id="generateMissingScenesBtn" class="btn">Generate missing scenes</button>
					<button id="recomputeAllScenesBtn" class="btn btn-secondary">Recompute all scenes</button>
					<button id="clearScenesBtn" class="btn">Clear all scenes</button>
				</div>
				<div class="mb-18" id="taskSection-sprites" data-task-section="sprites">
					<div class="small"><strong>Scrubbing Thumbnails</strong></div>
					<div class="row items-center gap-12 wrap mt-6">
						<label class="small">Interval (s)
							<input id="spriteIntervalInput" type="number" min="1" step="1" value="10" class="w-80" />
						</label>
						<label class="small">Width (px)
							<input id="spriteWidthInput" type="number" min="160" max="1920" step="10" value="320" class="w-80" />
						</label>
						<label class="small">Cols
							<input id="spriteColsInput" type="number" min="3" max="40" step="1" value="10" class="w-80" />
						</label>
						<label class="small">Rows
							<input id="spriteRowsInput" type="number" min="3" max="40" step="1" value="10" class="w-80" />
						</label>
						<label class="small">Quality (0-8)
							<input id="spriteQualityInput" type="number" min="0" max="8" step="1" value="4" class="w-80" />
						</label>
					</div>
					<progress id="spritesProgress" max="100" value="0" class="progress-lg"></progress>
					<span id="spritesPct" class="small"></span>
					<button id="generateMissingSpritesBtn" class="btn">Generate missing sprites</button>
					<button id="recomputeAllSpritesBtn" class="btn btn-secondary">Recompute all sprites</button>
					<button id="clearSpritesBtn" class="btn">Clear all sprites</button>
				</div>
				<div class="mb-18" id="taskSection-heatmaps" data-task-section="heatmaps">
					<div class="small"><strong>Heatmaps</strong></div>
					<div class="row items-center gap-12 wrap mt-6">
						<label class="small">Interval (s)
							<input id="heatmapsIntervalInput" type="number" min="0.5" step="0.5" value="5.0" class="w-80" />
						</label>
						<label class="small">Mode
							<select id="heatmapsModeSelect" class="w-80">
								<option value="both" selected>Both</option>
								<option value="brightness">Brightness</option>
								<option value="motion">Motion</option>
							</select>
						</label>
						<label class="row items-center gap-6 small"><input id="heatmapsPngChk" type="checkbox" checked /> Save PNG</label>
					</div>
					<progress id="heatmapsProgress" max="100" value="0" class="progress-lg"></progress>
					<span id="heatmapsPct" class="small"></span>
					<button id="generateMissingHeatmapsBtn" class="btn">Generate missing heatmaps</button>
					<button id="recomputeAllHeatmapsBtn" class="btn btn-secondary">Recompute all heatmaps</button>
					<button id="clearHeatmapsBtn" class="btn">Clear all heatmaps</button>
				</div>
				<div class="mb-18" id="taskSection-subtitles" data-task-section="subtitles">
					<div class="small"><strong>Subtitles</strong></div>
					<progress id="subsProgress" max="100" value="0" class="progress-lg"></progress>
					<span id="subsPct" class="small"></span>
					<button id="generateMissingSubsBtn" class="btn">Generate missing subtitles</button>
					<button id="recomputeAllSubsBtn" class="btn btn-secondary">Recompute all subtitles</button>
					<button id="clearSubsBtn" class="btn">Clear all subtitles</button>
				</div>
				<div class="mb-18" id="taskSection-faces" data-task-section="faces">
					<div class="small"><strong>Face Embeddings</strong><span class="muted">(Generate missing or recompute all)</span></div>
					<div class="row items-center gap-12 wrap mt-6">
						<label class="small">Backend
							<select id="faceBatchBackendSelect" class="w-80">
								<option value="auto" selected>Auto</option>
								<option value="insightface">InsightFace (SCRFD+ArcFace)</option>
								<option value="opencv">OpenCV (Haar+OpenFace)</option>
							</select>
						</label>
						<label class="small">Interval (s)
							<input id="faceBatchIntervalInput" type="number" min="0.05" step="0.05" value="1.0" class="w-80" />
						</label>
						<label class="small">Scale factor
							<input id="faceBatchScaleFactorInput" type="number" min="1.01" step="0.05" value="1.2" class="w-80" />
						</label>
						<label class="small">Min neighbors
							<input id="faceBatchMinNeighborsInput" type="number" min="1" step="1" value="7" class="w-80" />
						</label>
						<label class="small">Min size (fraction)
							<input id="faceBatchMinSizeFracInput" type="number" min="0.01" max="0.9" step="0.01" value="0.10" class="w-80" />
						</label>
						<label class="small">Similarity (0-1)
							<input id="faceBatchSimThreshInput" type="number" min="0" max="1" step="0.01" value="0.90" class="w-80" />
						</label>
					</div>
					<progress id="facesProgress" max="100" value="0" class="progress-lg"></progress>
					<span id="facesPct" class="small"></span>
					<button id="generateMissingFacesBtn" class="btn">Generate missing embeddings</button>
					<button id="recomputeAllFacesBtn" class="btn btn-secondary">Recompute all embeddings</button>
					<button id="clearFacesBtn" class="btn">Clear all embeddings</button>
				</div>
				<div class="mb-18" id="taskSection-cleanup" data-task-section="cleanup">
					<div class="small"><strong>Artifacts Cleanup</strong><span class="muted">(rename artifacts for renamed media; delete orphans)</span></div>
					<progress id="cleanupProgress" max="100" value="0" class="progress-lg"></progress>
					<span id="cleanupPct" class="small"></span>
					<div class="row items-center gap-8 wrap mt-6">
						<label class="row items-center gap-6 small"><input type="checkbox" id="keepOrphansChk" />Keep orphans</label>
						<button id="cleanupDryRunBtn" class="btn">Dry-run cleanup</button>
						<button id="cleanupRunBtn" class="btn btn-secondary">Run cleanup</button>
					</div>
					<div id="cleanupSummary" class="small mt-8 prewrap"></div>
				</div>
				<!--<button class="btn" disabled>Find end of intro</button>-->
				<!--<button class="btn" disabled>Facial recognition of actors</button>-->
			</div>
		</div>
	</div>
	<footer>
		<span id="status"></span>
	</footer>
	<script>
		const videoEl = document.getElementById("video");
		const metaEl = document.getElementById("meta");
		const playerEl = document.getElementById("player");
		const controlsBar = document.getElementById("controlsBar");
		const heatmapStripe = document.getElementById("heatmapStripe");
		const chaptersBar = document.getElementById("chaptersBar");
		const gridControls = document.getElementById("gridControls");
		const filesGrid = document.getElementById("files");
		const tasksDiv = document.getElementById("tasksDiv");
		const toggleHoversBtn = document.getElementById("toggleHoversBtn");
		let hoverPreviewsEnabled = true; // default enabled
		
		const TAB_SLUGS = {
			Player: "player",
			Grid: "grid",
			List: "list",
			Tasks: "tasks",
			Stats: "stats",
			Similar: "similar",
			Image: "image",
			Settings: "settings",
			Setup: "setup",
		};
		const SLUG_TO_TAB = Object.fromEntries(Object.entries(TAB_SLUGS).map(([k, v]) => [v, k]));
		// Paging helpers: keep ?page in the URL
		function getPageFromLocation() {
			try { 
				const u = new URL(location.href);
				const p = parseInt(u.searchParams.get('page') || '1', 10);
				return isFinite(p) && p > 0 ? p : 1;
			} catch (_) { return 1; }
		}
		function setPageInLocation(page, replace = false) {
			try { 
				const u = new URL(location.href);
				if (page && page > 1) u.searchParams.set('page', String(page));
				else u.searchParams.delete('page');
				const target = u.pathname + u.search + u.hash;
				if (replace) history.replaceState({ page }, '', target);
				else history.pushState({ page }, '', target);
			} catch (_) { }
		}
		function getTabFromLocation() {
			const slug = (location.hash || "").replace(/^#/, "").toLowerCase();
			return SLUG_TO_TAB[slug] || null;
		}
		function setRouteForTab(tab, replace = false) {
			const slug = TAB_SLUGS[tab] || "grid";
			const target = `#${slug}`;
			if (replace) {
				history.replaceState({tab }, "", target);
			}
			else {
				history.pushState({tab }, "", target);
			}
		}
		
		// DRY tab switching: hide all, then show the requested one
		// TODO @copilot: these should be standardized
		const TAB_CONTAINERS = {
			Player: "player",
			Grid: "gridTab",
			List: "listTab",
			Tasks: "tasksDiv",
			Stats: "statsTab",
			Similar: "similarTab",
			Settings: "settingsTab",
			Image: "imageTab",
			Setup: "setupTab",
			Registry: "registryTab",
		};
		function hideAllTabs() {
			Object.values(TAB_CONTAINERS).forEach((id) => {
				const el = document.getElementById(id);
				if (el) { el.classList.add("hidden"); }
			});
			// Hide Player-only UI by default
			const _bb = document.getElementById("backBtn");
			if (_bb) { _bb.style.display = "none"; }
			if (controlsBar) { controlsBar.classList.add("hidden"); }
			const setThumbBtn = document.getElementById("setThumbBtn");
			if (setThumbBtn) { setThumbBtn.style.display = "none"; }
			const setMarkerBtn = document.getElementById("setMarkerBtn");
			if (setMarkerBtn) { setMarkerBtn.style.display = "none"; }
			// Stop Tasks refresh + SSE when leaving
			if (typeof tasksRefreshTimer !== "undefined" && tasksRefreshTimer) {
				clearInterval(tasksRefreshTimer);
				tasksRefreshTimer = null;
			}
			try { 
				if (jobsEvtSrc) {
					jobsEvtSrc.close();
					jobsEvtSrc = null;
				}
			}
			catch (_) { }
			try { setIndeterminateActive(false); } catch (_) { }
		}
		function showTab(tab, fromRouter) {
			hideAllTabs();
			try { window.activeTab = tab; } catch(_) {}
			const id = TAB_CONTAINERS[tab] || TAB_CONTAINERS.Grid;
			const container = document.getElementById(id);
			if (container) { container.classList.remove("hidden"); }
			// Per-tab actions
			if (tab === "Player") {
				// Show back + player UI and ensure a file is loaded
				const _bb = document.getElementById("backBtn");
				if (_bb) { _bb.style.display = ""; }
				const setThumbBtn = document.getElementById("setThumbBtn");
				// TODO @copilot: can't you do this more programmatically?
				if (setThumbBtn) { setThumbBtn.style.display = ""; }
				const setMarkerBtn = document.getElementById("setMarkerBtn");
				// TODO @copilot: can't you do this more programmatically?
				if (setMarkerBtn) { setMarkerBtn.style.display = ""; }
				if (selectedFile) {
					const currentSrc = videoEl.querySelector("source")?.src || "";
					const shouldLoad = !currentSrc.endsWith(encodeURIComponent(selectedFile.path)) && !currentSrc.endsWith(selectedFile.path);
					if (shouldLoad) { play(selectedFile); }
				}
			}
			else if (tab === "Tasks") {
				try { startJobsSSE(); }
				catch (_) { }
				try { updateTasksStats(); }
				catch (_) { }
				try { updatePollingInterval(); }
				catch (_) { }
				try { setIndeterminateActive(window.__jobsActive === true); }
				catch (_) { }
			}
			else if (tab === "Stats") {
				try { loadStats(); }
				catch (_) { }
			}
			else if (tab === "Similar") {
				try { loadSimilar(); }
				catch (_) { }
			}
			else if (tab === "List") {
				try { loadList(); }
				catch (_) { }
			}
			else if (tab === "Image") {
				try { loadFaces(); }
				catch (_) { }
			}
			else if (tab === "Registry") {
				try { loadRegistry(); }
				catch (_) { }
			}
			else if (tab === "Settings") {
				try { loadSettings(); }
				catch (_) { }
			}
			else if (tab === "Setup") {
				try { loadSetup(); }
				catch (_) { }
			}
			// Update URL route after switching (unless invoked by popstate)
			try { if (!fromRouter) setRouteForTab(tab); }
			catch (_) { }
		}
		
		// Ensure sprite preview is positioned within player-media for z-index stacking
		function mountSpritePreviewInPlayer() {
			const preview = document.querySelector('.sprite-preview');
			const wrap = document.querySelector('.player-media');
			if (preview && wrap && preview.parentElement !== wrap) {
				wrap.appendChild(preview);
			}
		}
		
		// DRY bindings for top nav; detailed side effects live in showTab
		document.getElementById("tabPlayer").onclick = () => showTab("Player");
		document.getElementById("tabGrid").onclick = () => showTab("Grid");
		document.getElementById("tabTasks").onclick = () => showTab("Tasks");
		document.getElementById("tabStats").onclick = () => showTab("Stats");
		document.getElementById("tabSimilar").onclick = () => showTab("Similar");
		document.getElementById("tabImage").onclick = () => showTab("Image");
		document.getElementById("tabSetup").onclick = () => showTab("Setup");
		document.getElementById("tabRegistry").onclick = () => showTab("Registry");
		const _tabListBtn = document.getElementById("tabList");
		if (_tabListBtn) {
			_tabListBtn.onclick = () => showTab("List");
		}
		// Static Back button behavior
		const _backBtn = document.getElementById("backBtn");
		if (_backBtn) {
			_backBtn.onclick = () => {
				showTab("Grid");
				if (window._lastGridTile) {
					window._lastGridTile.classList.add("selected");
					try { 
						window._lastGridTile.scrollIntoView({
							block: "nearest", 
							inline: "nearest"
						});
					}
					catch (_) { }
				}
			};
		}
		document.getElementById("tabSettings").onclick = () => {
			showTab("Settings");
		};
		document.getElementById("playRandomBtn").onclick = async () => {
			let allMediaFiles = [];
			let page = 1;
			let pageSize = 500;
			let totalPages = 1;
			do {
				const params = new URLSearchParams();
				params.set("page", String(page));
				params.set("page_size", String(pageSize));
				const searchVal = document.getElementById("searchInput")?.value?.trim();
				if (searchVal) params.set("search", searchVal);
				params.set("sort", "name");
				const res = await fetch("/api/library?" + params.toString(), {
					method: "GET",
				});
				if (!res.ok) break;
				const body = await res.json();
				const data = body.data || body;
				allMediaFiles = allMediaFiles.concat(data.files || []);
				totalPages = data.total_pages || 1;
				page++;
			}
			while (page <= totalPages);
			if (allMediaFiles.length === 0) {
				alert("No videos found!");
				return;
			}
			const randomIdx = Math.floor(Math.random() * allMediaFiles.length);
			const file = allMediaFiles[randomIdx];
			selectedFile = file;
			showTab("Player");
			play(file);
		};
		
		// --- TASKS PAGE LOGIC ---
		const coverProgress = document.getElementById("coverProgress");
		const coverPct = document.getElementById("coverPct");
		const hoverProgress = document.getElementById("hoverProgress");
		const hoverPct = document.getElementById("hoverPct");
		const metadataProgress = document.getElementById("metaProgress");
		const metaPct = document.getElementById("metaPct");
		const phashProgress = document.getElementById("phashProgress");
		const phashPct = document.getElementById("phashPct");
		const scenesProgress = document.getElementById("scenesProgress");
		const scenesPct = document.getElementById("scenesPct");
		const spritesProgress = document.getElementById("spritesProgress");
		const spritesPct = document.getElementById("spritesPct");
		const subtitlesProgress = document.getElementById("subsProgress");
		const subsPct = document.getElementById("subsPct");
		const generateMissingCoversBtn = document.getElementById("generateMissingCoversBtn");
		const recomputeAllCoversBtn = document.getElementById("recomputeAllCoversBtn");
		const clearCoversBtn = document.getElementById("clearCoversBtn");
		const generateMissingHoversBtn = document.getElementById("generateMissingHoversBtn");
		const recomputeAllHoversBtn = document.getElementById("recomputeAllHoversBtn");
		const clearHoversBtn = document.getElementById("clearHoversBtn");
		const generateMissingMetaBtn = document.getElementById("generateMissingMetaBtn");
		const recomputeAllMetaBtn = document.getElementById("recomputeAllMetaBtn");
		const clearMetaBtn = document.getElementById("clearMetaBtn");
		const generateMissingPhashBtn = document.getElementById("generateMissingPhashBtn");
		const recomputeAllPhashBtn = document.getElementById("recomputeAllPhashBtn");
		const clearPhashBtn = document.getElementById("clearPhashBtn");
		const generateMissingScenesBtn = document.getElementById("generateMissingScenesBtn");
		const recomputeAllScenesBtn = document.getElementById("recomputeAllScenesBtn");
		const clearScenesBtn = document.getElementById("clearScenesBtn");
		const heatmapsProgress = document.getElementById("heatmapsProgress");
		const heatmapsPct = document.getElementById("heatmapsPct");
		const generateMissingHeatmapsBtn = document.getElementById("generateMissingHeatmapsBtn");
		const recomputeAllHeatmapsBtn = document.getElementById("recomputeAllHeatmapsBtn");
		const clearHeatmapsBtn = document.getElementById("clearHeatmapsBtn");
		const generateMissingSpritesBtn = document.getElementById("generateMissingSpritesBtn");
		const recomputeAllSpritesBtn = document.getElementById("recomputeAllSpritesBtn");
		const clearSpritesBtn = document.getElementById("clearSpritesBtn");
		// Task knobs for hovers/sprites/heatmaps
		const hoverSegmentsInput = document.getElementById("hoverSegmentsInput");
		const hoverSegDurInput = document.getElementById("hoverSegDurInput");
		const hoverWidthInput = document.getElementById("hoverWidthInput");
		const spriteIntervalInput = document.getElementById("spriteIntervalInput");
		const spriteWidthInput = document.getElementById("spriteWidthInput");
		const spriteColsInput = document.getElementById("spriteColsInput");
		const spriteRowsInput = document.getElementById("spriteRowsInput");
		const spriteQualityInput = document.getElementById("spriteQualityInput");
		const heatmapsIntervalInput = document.getElementById("heatmapsIntervalInput");
		const heatmapsModeSelect = document.getElementById("heatmapsModeSelect");
		const heatmapsPngChk = document.getElementById("heatmapsPngChk");
		const generateMissingSubsBtn = document.getElementById("generateMissingSubsBtn");
		const recomputeAllSubsBtn = document.getElementById("recomputeAllSubsBtn");
		const clearSubsBtn = document.getElementById("clearSubsBtn");
		const facesProgress = document.getElementById("facesProgress");
		const facesPct = document.getElementById("facesPct");
		const generateMissingFacesBtn = document.getElementById("generateMissingFacesBtn");
		const recomputeAllFacesBtn = document.getElementById("recomputeAllFacesBtn");
		const clearFacesBtn = document.getElementById("clearFacesBtn");
		// Cleanup controls
		const cleanupProgress = document.getElementById("cleanupProgress");
		const cleanupPct = document.getElementById("cleanupPct");
		const keepOrphansChk = document.getElementById("keepOrphansChk");
		const cleanupDryRunBtn = document.getElementById("cleanupDryRunBtn");
		const cleanupRunBtn = document.getElementById("cleanupRunBtn");
		const cleanupSummary = document.getElementById("cleanupSummary");
		// Jobs Activity DOM
		const jobsTableBody = document.getElementById("jobsTableBody");
		let tasksRefreshTimer = null;
		// Collect all Tasks progress elements for animation toggling
		const _allProgressEls = [
		coverProgress,
		facesProgress,
		hoverProgress,
		metadataProgress,
		phashProgress,
		scenesProgress,
		heatmapsProgress,
		subtitlesProgress,
		spritesProgress,
		cleanupProgress,
		].filter(Boolean);
		function setIndeterminateActive(active) {
			// No-op to avoid animating all progress bars; we use per-task animation instead.
			// Left in place for compatibility with callers.
		}
		// Quick helpers to start a batch in a resilient way (avoid waiting on long-held HTTP)
		async function postWithTimeout(url, ms = 3000) {
			const ctrl = new AbortController();
			const t = setTimeout(() => ctrl.abort(), ms);
			try {
				const r = await fetch(url, { method: 'POST', signal: ctrl.signal });
				return !!r && r.ok;
			} catch (_) {
				// Treat abort as success (likely job accepted and server kept connection open)
				return false;
			} finally { clearTimeout(t); }
		}
		function burstStatsRefresh(ticks = 6, intervalMs = 800) {
			let n = 0;
			const id = setInterval(() => {
				try { updateTasksStats(); } catch (_) {}
				if (++n >= ticks) clearInterval(id);
			}, intervalMs);
		}
		async function startBatchFlow(jobType, startUrl) {
			try { setIndeterminateForJobType(jobType, true); } catch (_) {}
			try { startJobsSSE(); } catch (_) {}
			// Fire request with short timeout; don't block UI
			postWithTimeout(startUrl, 2500).then(() => {}).catch(() => {});
			// Try to detect activity quickly and keep stats fresh
			burstStatsRefresh();
			// Opportunistic active jobs check (non-blocking)
			try {
				setTimeout(async () => {
					try {
						const res = await fetch('/api/jobs?state=active');
						if (res.ok) {
							const body = await res.json();
							const list = (body.data && body.data.jobs) || body.jobs || [];
							if (Array.isArray(list) && list.some(j => (j.type||'').toLowerCase().includes(String(jobType)))) {
								window.__jobsActive = true;
								try { updatePollingInterval(); } catch(_){}
							}
						}
					} catch(_){}
				}, 600);
			} catch (_) {}
		}
		// Scope indeterminate animation to a specific task section by name
		function setTaskIndeterminate(taskName, active) {
			const section = document.querySelector(`[data-task-section="${taskName}"] .progress-lg`);
			if (!section) return;
			section.classList.toggle("indeterminate", !!active);
		}
		// TODO @copilot: is this necessary?
		const JOB_SECTION_BY_TYPE = {
			"metadata": "metadata",
			"cover": "covers",
			"hover": "hovers",
			"phash": "phash",
			"scenes": "scenes",
			"sprites": "sprites",
			"heatmaps": "heatmaps",
			"subtitles": "subtitles",
			"faces": "faces",
		};
		// TODO @copilot: this should no longer be necessary
		function normalizeJobType(type) {
			let t = (type || "").toLowerCase();
			// Collapse batch variants to their base type
			if (t.endsWith("-batch")) {
				t = t.slice(0, -6);
			}
			// Collapse any hover variants (e.g., hover-concat) to "hover"
			if (t.startsWith("hover")) {
				t = "hover";
			}
			return t;
		}
		function getTaskSectionFromJobType(type) {
			const t = normalizeJobType(type);
			return JOB_SECTION_BY_TYPE[t] || null;
		}
		function setIndeterminateForJobType(type, active) {
			const section = getTaskSectionFromJobType(type);
			if (section) {
				setTaskIndeterminate(section, active);
			}
		}
		
		// --- Jobs Activity table helpers ---
		const __jobRows = new Map(); // id -> {tr, cells, last}
		function __shortName(p) {
			try {
				if (!p) return "";
				const u = decodeURIComponent(p);
				const parts = u.split(/[\\/]/);
				return parts[parts.length - 1] || u;
			} catch (_) { return p || ""; }
		}
		function __stateFromEvent(evt, error) {
			const e = (evt || '').toLowerCase();
			if (e === 'created' || e === 'queued') return 'queued';
			if (e === 'started' || e === 'progress') return 'running';
			if (e === 'cancel') return 'canceled';
			if (e === 'finished') return error ? 'failed' : 'done';
			return e || 'unknown';
		}
		function upsertJobRow(data) {
			if (!jobsTableBody) return;
			const id = data.id;
			if (!id) return;
			const nowStr = new Date().toLocaleTimeString();
			const t = normalizeJobType(data.type || '');
			const path = data.path || '';
			const state = (data.state) || __stateFromEvent(data.event, data.error);
			const total = data.total != null ? parseInt(data.total, 10) : null;
			const processed = data.processed != null ? parseInt(data.processed, 10) : null;
			let row = __jobRows.get(id);
			if (!row) {
				const tr = document.createElement('tr');
				tr.dataset.jobId = id;
				const tdWhen = document.createElement('td');
				tdWhen.className = 'small'; tdWhen.style.padding = '4px 8px';
				const tdTask = document.createElement('td');
				tdTask.className = 'small'; tdTask.style.padding = '4px 8px';
				const tdFile = document.createElement('td');
				tdFile.className = 'small'; tdFile.style.padding = '4px 8px'; tdFile.style.maxWidth = '40vw'; tdFile.style.whiteSpace = 'nowrap'; tdFile.style.overflow = 'hidden'; tdFile.style.textOverflow = 'ellipsis';
				const tdState = document.createElement('td');
				tdState.className = 'small'; tdState.style.padding = '4px 8px';
				const tdProg = document.createElement('td');
				tdProg.className = 'small'; tdProg.style.padding = '4px 8px';
				const prog = document.createElement('progress'); prog.max = 100; prog.value = 0; prog.className = 'progress-sm'; prog.style.minWidth = '140px';
				const progText = document.createElement('div'); progText.className = 'small muted';
				tdProg.appendChild(prog); tdProg.appendChild(progText);
				tr.appendChild(tdWhen); tr.appendChild(tdTask); tr.appendChild(tdFile); tr.appendChild(tdState); tr.appendChild(tdProg);
				jobsTableBody.insertBefore(tr, jobsTableBody.firstChild);
				row = { tr, cells: { tdWhen, tdTask, tdFile, tdState, prog, progText }, last: {} };
				__jobRows.set(id, row);
				// keep at most 300 rows to avoid unbounded growth
				while (jobsTableBody.children.length > 300) {
					const last = jobsTableBody.lastElementChild;
					if (!last) break;
					__jobRows.delete(last.dataset.jobId);
					jobsTableBody.removeChild(last);
				}
			}
			const { tdWhen, tdTask, tdFile, tdState, prog, progText } = row.cells;
			// Update cells (only if changed to minimize layout work)
			if (row.last.when !== nowStr) { tdWhen.textContent = nowStr; row.last.when = nowStr; }
			if (row.last.task !== t) { tdTask.textContent = t || (data.type || ''); row.last.task = t; }
			const fileShort = __shortName(path);
			if (row.last.file !== fileShort) { tdFile.textContent = fileShort || ''; tdFile.title = path || ''; row.last.file = fileShort; }
			if (row.last.state !== state) { tdState.textContent = state || ''; row.last.state = state; }
			let pct = null;
			if (total != null && total > 0 && processed != null) pct = Math.max(0, Math.min(100, Math.floor((processed / total) * 100)));
			if (pct == null && (state === 'running' || state === 'queued')) {
				prog.removeAttribute('value'); // indeterminate
				progText.textContent = processed != null ? `${processed}/${total ?? '?'}` : '';
			} else if (pct != null) {
				prog.value = pct;
				progText.textContent = `${processed ?? 0}/${total ?? 0} (${pct}%)`;
			} else {
				prog.value = 0;
				progText.textContent = '';
			}
			// Dim done/failed rows slightly
			if (state === 'done') row.tr.style.opacity = '0.85';
			else if (state === 'failed') row.tr.style.opacity = '0.95';
			else row.tr.style.opacity = '';
		}
		async function updateTasksStats() {
			try { 
				const res = await fetch("/api/stats?fast=1");
				if (!res.ok) return;
				const body = await res.json();
				const s = body.data || body;
				const total = s.total_files || 0;
				const pct = (n, t) => (t ? Math.floor((n / t) * 100) : 0);
				
				// TODO @copilot: seems like this section could be DRYer
				// Covers
				const covers = s.covers || 0;
				if (coverProgress) coverProgress.value = pct(covers, total);
				if (coverPct) coverPct.textContent = `${covers}/${total} (${pct(covers, total)}%)`;
				// Hovers
				const hovers = s.hovers || 0;
				if (hoverProgress) hoverProgress.value = pct(hovers, total);
				if (hoverPct) hoverPct.textContent = `${hovers}/${total} (${pct(hovers, total)}%)`;
				// Metadata
				const metas = s.metadata || 0;
				if (metadataProgress) metadataProgress.value = pct(metas, total);
				if (metaPct) metaPct.textContent = `${metas}/${total} (${pct(metas, total)}%)`;
				// pHash
				const phashes = s.phash || 0;
				if (phashProgress) phashProgress.value = pct(phashes, total);
				if (phashPct) phashPct.textContent = `${phashes}/${total} (${pct(phashes, total)}%)`;
				// Scenes
				const scenes = s.scenes || 0;
				if (scenesProgress) scenesProgress.value = pct(scenes, total);
				if (scenesPct) scenesPct.textContent = `${scenes}/${total} (${pct(scenes, total)}%)`;
				// Sprites
				const sprites = s.sprites || 0;
				if (spritesProgress) spritesProgress.value = pct(sprites, total);
				if (spritesPct) spritesPct.textContent = `${sprites}/${total} (${pct(sprites, total)}%)`;
				// Heatmaps
				const heatmaps = s.heatmaps || 0;
				if (heatmapsProgress) heatmapsProgress.value = pct(heatmaps, total);
				if (heatmapsPct) heatmapsPct.textContent = `${heatmaps}/${total} (${pct(heatmaps, total)}%)`;
				// Subtitles
				const subs = s.subtitles || 0;
				if (subtitlesProgress) subtitlesProgress.value = pct(subs, total);
				if (subsPct) subsPct.textContent = `${subs}/${total} (${pct(subs, total)}%)`;
				// Faces
				const faces = s.faces || 0;
				if (facesProgress) facesProgress.value = pct(faces, total);
				if (facesPct) facesPct.textContent = `${faces}/${total} (${pct(faces, total)}%)`;
			}
			catch (_) { }
		}
		if (clearCoversBtn) {
			clearCoversBtn.onclick = async () => {
				clearCoversBtn.disabled = true;
				let allMediaFiles = [];
				let page = 1;
				let pageSize = 500;
				let totalPages = 1;
				do {
					const params = new URLSearchParams();
					params.set("page", String(page));
					params.set("page_size", String(pageSize));
					const res = await fetch("/api/library?" + params.toString(), {
						method: "GET",
					});
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					allMediaFiles = allMediaFiles.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (let i = 0; i< allMediaFiles.length; i++) {
					const file = allMediaFiles[i];
					if (file.cover) {
						// Remove cover file via API (needs backend endpoint)
						await fetch(`/api/cover/delete?path=${encodeURIComponent(file.path)}`, {method: "DELETE"});
					}
				}
				clearCoversBtn.disabled = false;
				updateTasksStats();
				// Also refresh Stats so the COVERS count drops immediately
				try { await loadStats(); } catch (_) { }
				// Refresh grid so removed covers disappear
				try { 
					await load(cwd);
				}
				catch (_) { }
			};
		}
		
		// Recompute ALL covers (batch with overwrite)
		if (recomputeAllCoversBtn) {
			recomputeAllCoversBtn.onclick = async () => {
				recomputeAllCoversBtn.disabled = true;
				try {
					await startBatchFlow('cover', `/api/cover/create/batch?overwrite=true`);
					try { await loadStats(); } catch (_) { }
				} finally { recomputeAllCoversBtn.disabled = false; }
			};
		}
		if (generateMissingCoversBtn) {
			generateMissingCoversBtn.onclick = async () => {
				generateMissingCoversBtn.disabled = true;
				try { 
					// Prefer server-side batch; don't block on long-held connection
					let usedBatch = false;
					try {
						startBatchFlow('cover', `/api/cover/create/batch`);
						usedBatch = true;
					} catch (_) { usedBatch = false; }
					if (!usedBatch) {
						// Fallback: iterate client-side
						let allMediaFiles = [];
						let page = 1;
						let pageSize = 500;
						let totalPages = 1;
						do {
							const params = new URLSearchParams();
							params.set("page", String(page));
							params.set("page_size", String(pageSize));
							const res = await fetch("/api/library?" + params.toString(), { method: "GET" });
							if (!res.ok) break;
							const body = await res.json();
							const data = body.data || body;
							allMediaFiles = allMediaFiles.concat(data.files || []);
							totalPages = data.total_pages || 1;
							page++;
						}
						while (page <= totalPages);
						for (let i = 0; i < allMediaFiles.length; i++) {
							const file = allMediaFiles[i];
							if (!file.cover) {
								await fetch(`/api/cover/create?path=${encodeURIComponent(file.path)}`, { method: "POST" });
								if (i % 10 === 0) { try { updateTasksStats(); } catch (_) { } }
							}
						}
					}
				}
				finally {
					generateMissingCoversBtn.disabled = false;
					updateTasksStats();
					try { await loadStats(); } catch (_) { }
					try { await load(cwd); } catch (_) { }
				}
			};
		}
		if (generateMissingHoversBtn) {
			generateMissingHoversBtn.onclick = async () => {
				generateMissingHoversBtn.disabled = true;
				try {
					const qs = new URLSearchParams();
					if (hoverSegmentsInput) qs.set("segments", String(parseInt(hoverSegmentsInput.value || "9", 10)));
					if (hoverSegDurInput) qs.set("seg_dur", String(parseFloat(hoverSegDurInput.value || "1.0")));
					if (hoverWidthInput) qs.set("width", String(parseInt(hoverWidthInput.value || "320", 10)));
					await startBatchFlow('hover', `/api/hover/create/batch?${qs.toString()}`);
				}
				catch (_) {
					await startBatchFlow('hover', `/api/hover/create/batch`);
				}
				generateMissingHoversBtn.disabled = false;
				updateTasksStats();
				try { await loadStats(); } catch (_) { }
				// Refresh grid to reflect hover availability flags
				try { 
					await load(cwd);
				}
				catch (_) { }
			};
		}
		// Recompute ALL hovers
		if (recomputeAllHoversBtn) {
			recomputeAllHoversBtn.onclick = async () => {
				recomputeAllHoversBtn.disabled = true;
				try {
					const qs = new URLSearchParams();
					if (hoverSegmentsInput) qs.set("segments", String(parseInt(hoverSegmentsInput.value || "9", 10)));
					if (hoverSegDurInput) qs.set("seg_dur", String(parseFloat(hoverSegDurInput.value || "1.0")));
					if (hoverWidthInput) qs.set("width", String(parseInt(hoverWidthInput.value || "320", 10)));
					await startBatchFlow('hover', `/api/hover/create/batch?${qs.toString()}`);
					updateTasksStats(); try { await loadStats(); } catch (_) { }
				} finally { recomputeAllHoversBtn.disabled = false; }
			};
		}
		/* removed broken duplicate generateMissingCoversBtn block */
		if (generateMissingMetaBtn) {
			generateMissingMetaBtn.onclick = async () => {
				generateMissingMetaBtn.disabled = true;
				let allMediaFiles = [];
				let page = 1;
				let pageSize = 500;
				let totalPages = 1;
				do {
					const params = new URLSearchParams();
					params.set("page", String(page));
					params.set("page_size", String(pageSize));
					const res = await fetch("/api/library?" + params.toString(), {
						method: "GET",
					});
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					allMediaFiles = allMediaFiles.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (let i = 0; i< allMediaFiles.length; i++) {
					const file = allMediaFiles[i];
					if (file.duration == null) {
						// Regenerate metadata by calling /api/metadata (GET)
						await fetch(`/api/metadata/create?path=${encodeURIComponent(file.path)}`, {method: "POST"});
					}
				}
				generateMissingMetaBtn.disabled = false;
				updateTasksStats();
				try { await loadStats(); } catch (_) { }
				// Refresh grid for updated duration/flags
				try { 
					await load(cwd);
				}
				catch (_) { }
			};
		}
		if (recomputeAllMetaBtn) {
			recomputeAllMetaBtn.onclick = async () => {
				recomputeAllMetaBtn.disabled = true;
				try { 
					// Use jobs API to recompute metadata with force=true across library
					const base = {task: "metadata", directory: "", recursive: true, force: true };
					const r = await fetch("/jobs", {method: "POST", headers: {"Content-Type": "application/json" }, body: JSON.stringify(base) });
					if (r.ok) {
						try { startJobsSSE(); }
						catch (_) { }
						// Nudge Tasks stats quickly
						let ticks = 0;
						const burst = setInterval(() => {
							try { updateTasksStats(); }
							catch (_) { }
							if (++ticks >= 10) {
								clearInterval(burst);
							}
						}, 1000);
					}
				}
				finally {
					recomputeAllMetaBtn.disabled = false;
					updateTasksStats();
					try { await loadStats(); }
					catch (_) { }
				}
			};
		}
		// Recompute ALL pHash
		if (recomputeAllPhashBtn) {
			recomputeAllPhashBtn.onclick = async () => {
				recomputeAllPhashBtn.disabled = true;
				try {
					let page = 1, pageSize = 500, totalPages = 1, files = [];
					do {
						const params = new URLSearchParams({ page: String(page), page_size: String(pageSize) });
						const res = await fetch("/api/library?" + params.toString());
						if (!res.ok) break;
						const body = await res.json();
						const data = body.data || body; files = files.concat(data.files || []);
						totalPages = data.total_pages || 1; page++;
					} while (page <= totalPages);
					for (const f of files) {
						await fetch(`/api/phash/create?path=${encodeURIComponent(f.path)}`, { method: "POST" });
					}
					updateTasksStats(); try { await loadStats(); } catch(_){}
				} finally { recomputeAllPhashBtn.disabled = false; }
			};
		}
		if (clearMetaBtn) {
			clearMetaBtn.onclick = async () => {
				clearMetaBtn.disabled = true;
				let allMediaFiles = [];
				let page = 1;
				let pageSize = 500;
				let totalPages = 1;
				do {
					const params = new URLSearchParams();
					params.set("page", String(page));
					params.set("page_size", String(pageSize));
					const res = await fetch("/api/library?" + params.toString(), {
						method: "GET",
					});
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					allMediaFiles = allMediaFiles.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (let i = 0; i< allMediaFiles.length; i++) {
					const file = allMediaFiles[i];
					// Remove meta file via API (needs backend endpoint)
					await fetch(`/api/metadata/delete?path=${encodeURIComponent(file.path)}`, {method: "DELETE"});
				}
				clearMetaBtn.disabled = false;
				updateTasksStats();
				try { await loadStats(); } catch (_) { }
				// Refresh grid after clearing metadata
				try { 
					await load(cwd);
				}
				catch (_) { }
			};
		}
		
		// --- Artifacts Cleanup wiring ---
		async function pollJobUntilDone(jobId, onProgress) {
			// Poll /jobs/{id} for status and results
			const get = async () => {
				try { 
					const res = await fetch(`/jobs/${encodeURIComponent(jobId)}`);
					if (!res.ok) {
						return null;
					}
					return await res.json();
				}
				catch (_) {
					return null;
				}
			};
			let info = await get();
			// Best-effort quick loop; backend also emits SSE events we already subscribe to
			const start = Date.now();
			while (info && info.status && ["queued","running","cancel_requested"].includes(info.status)) {
				if (typeof onProgress === "function") {
					try { onProgress(info); }
					catch (_) { }
				}
				await new Promise(r => setTimeout(r, 500));
				info = await get();
				if (Date.now() - start >5 * 60 * 1000) break; // cap at 5 minutes
			}
			if (typeof onProgress === "function" && info) {
				try { onProgress(info); }
				catch (_) { }
			}
			return info;
		}
		function setCleanupProgress(processed, total) {
			if (!cleanupProgress || !cleanupPct) return;
			const t = Math.max(0, Number(total) || 0);
			const p = Math.max(0, Math.min(t, Number(processed) || 0));
			const pct = t ? Math.floor((p / t) * 100) : 0;
			cleanupProgress.value = pct;
			cleanupPct.textContent = `${p}/${t} (${pct}%)`;
		}
		async function runArtifactsCleanup(dryRun) {
			if (cleanupDryRunBtn) cleanupDryRunBtn.disabled = true;
			if (cleanupRunBtn) cleanupRunBtn.disabled = true;
			if (cleanupSummary) cleanupSummary.textContent = "";
			try { 
				const params = new URLSearchParams({dry_run: String(!!dryRun), keep_orphans: String(!!(keepOrphansChk && keepOrphansChk.checked)) });
				const res = await fetch(`/api/artifacts/cleanup?${params.toString()}`, {method: "POST" });
				if (!res.ok) return;
				const j = await res.json();
				const jobId = (j.data && j.data.job) || j.job;
				if (!jobId) return;
				try { startJobsSSE(); }
				catch (_) { }
				setTaskIndeterminate("cleanup", true);
				await pollJobUntilDone(jobId, (info) => {
					if (!info) return;
					setCleanupProgress(info.processed || 0, info.total || 0);
				});
				// Fetch final result one more time
				try { 
					const s = await fetch(`/jobs/${encodeURIComponent(jobId)}`);
					if (s.ok) {
						const body = await s.json();
						const result = body.result || {};
						const renamed = result.renamed || [];
						const deleted = result.deleted || [];
						const kept = result.kept || [];
						const isDry = !!result.dry_run;
						const lines = [];
						lines.push(isDry ? "Dry-run results:" : "Cleanup results:");
						lines.push(`Renamed: ${renamed.length}, Deleted: ${deleted.length}, Kept: ${kept.length}`);
						if (renamed.length) {
							lines.push("\nRenamed:");
							renamed.slice(0, 20).forEach(r => lines.push(`- ${r.from} ->${r.to}`));
							if (renamed.length >20) lines.push(`… and ${renamed.length - 20} more`);
						}
						if (deleted.length) {
							lines.push("\nDeleted:");
							deleted.slice(0, 20).forEach(d => lines.push(`- ${d}`));
							if (deleted.length >20) lines.push(`… and ${deleted.length - 20} more`);
						}
						if (kept.length && isDry) {
							lines.push("\nKept (dry-run or keep-orphans):");
							kept.slice(0, 20).forEach(k => lines.push(`- ${k}`));
							if (kept.length >20) lines.push(`… and ${kept.length - 20} more`);
						}
						if (cleanupSummary) cleanupSummary.textContent = lines.join("\n");
					}
				}
				catch (_) { }
			}
			finally {
				if (cleanupDryRunBtn) cleanupDryRunBtn.disabled = false;
				if (cleanupRunBtn) cleanupRunBtn.disabled = false;
				setTaskIndeterminate("cleanup", false);
				updateTasksStats();
				try { await loadStats(); }
				catch (_) { }
				try { await load(cwd); }
				catch (_) { }
			}
		}
		if (cleanupDryRunBtn) cleanupDryRunBtn.onclick = () => runArtifactsCleanup(true);
		if (cleanupRunBtn) cleanupRunBtn.onclick = () => runArtifactsCleanup(false);
		
		// pHash buttons
		if (generateMissingPhashBtn) {
			generateMissingPhashBtn.onclick = async () => {
				generateMissingPhashBtn.disabled = true;
				let page = 1,
				pageSize = 500,
				totalPages = 1,
				files = [];
				do {
					const params = new URLSearchParams({
						page: String(page),
						page_size: String(pageSize),
					});
					const res = await fetch("/api/library?" + params.toString());
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					files = files.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (const f of files) {
					if (!f.phash) {
						await fetch(`/api/phash/create?path=${encodeURIComponent(f.path)}`, {method: "POST"});
					}
				}
				generateMissingPhashBtn.disabled = false;
				updateTasksStats();
				try { await loadStats(); } catch (_) { }
			};
		}
		if (clearPhashBtn) {
			clearPhashBtn.onclick = async () => {
				clearPhashBtn.disabled = true;
				let page = 1,
				pageSize = 500,
				totalPages = 1,
				files = [];
				do {
					const params = new URLSearchParams({
						page: String(page),
						page_size: String(pageSize),
					});
					const res = await fetch("/api/library?" + params.toString());
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					files = files.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (const f of files) {
					if (f.phash) {
						await fetch(`/api/phash/delete?path=${encodeURIComponent(f.path)}`, {method: "DELETE" });
					}
				}
				clearPhashBtn.disabled = false;
				updateTasksStats();
				try { await loadStats(); } catch (_) { }
			};
		}
		
		// Scenes buttons
		if (generateMissingScenesBtn) {
			generateMissingScenesBtn.onclick = async () => {
				generateMissingScenesBtn.disabled = true;
				let page = 1,
				pageSize = 500,
				totalPages = 1,
				files = [];
				do {
					const params = new URLSearchParams({
						page: String(page),
						page_size: String(pageSize),
					});
					const res = await fetch("/api/library?" + params.toString());
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					files = files.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (const f of files) {
					if (!f.chapters) {
						await fetch(`/api/scenes/create?path=${encodeURIComponent(f.path)}`, {method: "POST"});
					}
				}
				generateMissingScenesBtn.disabled = false;
				updateTasksStats();
				try { await loadStats(); } catch (_) { }
			};
		}
		// Recompute ALL scenes
		if (recomputeAllScenesBtn) {
			recomputeAllScenesBtn.onclick = async () => {
				recomputeAllScenesBtn.disabled = true;
				try {
					let page = 1, pageSize = 500, totalPages = 1, files = [];
					do {
						const params = new URLSearchParams({ page: String(page), page_size: String(pageSize) });
						const res = await fetch("/api/library?" + params.toString());
						if (!res.ok) break; const body = await res.json();
						const data = body.data || body; files = files.concat(data.files || []);
						totalPages = data.total_pages || 1; page++;
					} while (page <= totalPages);
					for (const f of files) {
						await fetch(`/api/scenes/create?path=${encodeURIComponent(f.path)}`, { method: "POST" });
					}
					updateTasksStats(); try { await loadStats(); } catch(_){}
				} finally { recomputeAllScenesBtn.disabled = false; }
			};
		}
		if (clearScenesBtn) {
			clearScenesBtn.onclick = async () => {
				clearScenesBtn.disabled = true;
				let page = 1,
				pageSize = 500,
				totalPages = 1,
				files = [];
				do {
					const params = new URLSearchParams({
						page: String(page),
						page_size: String(pageSize),
					});
					const res = await fetch("/api/library?" + params.toString());
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					files = files.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (const f of files) {
					if (f.chapters) {
						await fetch(`/api/scenes/delete?path=${encodeURIComponent(f.path)}`, {method: "DELETE"});
					}
				}
				clearScenesBtn.disabled = false;
				updateTasksStats();
				try { await loadStats(); } catch (_) { }
			};
		}
		
		// Sprites buttons
		if (generateMissingSpritesBtn) {
			generateMissingSpritesBtn.onclick = async () => {
				generateMissingSpritesBtn.disabled = true;
				try {
					const qs = new URLSearchParams();
					if (spriteIntervalInput) qs.set("interval", String(parseFloat(spriteIntervalInput.value || "10")));
					if (spriteWidthInput) qs.set("width", String(parseInt(spriteWidthInput.value || "320", 10)));
					if (spriteColsInput) qs.set("cols", String(parseInt(spriteColsInput.value || "10", 10)));
					if (spriteRowsInput) qs.set("rows", String(parseInt(spriteRowsInput.value || "10", 10)));
					if (spriteQualityInput) qs.set("quality", String(parseInt(spriteQualityInput.value || "4", 10)));
					await startBatchFlow('sprites', `/api/sprites/create/batch?${qs.toString()}`);
				}
				catch (_) {
					await startBatchFlow('sprites', `/api/sprites/create/batch`);
				}
				generateMissingSpritesBtn.disabled = false;
				updateTasksStats();
				try { await loadStats(); } catch (_) { }
			};
		}
		// Recompute ALL sprites
		if (recomputeAllSpritesBtn) {
			recomputeAllSpritesBtn.onclick = async () => {
				recomputeAllSpritesBtn.disabled = true;
				try {
					const qs = new URLSearchParams();
					if (spriteIntervalInput) qs.set("interval", String(parseFloat(spriteIntervalInput.value || "10")));
					if (spriteWidthInput) qs.set("width", String(parseInt(spriteWidthInput.value || "320", 10)));
					if (spriteColsInput) qs.set("cols", String(parseInt(spriteColsInput.value || "10", 10)));
					if (spriteRowsInput) qs.set("rows", String(parseInt(spriteRowsInput.value || "10", 10)));
					if (spriteQualityInput) qs.set("quality", String(parseInt(spriteQualityInput.value || "4", 10)));
					await startBatchFlow('sprites', `/api/sprites/create/batch?${qs.toString()}`);
					updateTasksStats(); try { await loadStats(); } catch(_){}
				}
				finally { recomputeAllSpritesBtn.disabled = false; }
			};
		}
		
		// Heatmaps buttons
		if (generateMissingHeatmapsBtn) {
			generateMissingHeatmapsBtn.onclick = async () => {
				generateMissingHeatmapsBtn.disabled = true;
				try {
					const qs = new URLSearchParams();
					if (heatmapsIntervalInput) qs.set("interval", String(parseFloat(heatmapsIntervalInput.value || "5.0")));
					if (heatmapsModeSelect) qs.set("mode", String(heatmapsModeSelect.value || "both"));
					qs.set("png", (heatmapsPngChk && heatmapsPngChk.checked) ? "true" : "false");
					await startBatchFlow('heatmaps', `/api/heatmaps/create/batch?${qs.toString()}`);
				}
				catch (_) {
					await startBatchFlow('heatmaps', `/api/heatmaps/create/batch`);
				}
				generateMissingHeatmapsBtn.disabled = false;
				updateTasksStats();
				try { await loadStats(); }
				catch (_) { }
			};
		}
		// Recompute ALL heatmaps
		if (recomputeAllHeatmapsBtn) {
			recomputeAllHeatmapsBtn.onclick = async () => {
				recomputeAllHeatmapsBtn.disabled = true;
				try {
					const qs = new URLSearchParams();
					if (heatmapsIntervalInput) qs.set("interval", String(parseFloat(heatmapsIntervalInput.value || "5.0")));
					if (heatmapsModeSelect) qs.set("mode", String(heatmapsModeSelect.value || "both"));
					qs.set("png", (heatmapsPngChk && heatmapsPngChk.checked) ? "true" : "false");
					await startBatchFlow('heatmaps', `/api/heatmaps/create/batch?${qs.toString()}`);
					updateTasksStats(); try { await loadStats(); } catch(_){}
				}
				finally { recomputeAllHeatmapsBtn.disabled = false; }
			};
		}
		
		// Subtitles buttons
		if (generateMissingSubsBtn) {
			generateMissingSubsBtn.onclick = async () => {
				generateMissingSubsBtn.disabled = true;
				await startBatchFlow('subtitles', `/api/subtitles/create/batch`);
				generateMissingSubsBtn.disabled = false;
				updateTasksStats();
				try { await loadStats(); }
				catch (_) { }
			};
		}
		// Recompute ALL subtitles
		if (recomputeAllSubsBtn) {
			recomputeAllSubsBtn.onclick = async () => {
				recomputeAllSubsBtn.disabled = true;
				try { await startBatchFlow('subtitles', `/api/subtitles/create/batch?overwrite=true`); updateTasksStats(); try { await loadStats(); } catch(_){} }
				finally { recomputeAllSubsBtn.disabled = false; }
			};
		}
		
		if (clearSubsBtn) {
			clearSubsBtn.onclick = async () => {
				clearSubsBtn.disabled = true;
				let page = 1,
				pageSize = 500,
				totalPages = 1,
				files = [];
				do {
					const params = new URLSearchParams({
						page: String(page),
						page_size: String(pageSize),
					});
					const res = await fetch("/api/library?" + params.toString());
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					files = files.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (const f of files) {
					if (f.subtitles) {
						await fetch(`/api/subtitles/delete?path=${encodeURIComponent(f.path)}`, {method: "DELETE"});
					}
				}
				clearSubsBtn.disabled = false;
				updateTasksStats();
				try { await loadStats(); }
				catch (_) { }
			};
		}
		if (clearHeatmapsBtn) {
			clearHeatmapsBtn.onclick = async () => {
				clearHeatmapsBtn.disabled = true;
				let page = 1,
				pageSize = 500,
				totalPages = 1,
				files = [];
				do {
					const params = new URLSearchParams({
						page: String(page),
						page_size: String(pageSize),
					});
					const res = await fetch("/api/library?" + params.toString());
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					files = files.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (const f of files) {
					if (f.heatmaps) {
						await fetch(`/api/heatmaps/delete?path=${encodeURIComponent(f.path)}`, {method: "DELETE"});
					}
				}
				clearHeatmapsBtn.disabled = false;
				updateTasksStats();
				try { await loadStats(); } catch (_) { }
			};
		}
		if (clearSpritesBtn) {
			clearSpritesBtn.onclick = async () => {
				clearSpritesBtn.disabled = true;
				let page = 1,
				pageSize = 500,
				totalPages = 1,
				files = [];
				do {
					const params = new URLSearchParams({
						page: String(page),
						page_size: String(pageSize),
					});
					const res = await fetch("/api/library?" + params.toString());
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					files = files.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (const f of files) {
					if (f.scrubThumbs) {
						await fetch(`/api/sprites/delete?path=${encodeURIComponent(f.path)}`, {method: "DELETE"});
					}
				}
				clearSpritesBtn.disabled = false;
				updateTasksStats();
				try { await loadStats(); } catch (_) { }
			};
		}
		
		// Faces buttons
		if (generateMissingFacesBtn) {
			generateMissingFacesBtn.onclick = async () => {
				generateMissingFacesBtn.disabled = true;
				if (recomputeAllFacesBtn) recomputeAllFacesBtn.disabled = true;
				try { 
					const k = readBatchFaceKnobs();
					const qs = new URLSearchParams({
						"backend": String(k.backend || 'auto'),
						"interval": String(k.interval),
						"scale_factor": String(k.scale_factor),
						"min_neighbors": String(k.min_neighbors),
						"min_size_frac": String(k.min_size_frac),
						"sim_thresh": String(k.sim_thresh),
						"only_missing": "true",
					});
					await fetch(`/api/faces/create/batch?${qs.toString()}`, {method: "POST" });
					// Ensure jobs SSE is connected so we see events immediately
					try { startJobsSSE(); } catch (_) { }
					// Fast refresh for a short burst
					let ticks = 0;
					const burst = setInterval(() => {
						try { updateTasksStats(); } catch (_) { }
						if (++ticks >= 10) clearInterval(burst);
					}, 1000);
					// Poll active jobs briefly to reflect activity even if SSE is delayed
					let sawFaces = false;
					for (let i = 0; i< 5; i++) {
						try { 
							const r = await fetch("/api/jobs?state=active");
							if (r.ok) {
								const body = await r.json();
								const list = (body.data && body.data.jobs) || body.jobs || [];
								if (Array.isArray(list) && list.some(j => (j.type||"").toLowerCase().includes("faces"))) {sawFaces = true; break; }
							}
						}
						catch (_) { }
						await new Promise(res => setTimeout(res, 500));
					}
					if (!sawFaces) {
						try { setTaskIndeterminate("faces", true); }
						catch (_) { }
					}
				}
				finally {
					generateMissingFacesBtn.disabled = false;
					if (recomputeAllFacesBtn) recomputeAllFacesBtn.disabled = false;
					updateTasksStats();
					try { await loadStats(); }
					catch (_) { }
				}
			};
		}
		if (recomputeAllFacesBtn) {
			recomputeAllFacesBtn.onclick = async () => {
				recomputeAllFacesBtn.disabled = true;
				if (generateMissingFacesBtn) generateMissingFacesBtn.disabled = true;
				try {
					const k = readBatchFaceKnobs();
					const qs = new URLSearchParams({
						"backend": String(k.backend || 'auto'),
						"interval": String(k.interval),
						"scale_factor": String(k.scale_factor),
						"min_neighbors": String(k.min_neighbors),
						"min_size_frac": String(k.min_size_frac),
						"sim_thresh": String(k.sim_thresh),
						"only_missing": "false",
					});
					await fetch(`/api/faces/create/batch?${qs.toString()}`, {method: "POST" });
					try { startJobsSSE(); }
					catch (_) { }
					let ticks = 0;
					const burst = setInterval(() => {
						try { updateTasksStats(); } catch (_) { }
						if (++ticks >= 10) clearInterval(burst);
					}, 1000);
					let sawFaces = false;
					for (let i = 0; i< 5; i++) {
						try { 
							const r = await fetch("/api/jobs?state=active");
							if (r.ok) {
								const body = await r.json();
								const list = (body.data && body.data.jobs) || body.jobs || [];
								if (Array.isArray(list) && list.some(j => (j.type||"").toLowerCase().includes("faces"))) {sawFaces = true; break; }
							}
						}
						catch (_) { }
						await new Promise(res => setTimeout(res, 500));
					}
					if (!sawFaces) {
						try { setTaskIndeterminate("faces", true); } catch (_) { }
					}
				}
				finally {
					recomputeAllFacesBtn.disabled = false;
					if (generateMissingFacesBtn) generateMissingFacesBtn.disabled = false;
					updateTasksStats();
					try { await loadStats(); } catch (_) { }
				}
			};
		}
		if (clearFacesBtn) {
			clearFacesBtn.onclick = async () => {
				clearFacesBtn.disabled = true;
				let page = 1,
				pageSize = 500,
				totalPages = 1,
				files = [];
				do {
					const params = new URLSearchParams({
						page: String(page),
						page_size: String(pageSize),
					});
					const res = await fetch("/api/library?" + params.toString());
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					files = files.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				for (const f of files) {
					if (f.faces) {
						await fetch(`/api/faces/delete?path=${encodeURIComponent(f.path)}`, {method: "DELETE"});
					}
				}
				clearFacesBtn.disabled = false;
				updateTasksStats();
				try { await loadStats(); } catch (_) { }
			};
		}
		
		let jobsEvtSrc = null;
		// Track active job IDs to switch polling cadence and animations
		let __runningJobIds = new Set();
		window.__jobsActive = false;
		function startJobsSSE() {
			if (jobsEvtSrc) {
				try { jobsEvtSrc.close(); } catch (_) { }
				jobsEvtSrc = null;
			}
			let triedApiAlias = false;
			const openEs = (url) => {
				const es = new EventSource(url);
				jobsEvtSrc = es;
				es.onmessage = (ev) => {
					try { 
						const data = JSON.parse(ev.data || "{}");
						const line = `[${new Date().toLocaleTimeString()}] ${data.event || "msg"} ${data.id || ""}`;
						if (typeof jobsBox !== "undefined" && jobsBox) {
							jobsBox.textContent = (jobsBox.textContent + "\n" + line).trim();
							jobsBox.scrollTop = jobsBox.scrollHeight;
						}
						// Update one-row-per-job activity table
						try { upsertJobRow(data); } catch (_) {}
						// Maintain set of running jobs and update UI cadence
						const evt = (data.event || "").toLowerCase();
						const jid = data.id;
						if ((evt === "started" || evt === "queued" || evt === "created") && jid) {
							__runningJobIds.add(jid);
							// toggle only that task section's animation if known
							setIndeterminateForJobType(data.type, true);
						}
						else if (evt === "progress" && jid && !__runningJobIds.has(jid)) {
							// If we refreshed after a job started, the first event we see may be progress
							__runningJobIds.add(jid);
							setIndeterminateForJobType(data.type, true);
						}
						else if ((evt === "finished" || evt === "cancel") && jid) {
							__runningJobIds.delete(jid);
							setIndeterminateForJobType(data.type, false);
						}
						const newActive = __runningJobIds.size >0;
						if (window.__jobsActive !== newActive) {
							window.__jobsActive = newActive;
							try { 
								updatePollingInterval();
							}
							catch (_) { }
							try { 
								setIndeterminateActive(newActive);
							}
							catch (_) { }
						}
						// Nudge a quick stats refresh on any event for snappier feedback
						try { updateTasksStats(); } catch (_) { }
					}
					catch (_) { }
				};
				es.onerror = () => {
					// First failure: try API alias once, then let browser retry
					if (!triedApiAlias) {
						triedApiAlias = true;
						try { es.close(); } catch (_) { }
						openEs("/api/jobs/events");
					}
				};
			};
			openEs("/jobs/events");
			// After connecting, fetch current active jobs to restore UI state on refresh
			(async () => {
				try { 
					const res = await fetch("/api/jobs?state=active");
					if (res.ok) {
						const body = await res.json();
						const list = (body.data && body.data.jobs) || body.jobs || [];
						let anyActive = false;
						for (const j of list) {
							if (!j || (j.state !== "queued" && j.state !== "running")) continue;
							const jid = j.id;
							if (jid && !__runningJobIds.has(jid)) __runningJobIds.add(jid);
							setIndeterminateForJobType(j.type, true);
							try { upsertJobRow(j); } catch (_) {}
							anyActive = true;
						}
						if (anyActive) {
							if (window.__jobsActive !== true) {
								window.__jobsActive = true;
								try { updatePollingInterval(); } catch (_) { }
								try { setIndeterminateActive(true); } catch (_) { }
							}
						}
					}
				}
				catch (_) { }
				// Also seed recent finished jobs for quick context
				try {
					const r2 = await fetch("/api/jobs?state=recent");
					if (r2.ok) {
						const b2 = await r2.json();
						const list2 = (b2.data && b2.data.jobs) || b2.jobs || [];
						for (const j of list2) { try { upsertJobRow(j); } catch (_) {} }
					}
				} catch (_) {}
			})();
		}
		
		// Refresh stats and jobs every 1 second in Tasks tab
		function startTasksRefresh() {
			updateTasksStats();
			updatePollingInterval();
		}
		// Update polling cadence based on job activity (fast when active, slow when idle)
		function updatePollingInterval() {
			if (tasksRefreshTimer) clearInterval(tasksRefreshTimer);
			// Only poll if Tasks tab is visible
			if (!tasksDiv || tasksDiv.classList.contains("hidden")) return;
			const intervalMs = window.__jobsActive === true ? 1000 : 5000;
			tasksRefreshTimer = setInterval(() => {
				updateTasksStats();
			}, intervalMs);
		}
		// Wire up tabs: use DRY showTab; per-tab side effects happen inside showTab
		document.getElementById("tabTasks").onclick = () => {showTab("Tasks"); };
		// --- IMAGE TAB LOGIC (FaceLab) ---
		const imageStatus = document.getElementById("imageStatus");
		const facesList = document.getElementById("facesList");
		const refreshFacesBtn = document.getElementById("refreshFacesBtn");
		const createFacesBtn = document.getElementById("createFacesBtn");
		const faceBackendSelect = document.getElementById("faceBackendSelect");
		const faceBatchBackendSelect = document.getElementById("faceBatchBackendSelect");
		
		// Face tuning inputs and helpers
		const faceIntervalInput = document.getElementById("faceIntervalInput");
		const faceScaleFactorInput = document.getElementById("faceScaleFactorInput");
		const faceMinNeighborsInput = document.getElementById("faceMinNeighborsInput");
		const faceMinSizeFracInput = document.getElementById("faceMinSizeFracInput");
		const faceSimThreshInput = document.getElementById("faceSimThreshInput");
		const faceBatchIntervalInput = document.getElementById("faceBatchIntervalInput");
		const faceBatchScaleFactorInput = document.getElementById("faceBatchScaleFactorInput");
		const faceBatchMinNeighborsInput = document.getElementById("faceBatchMinNeighborsInput");
		const faceBatchMinSizeFracInput = document.getElementById("faceBatchMinSizeFracInput");
		const faceBatchSimThreshInput = document.getElementById("faceBatchSimThreshInput");
		
		// TODO @copilot v1 reference
		const FACE_SINGLE_KEY = "face.knobs.single.v1";
		const FACE_BATCH_KEY = "face.knobs.batch.v1";
		const FACE_BACKEND_SINGLE_KEY = "face.backend.single.v1";
		const FACE_BACKEND_BATCH_KEY = "face.backend.batch.v1";
		function _num(v, d, min, max) {
			let n = parseFloat(String(v));
			if (!isFinite(n)) n = d;
			if (min != null) n = Math.max(min, n);
			if (max != null) n = Math.min(max, n);
			return n;
		}
		function readSingleFaceKnobs() {
			return {
				backend: (faceBackendSelect && faceBackendSelect.value) || "auto",
				interval: _num(faceIntervalInput?.value, 1.0, 0.01, 999),
				scale_factor: _num(faceScaleFactorInput?.value, 1.2, 1.01, 10),
				min_neighbors: Math.max(1, parseInt(faceMinNeighborsInput?.value || "7", 10) || 7),
				min_size_frac: _num(faceMinSizeFracInput?.value, 0.10, 0.01, 0.9),
				sim_thresh: _num(faceSimThreshInput?.value, 0.90, 0, 1),
			};
		}
		function readBatchFaceKnobs() {
			return {
				backend: (faceBatchBackendSelect && faceBatchBackendSelect.value) || "auto",
				interval: _num(faceBatchIntervalInput?.value, 1.0, 0.01, 999),
				scale_factor: _num(faceBatchScaleFactorInput?.value, 1.2, 1.01, 10),
				min_neighbors: Math.max(1, parseInt(faceBatchMinNeighborsInput?.value || "7", 10) || 7),
				min_size_frac: _num(faceBatchMinSizeFracInput?.value, 0.10, 0.01, 0.9),
				sim_thresh: _num(faceBatchSimThreshInput?.value, 0.90, 0, 1),
			};
		}
		function saveSingleFaceKnobs() { try { localStorage.setItem(FACE_SINGLE_KEY, JSON.stringify(readSingleFaceKnobs())); } catch (_) {} }
		function saveBatchFaceKnobs() { try { localStorage.setItem(FACE_BATCH_KEY, JSON.stringify(readBatchFaceKnobs())); } catch (_) {} }
		function restoreFaceKnobs() {
			try { 
				const beS = localStorage.getItem(FACE_BACKEND_SINGLE_KEY);
				if (beS && faceBackendSelect) faceBackendSelect.value = beS;
				const sraw = localStorage.getItem(FACE_SINGLE_KEY);
				if (sraw) {
					const s = JSON.parse(sraw);
					if (faceIntervalInput && s.interval != null) faceIntervalInput.value = String(s.interval);
					if (faceScaleFactorInput && s.scale_factor != null) faceScaleFactorInput.value = String(s.scale_factor);
					if (faceMinNeighborsInput && s.min_neighbors != null) faceMinNeighborsInput.value = String(s.min_neighbors);
					if (faceMinSizeFracInput && s.min_size_frac != null) faceMinSizeFracInput.value = String(s.min_size_frac);
					if (faceSimThreshInput && s.sim_thresh != null) faceSimThreshInput.value = String(s.sim_thresh);
				}
			}
			catch (_) {}
			try { 
				const beB = localStorage.getItem(FACE_BACKEND_BATCH_KEY);
				if (beB && faceBatchBackendSelect) faceBatchBackendSelect.value = beB;
				const braw = localStorage.getItem(FACE_BATCH_KEY);
				if (braw) {
					const b = JSON.parse(braw);
					if (faceBatchIntervalInput && b.interval != null) faceBatchIntervalInput.value = String(b.interval);
					if (faceBatchScaleFactorInput && b.scale_factor != null) faceBatchScaleFactorInput.value = String(b.scale_factor);
					if (faceBatchMinNeighborsInput && b.min_neighbors != null) faceBatchMinNeighborsInput.value = String(b.min_neighbors);
					if (faceBatchMinSizeFracInput && b.min_size_frac != null) faceBatchMinSizeFracInput.value = String(b.min_size_frac);
					if (faceBatchSimThreshInput && b.sim_thresh != null) faceBatchSimThreshInput.value = String(b.sim_thresh);
				}
			}
			catch (_) {}
		}
		// Persist on change and restore once
		[faceIntervalInput, faceScaleFactorInput, faceMinNeighborsInput, faceMinSizeFracInput, faceSimThreshInput].forEach(el => { if (el) el.addEventListener('change', saveSingleFaceKnobs); });
		[faceBatchIntervalInput, faceBatchScaleFactorInput, faceBatchMinNeighborsInput, faceBatchMinSizeFracInput, faceBatchSimThreshInput].forEach(el => { if (el) el.addEventListener('change', saveBatchFaceKnobs); });
		if (faceBackendSelect) faceBackendSelect.addEventListener('change', () => { try { localStorage.setItem(FACE_BACKEND_SINGLE_KEY, faceBackendSelect.value); } catch(_){} });
		if (faceBatchBackendSelect) faceBatchBackendSelect.addEventListener('change', () => { try { localStorage.setItem(FACE_BACKEND_BATCH_KEY, faceBatchBackendSelect.value); } catch(_){} });
		restoreFaceKnobs();
		
		function setImageStatus(text) {
			if (imageStatus) imageStatus.textContent = text || "";
		}
		
		function getFaceNameKey(filePath, embedding) {
			// Persist a name per (file, embedding hash) in localStorage
			const sig = Array.isArray(embedding) && embedding.length ? embedding.map(x => Number(x).toFixed(3)).join(",") : "stub";
			return `facelab:name:${filePath}:${sig}`;
		}
		
		function getFaceName(filePath, embedding) {
			const key = getFaceNameKey(filePath, embedding);
			return localStorage.getItem(key) || "";
		}
		
		function setFaceName(filePath, embedding, name) {
			const key = getFaceNameKey(filePath, embedding);
			if (name) localStorage.setItem(key, name); else localStorage.removeItem(key);
		}
		
		async function loadFaces() {
			if (!selectedFile || !selectedFile.path) {
				if (facesList) {
					facesList.textContent = "";
					const em = document.createElement("em");
					em.textContent = "No file selected.";
					facesList.appendChild(em);
				}
				setImageStatus("");
				return;
			}
			const path = selectedFile.path;
			setImageStatus("Loading faces…");
			try { 
				const r = await fetch(`/api/faces/json?path=${encodeURIComponent(path)}`);
				if (!r.ok) {
					facesList.textContent = "";
					const em = document.createElement("em");
					em.textContent = "No faces found. Click \"Compute faces\".";
					facesList.appendChild(em);
					setImageStatus("");
					return;
				}
				const data = await r.json();
				const faces = (data && data.data && Array.isArray(data.data.faces)) ? data.data.faces : [];
				if (!faces.length) {
					facesList.textContent = "";
					const em = document.createElement("em");
					em.textContent = "No faces in this file.";
					facesList.appendChild(em);
					setImageStatus("");
					return;
				}
				facesList.textContent = "";
				for (const f of faces) {
					const box = f.box || [0,0,0,0];
					const t = typeof f.first_time === 'number' ? f.first_time : (f.time || 0);
					const url = `/api/frame/boxed?path=${encodeURIComponent(path)}&t=${encodeURIComponent(t)}&x=${box[0]}&y=${box[1]}&w=${box[2]}&h=${box[3]}&scale=256&thickness=3`;
					const nameVal = getFaceName(path, f.embedding);
					const tile = document.createElement('div');
					tile.className = 'tile p-8';
					tile.style.width = '220px';
					const col = document.createElement('div');
					col.className = 'col gap-6';
					const img = document.createElement('img');
					img.src = url;
					img.alt = 'face';
					img.style.width = '128px';
					img.style.height = 'auto';
					img.style.borderRadius = '6px';
					const input = document.createElement('input');
					input.type = 'text';
					input.className = 'w-full';
					input.placeholder = 'Name';
					input.value = nameVal;
					input.addEventListener('change', () => setFaceName(path, f.embedding, input.value.trim()));
					const meta = document.createElement('div');
					meta.className = 'small muted';
					const start = Number(f.first_time ?? f.time ?? 0).toFixed(1);
					const end = Number(f.last_time ?? f.time ?? 0).toFixed(1);
					meta.textContent = `count: ${f.count ?? 1} • span: ${start}–${end}s`;
					col.appendChild(img);
					col.appendChild(input);
					col.appendChild(meta);
					tile.appendChild(col);
					facesList.appendChild(tile);
				}
				setImageStatus("");
			}
			catch (_) {
				if (facesList) {
					facesList.textContent = "";
					const em = document.createElement('em');
					em.textContent = 'Failed to load faces.';
					facesList.appendChild(em);
				}
				setImageStatus("");
			}
		}
		
		if (refreshFacesBtn) refreshFacesBtn.onclick = loadFaces;
		if (createFacesBtn) createFacesBtn.onclick = async () => {
			if (!selectedFile || !selectedFile.path) return;
			createFacesBtn.disabled = true;
			setImageStatus("Computing faces…");
			try { 
				const k = readSingleFaceKnobs();
				const qs = new URLSearchParams({
					"path": selectedFile.path,
					"backend": String(k.backend || 'auto'),
					"interval": String(k.interval),
					"scale_factor": String(k.scale_factor),
					"min_neighbors": String(k.min_neighbors),
					"min_size_frac": String(k.min_size_frac),
					"sim_thresh": String(k.sim_thresh),
					"background": "true",
				});
				const r = await fetch(`/api/faces/create?${qs.toString()}`, {method: 'POST' });
				if (r.ok) {
					let jobId = null;
					try { 
						const body = await r.json();
						const data = body.data || body;
						jobId = data.job || null;
					} catch (_) { jobId = null; }
					// If we got a job id, poll for progress and reflect in the Image tab
					if (jobId) {
						try { startJobsSSE(); } catch (_) { }
						await pollJobUntilDone(jobId, (info) => {
							if (!info) return;
							const t = Math.max(0, Number(info.total) || 0);
							const p = Math.max(0, Number(info.processed) || 0);
							const pct = t ? Math.floor((p / t) * 100) : 0;
							setImageStatus(t ? `Computing faces… ${p}/${t} (${pct}%)` : `Computing faces… ${p}`);
						});
					}
					else {
						// Fallback: poll for faces artifact presence briefly
						let tries = 0;
						const maxTries = 30; // ~15s
						while (tries++ < maxTries) {
							try { 
								const h = await fetch(`/api/faces/json?path=${encodeURIComponent(selectedFile.path)}`);
								if (h.ok) break;
							} catch (_) {}
							await new Promise(res => setTimeout(res, 500));
						}
					}
					await loadFaces();
					setTimeout(() => setImageStatus(""), 800);
				}
				else {
					setImageStatus("Face compute failed");
				}
			}
			catch (_) { setImageStatus("Face compute failed"); }
			finally { createFacesBtn.disabled = false; }
		};
		
		// --- STATS TAB LOGIC ---
		// --- SIMILAR TAB LOGIC ---
		async function loadSimilar() {
			const statusEl = document.getElementById('similarStatus');
			const grid = document.getElementById('similarResults');
			if (!statusEl || !grid) return;
			// Determine directory from current Grid cwd or root input
			const dir = typeof cwd === 'string' && cwd.length > 0 ? cwd : (rootInput?.value?.trim() || '.');
			const thresh = parseFloat(document.getElementById('similarThresh')?.value || '0.90');
			const limitVal = parseInt(document.getElementById('similarLimit')?.value || '50', 10);
			const recursive = !!document.getElementById('similarRecursive')?.checked;
			const qs = new URLSearchParams();
			qs.set('directory', dir);
			qs.set('phash_threshold', isFinite(thresh) ? String(thresh) : '0.9');
			if (recursive) qs.set('recursive', 'true'); else qs.set('recursive', 'false');
			// page/page_size supported; keep using page_size via limit input
			if (isFinite(limitVal) && limitVal > 0) qs.set('page_size', String(limitVal));
			statusEl.textContent = 'Loading…';
			statusEl.style.color = '#666';
			grid.innerHTML = '';
			try { 
				const res = await fetch(`/api/duplicates/list?${qs.toString()}`);
				if (!res.ok) { statusEl.textContent = 'Failed to load'; statusEl.style.color = 'red'; return; }
				const j = await res.json();
				const payload = j && j.status === 'success' ? (j.data || {}) : (j || {});
				const pairs = payload.pairs || [];
				if (!pairs.length) {
					statusEl.textContent = 'No similar pairs found at this threshold.';
					statusEl.style.color = '#666';
					grid.innerHTML = '';
					return;
				}
				const total = (payload.total_pairs ?? pairs.length);
				statusEl.textContent = `${total} pairs ≥ ${(thresh*100).toFixed(0)}%`;
				statusEl.style.color = '#333';
				for (const p of pairs) {
					const tile = document.createElement('div');
					tile.className = 'tile p-8';
					tile.style.minWidth = '360px';
					tile.style.display = 'flex';
					tile.style.flexDirection = 'column';
					tile.style.gap = '8px';
					const head = document.createElement('div');
					head.className = 'row space-between items-center';
					const sim = document.createElement('strong');
					sim.textContent = `${Math.round((p.similarity || 0) * 100)}% similar`;
					head.appendChild(sim);
					const actions = document.createElement('div');
					actions.className = 'row gap-6';
					const mkBtn = (label, path) => {
						const b = document.createElement('button');
						b.className = 'btn btn-secondary';
						b.textContent = label;
						b.onclick = () => {
							selectedFile = { path, name: path.split('/').pop() };
							showTab('Player');
							play(selectedFile);
						};
						return b;
					};
					actions.appendChild(mkBtn('Play A', p.a));
					actions.appendChild(mkBtn('Play B', p.b));
					head.appendChild(actions);
					tile.appendChild(head);
					const row = document.createElement('div');
					row.className = 'row gap-12 wrap';
					const mkCard = (label, path) => {
						const card = document.createElement('div');
						card.className = 'col gap-6';
						card.style.width = '240px';
						const cap = document.createElement('div');
						cap.className = 'small muted';
						cap.textContent = label;
						const img = document.createElement('img');
						img.alt = 'cover';
						img.style.width = '220px';
						img.style.height = 'auto';
						img.style.borderRadius = '6px';
						// Try to show cover; fallback text if missing
						const url = `/api/cover/get?path=${encodeURIComponent(path)}&t=${Date.now()}`;
						fetch(url, { method: 'GET' }).then(r => r.ok ? r.blob() : null).then(blob => {
							if (blob) { img.src = URL.createObjectURL(blob); }
							else { img.replaceWith(Object.assign(document.createElement('div'), {textContent: 'No cover', className: 'placeholder', style: 'width:220px;height:124px;'})); }
						}).catch(() => {
							img.replaceWith(Object.assign(document.createElement('div'), {textContent: 'No cover', className: 'placeholder', style: 'width:220px;height:124px;'}));
						});
						const pathEl = document.createElement('div');
						pathEl.className = 'small code';
						pathEl.textContent = path;
						card.appendChild(cap);
						card.appendChild(img);
						card.appendChild(pathEl);
						return card;
					};
					row.appendChild(mkCard('A', p.a));
					row.appendChild(mkCard('B', p.b));
					tile.appendChild(row);
					grid.appendChild(tile);
				}
			}
			catch (_) {
				statusEl.textContent = 'Error loading';
				statusEl.style.color = 'red';
			}
		}
		const refreshBtn = document.getElementById('similarRefreshBtn');
		if (refreshBtn) refreshBtn.onclick = () => loadSimilar();
		function humanBytes(n) {
			if (!n || n <= 0) return "0 B";
			const units = ["B", "KiB", "MiB", "GiB", "TiB"];
			let i = 0;
			let v = n;
			while (v >= 1024 && i< units.length - 1) {
				v /= 1024;
				i++;
			}
			return `${v.toFixed(1)} ${units[i]}`;
		}
		function humanDuration(totalSeconds) {
			if (!totalSeconds && totalSeconds !== 0) return "";
			const s = Math.floor(totalSeconds);
			const weeks = Math.floor(s / (7 * 24 * 3600));
			const days = Math.floor((s % (7 * 24 * 3600)) / (24 * 3600));
			const hours = Math.floor((s % (24 * 3600)) / 3600);
			const minutes = Math.floor((s % 3600) / 60);
			const sec = s % 60;
			const parts = [];
			if (weeks) parts.push(`${weeks}W`);
			if (days) parts.push(`${days}D`);
			if (hours) parts.push(`${hours}h`);
			if (minutes) parts.push(`${minutes}m`);
			if (sec || parts.length === 0) parts.push(`${sec}s`);
			return parts.join(" ");
		}
		async function loadStats() {
			try { 
				const res = await fetch("/api/stats", {method: "GET" });
				if (!res.ok) return;
				const body = await res.json();
				const s = body.data || body;
				const scenes = s.total_files || 0;
				const size = humanBytes(s.total_size_bytes || 0);
				const dur = humanDuration(s.total_duration_seconds || 0);
				const covers = s.covers || 0;
				const hovers = s.hovers || 0;
				const subs = s.subtitles || 0;
				const meta = s.metadata || 0;
				const note = [];
				if (s.duration_files_count != null && scenes) {
					note.push(
					
					// --- Setup tab wiring ---
					function loadSetup() {
						const perfEl = document.getElementById('setupPerformers');
						const tagsEl = document.getElementById('setupTags');
						const saveBtn = document.getElementById('setupSaveBtn');
						const runBtn = document.getElementById('setupRunBtn');
						const statusEl = document.getElementById('setupStatus');
						if (!perfEl || !tagsEl || !saveBtn || !runBtn || !statusEl) return;
						try { 
							perfEl.value = (localStorage.getItem('setup.performers') || '').replace(/\r\n/g, '\n');
							tagsEl.value = (localStorage.getItem('setup.tags') || '').replace(/\r\n/g, '\n');
						}
						catch(_) {}
						saveBtn.onclick = () => {
							try { 
								localStorage.setItem('setup.performers', perfEl.value || '');
								localStorage.setItem('setup.tags', tagsEl.value || '');
								statusEl.textContent = 'Saved locally';
								statusEl.style.color = 'green';
							}
							catch(_) {
								statusEl.textContent = 'Failed to save';
								statusEl.style.color = 'red';
							}
						};
						runBtn.onclick = async () => {
							const perfs = (perfEl.value || '').split(/\n+/).map(s => s.trim()).filter(Boolean);
							const tags = (tagsEl.value || '').split(/\n+/).map(s => s.trim()).filter(Boolean);
							statusEl.textContent = 'Starting…'; 
							statusEl.style.color = '#666';
							try { 
								const body = { path: '', recursive: true, performers: perfs, tags };
								const res = await fetch('/api/autotag/scan', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(body)});
								if (!res.ok) { statusEl.textContent = 'Failed to start'; statusEl.style.color = 'red'; return; }
								const j = await res.json();
								const jid = (j.data && j.data.job) || j.job || '';
								if (!jid) { statusEl.textContent = 'No job id'; statusEl.style.color = 'red'; return; }
								statusEl.textContent = `Running (job ${jid})…`;
								// lightweight poll for completion
								const deadline = Date.now() + 60_000;
								let done = false;
								while (!done && Date.now() < deadline) {
									await new Promise(r => setTimeout(r, 750));
									try { 
										const jr = await fetch('/api/jobs?state=recent&limit=50');
										if (jr.ok) {
											const jb = await jr.json();
											const jobs = (jb.data && jb.data.jobs) || jb.jobs || [];
											const me = jobs.find(x => x.id === jid);
											if (me && (me.state === 'done' || me.state === 'failed')) {
												done = true;
												const r = me.result || {};
												statusEl.textContent = me.state === 'done' ? `Done. Updated ${r.updated_files || 0} (matched ${r.matched_files || 0})` : 'Failed';
												statusEl.style.color = me.state === 'done' ? 'green' : 'red';
											}
										}
									} catch(_) {}
								}
								if (!done) { statusEl.textContent = 'Started (check Tasks for progress)…'; statusEl.style.color = '#666'; }
							} catch(_) { statusEl.textContent = 'Error'; statusEl.style.color = 'red'; }
						};
					}
					`${s.duration_files_count}/${scenes} files have duration`,
					);
				}
				document.getElementById("statScenesSize").textContent = size;
				document.getElementById("statScenes").textContent = scenes;
				document.getElementById("statScenesDuration").textContent = dur;
				document.getElementById("statCovers").textContent = covers;
				document.getElementById("statHovers").textContent = hovers;
				document.getElementById("statSubs").textContent = subs;
				document.getElementById("statMeta").textContent = meta;
				const noteEl = document.getElementById("statsNote");
				if (noteEl) noteEl.textContent = note.join(" • ");
			}
			catch (_) { }
		}
		
		// SETTINGS TAB
		async function loadSettings() {
			try { 
				const [h, c] = await Promise.all([
				fetch("/health")
				.then((r) => r.json())
				.catch(() => ({})),
				fetch("/config")
				.then((r) => r.json())
				.catch(() => ({})),
				]);
				const hi = document.getElementById("healthInfo");
				const ci = document.getElementById("configInfo");
				if (hi) hi.textContent = JSON.stringify(h, null, 2);
				if (ci) ci.textContent = JSON.stringify(c, null, 2);
			}
			catch (_) { }
		}
		// Keyboard controls for video player
		document.addEventListener("keydown", function (e) {
			if (!videoEl || videoEl.classList.contains("hidden")) {
				return;
			}
			const ae = document.activeElement;
			const tag = (ae && ae.tagName) || "";
			if (ae && (tag === "INPUT" || tag === "TEXTAREA" || ae.isContentEditable)) return;
			if (e.code === "ArrowLeft") {
				videoEl.currentTime = Math.max(0, videoEl.currentTime - 10);
				e.preventDefault();
			}
			else if (e.code === "ArrowRight") {
				videoEl.currentTime = Math.min( videoEl.duration || 0, videoEl.currentTime + 10 );
				e.preventDefault();
			}
			else if (e.code === "Space") {
				if (videoEl.paused) {
					videoEl.play();
				}
				else {
					videoEl.pause();
				}
				e.preventDefault();
			}
			else if ((e.key || '').toLowerCase() === 'm') {
				// Add persistent marker at current time
				try { 
					if (selectedFile && selectedFile.path) {
						const t = Math.max(0, Math.min(videoEl.duration || 0, videoEl.currentTime || 0));
						fetch(`/api/marker?path=${encodeURIComponent(selectedFile.path)}&time=${encodeURIComponent(t)}`, { method: 'POST' })
						.then(() => { try { renderOverlaysForFile(selectedFile); } catch (_) {} });
					}
				} catch (_) {}
			}
		});
		// Custom controls behavior
		const btnPlayPause = document.getElementById("btnPlayPause");
		const btnCC = document.getElementById("btnCC");
		const btnFS = document.getElementById("btnFS");
		const controlsProgress = document.getElementById("controlsProgress");
		const controlsProgressFill = document.getElementById("controlsProgressFill");
		const timeLabel = document.getElementById("timeLabel");
		function fmtTime(t) {
			if (!isFinite(t) || t< 0) return "0:00";
			const s = Math.floor(t % 60)
			.toString()
			.padStart(2, "0");
			const m = Math.floor((t / 60) % 60);
			const h = Math.floor(t / 3600);
			return h ? `${h}:${m.toString().padStart(2, "0")}:${s}` : `${m}:${s}`;
		}
		function updateControls() {
			if (!videoEl) return;
			const d = videoEl.duration || 0;
			const c = videoEl.currentTime || 0;
			if (timeLabel) timeLabel.textContent = `${fmtTime(c)} / ${fmtTime(d)}`;
			if (controlsProgressFill) {
				const pct = d ? Math.max(0, Math.min(1, c / d)) : 0;
				controlsProgressFill.style.width = `${pct * 100}%`;
			}
			if (btnPlayPause)
			btnPlayPause.textContent = videoEl.paused ? "▶︎" : "❚❚";
		}
		if (btnPlayPause)
		btnPlayPause.onclick = () => {
			if (videoEl.paused) videoEl.play();
			else videoEl.pause();
		};
		// Fullscreen toggle
		function toggleFullscreen() {
			const el = playerEl; // include overlays
			const d = document;
			if (!d.fullscreenElement && !d.webkitFullscreenElement) {
				if (el.requestFullscreen) el.requestFullscreen();
				else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
			}
			else {
				if (d.exitFullscreen) d.exitFullscreen();
				else if (d.webkitExitFullscreen) d.webkitExitFullscreen();
			}
		}
		if (btnFS) btnFS.onclick = toggleFullscreen;
		if (videoEl) {
			videoEl.addEventListener('dblclick', toggleFullscreen);
		}
		if (btnCC)
		btnCC.onclick = () => {
			// Prefer our custom subtitles track
			const tt = videoEl._subsTrack || (videoEl.textTracks && Array.from(videoEl.textTracks).find(t => t.kind === 'subtitles'));
			if (!tt) return;
			const next = tt.mode === 'showing' ? 'disabled' : 'showing';
			try { tt.mode = next; } catch (_) {}
			// Disable others to avoid duplicates
			try { Array.from(videoEl.textTracks || []).forEach(t => { if (t !== tt) t.mode = 'disabled'; }); } catch (_) {}
		};
		if (controlsProgress)
		controlsProgress.addEventListener("click", (e) => {
			const r = controlsProgress.getBoundingClientRect();
			const pct = Math.max(0, Math.min(1, (e.clientX - r.left) / r.width));
			if (isFinite(videoEl.duration))
			videoEl.currentTime = pct * videoEl.duration;
		});
		// Click video to toggle play/pause
		if (videoEl)
		videoEl.addEventListener("click", () => {
			if (videoEl.paused) videoEl.play();
			else videoEl.pause();
		});
		// Space toggles play/pause when focused on document
		document.addEventListener("keydown", (e) => {
			// Ignore when user is typing into inputs/textareas or editable fields
			const ae = document.activeElement;
			const tag = (ae && ae.tagName) || "";
			const typing = !!(ae && (tag === "INPUT" || tag === "TEXTAREA" || ae.isContentEditable));
			if (typing) return;
			// Only handle when player is visible
			if (!videoEl || videoEl.classList.contains("hidden")) return;
			if (e.code === "Space" && !e.repeat) {
				e.preventDefault();
				if (videoEl.paused) videoEl.play();
				else videoEl.pause();
			}
			if ((e.key || '').toLowerCase() === 'f') {
				e.preventDefault();
				toggleFullscreen();
			}
		});
		if (videoEl) {
			videoEl.addEventListener("timeupdate", updateControls);
			videoEl.addEventListener("loadedmetadata", updateControls);
			videoEl.addEventListener("play", updateControls);
			videoEl.addEventListener("pause", updateControls);
		}
		// Keep progress bar responsive with RAF in case timeupdate is throttled
		let _rafId;
		function tickControls() {
			updateControls();
			_rafId = requestAnimationFrame(tickControls);
		}
		if (document.visibilityState !== "hidden") {
			_rafId = requestAnimationFrame(tickControls);
		}
		document.addEventListener("visibilitychange", () => {
			if (document.visibilityState === "hidden") {
				if (_rafId) cancelAnimationFrame(_rafId);
				_rafId = null;
			}
			else {
				if (!_rafId) _rafId = requestAnimationFrame(tickControls);
			}
		});
		function showFileMenu(x, y) {
			const menu = document.getElementById("fileMenu");
			menu.classList.remove("hidden");
			menu.style.left = x + "px";
			menu.style.top = y + "px";
		}
		
		function hideFileMenu() {
			const menu = document.getElementById("fileMenu");
			menu.classList.add("hidden");
			selectedFile = null;
		}
		
		document.getElementById("closeMenuBtn").onclick = hideFileMenu;
		document.getElementById("coverBtn").onclick = async () => {
			if (!selectedFile) {
				return;
			}
			const ok = await generateCover(selectedFile);
			if (ok) {
				const cacheBust = `?t=${Date.now()}`;
				const imgs = document.querySelectorAll(`.tile img.thumb`);
				imgs.forEach((img) => {
					// Replace all thumbs for selected file by matching their alt/title if we have it; fallback: reload visible tiles later
					if (
					selectedFile &&
					img.closest(".tile")?.textContent?.includes(selectedFile.name)
					) {
						img.src =
						(selectedFile.cover || img.src).split("?")[0] + cacheBust;
					}
				});
			}
			hideFileMenu();
		};
		const dirsEl = document.getElementById("dirs");
		const filesEl = document.getElementById("files");
		const crumbsEl = document.getElementById("crumbs");
		const infoPanel = document.getElementById("infoPanel");
		const statusEl = document.getElementById("status");
		
		async function renderTagEditor(file) {
			if (!infoPanel) return;
			const old = document.getElementById("tagEditorSection");
			if (old) old.remove();
			const section = document.createElement("div");
			section.id = "tagEditorSection";
			section.className = "mt-8";
			section.innerHTML = `
					<div class="infoRow"><span class="infoLabel">Tags</span><div id="tagsInput" class="chips"></div></div>
					<div class="infoRow"><span class="infoLabel">Performers</span><div id="performersInput" class="chips"></div></div>
					<div class="infoRow items-start"><span class="infoLabel" style="padding-top:6px;">Description</span>
						<textarea id="descInput" rows="4" style="flex:1; width:100%;"></textarea>
					</div>
					<datalist id="tagsList"></datalist>
					<datalist id="performersList"></datalist>
					<div class="infoRow"><span class="infoLabel">Rating</span><div id="ratingContainer"></div></div>
					<div id="saveTagsFeedback" class="small mt-8"></div>`;
			infoPanel.appendChild(section);
			const tagsListEl = section.querySelector('#tagsList');
			const perfListEl = section.querySelector('#performersList');
			const descEl = section.querySelector('#descInput');
			const saveFeedback = section.querySelector('#saveTagsFeedback');
			const baseDir = file.path.includes('/') ? file.path.substring(0, file.path.lastIndexOf('/')) : '';

			// Minimal chips input factory
			function makeChips(container, listEl) {
				const input = document.createElement('input');
				if (listEl && listEl.id) input.setAttribute('list', listEl.id);
				container.appendChild(input);
				const values = [];
				let onChange = null;
				// UX niceties
				input.placeholder = container.id === 'tagsInput' ? 'Add tag…' : (container.id === 'performersInput' ? 'Add performer…' : 'Add…');
				container.addEventListener('click', () => input.focus());
				function notify() { if (typeof onChange === 'function') onChange(values.slice()); }
				function render() {
					// remove all chips except input
					[...container.querySelectorAll('.chip')].forEach(c => c.remove());
					values.forEach(v => {
						const chip = document.createElement('span');
						chip.className = 'chip';
						chip.textContent = v;
						const btn = document.createElement('button');
						btn.type = 'button';
						btn.title = 'Remove';
						btn.textContent = '×';
						btn.addEventListener('click', () => { const i = values.indexOf(v); if (i >= 0) { values.splice(i, 1); render(); notify(); } });
						chip.appendChild(btn);
						container.insertBefore(chip, input);
					});
				}
				function add(val) {
					const s = String(val || '').trim();
					if (!s) return;
					if (!values.includes(s)) { values.push(s); render(); notify(); }
					input.value = '';
				}
				input.addEventListener('keydown', (e) => {
					if (e.key === 'Enter' || e.key === ',') {
						e.preventDefault();
						add(input.value);
					}
					else if (e.key === ';') {
						e.preventDefault();
						add(input.value);
					}
					else if (e.key === 'Backspace' && !input.value) {
						const v = values.pop();
						if (v !== undefined) { render(); notify(); }
					}
				});
				input.addEventListener('blur', () => { if (input.value.trim()) add(input.value); });
				input.addEventListener('paste', (e) => {
					const text = (e.clipboardData || window.clipboardData)?.getData('text');
					if (text && (text.includes(',') || text.includes('\n') || text.includes(';'))) {
						e.preventDefault();
						text.split(/[\n,;]+/).map(s => s.trim()).filter(Boolean).forEach(tok => add(tok));
					}
				});
				return {
					get values() { return values.slice(); },
					add,
					setValues(arr) { values.splice(0, values.length, ...Array.from(new Set((arr||[]).map(x => String(x).trim()).filter(Boolean)))); render(); notify(); },
					onChange(cb) { onChange = cb; },
				};
			}

			const tagsContainer = section.querySelector('#tagsInput');
			const perfContainer = section.querySelector('#performersInput');
			const tagsChips = makeChips(tagsContainer, tagsListEl);
			const perfChips = makeChips(perfContainer, perfListEl);
			// Populate autocomplete lists from summary
			try { 
				const s = await fetch(`/api/tags/summary?path=${encodeURIComponent(baseDir)}`);
				if (s.ok) {
					const js = await s.json();
					const tagNames = Object.keys(js.tags || {});
					const perfNames = Object.keys(js.performers || {});
					tagNames.sort((a,b) => a.localeCompare(b));
					perfNames.sort((a,b) => a.localeCompare(b));
					tagNames.forEach(t => { const o = document.createElement('option'); o.value = t; tagsListEl.appendChild(o); });
					perfNames.forEach(p => { const o = document.createElement('option'); o.value = p; perfListEl.appendChild(o); });
				}
			} catch (_) { /* ignore */ }
			
			let currentRating = 0;
			const ratingEl = section.querySelector('#ratingContainer');
			let _saveTimer;
			async function saveTags() {
				// Show inline, lightweight feedback
				if (saveFeedback) { saveFeedback.textContent = 'Saving…'; saveFeedback.style.color = '#666'; }
				const payload = {
					replace: true,
					add: tagsChips.values,
					performers_add: perfChips.values,
					rating: currentRating,
					description: (descEl?.value || ""),
				};
				try { 
					const resp = await fetch(`/api/videos/${encodeURIComponent(file.name)}/tags?directory=${encodeURIComponent(baseDir)}`, {
						method: 'PATCH',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify(payload),
					});
					if (saveFeedback) {
						saveFeedback.textContent = resp.ok ? 'Saved' : 'Failed to save';
						saveFeedback.style.color = resp.ok ? 'green' : 'red';
					}
				} catch (_) {
					if (saveFeedback) { saveFeedback.textContent = 'Error saving'; saveFeedback.style.color = 'red'; }
				}
			}
			function debouncedSave() {
				clearTimeout(_saveTimer);
				_saveTimer = setTimeout(saveTags, 600);
			}
			function renderStars(r) {
				ratingEl.innerHTML = '';
				for (let i = 1; i <= 5; i++) {
					const s = document.createElement('span');
					s.className = 'star' + (i <= r ? ' selected' : '');
					s.textContent = i <= r ? '★' : '☆';
					s.dataset.val = String(i);
					s.addEventListener('click', () => { currentRating = i; renderStars(currentRating); debouncedSave(); });
					ratingEl.appendChild(s);
				}
			}
			// Load existing tags/performers/rating
			try { 
				const resp = await fetch(`/api/videos/${encodeURIComponent(file.name)}/tags?directory=${encodeURIComponent(baseDir)}`);
				if (resp.ok) {
					const t = await resp.json();
					tagsChips.setValues(t.tags || []);
					perfChips.setValues(t.performers || []);
					if (descEl) descEl.value = t.description || '';
					currentRating = t.rating || 0;
				}
			} catch (_) { /* ignore */ }
			renderStars(currentRating);
			// Autosave on changes (debounced)
			tagsChips.onChange(debouncedSave);
			perfChips.onChange(debouncedSave);
			if (descEl) descEl.addEventListener('input', debouncedSave);
		}
		const rootInput = document.getElementById("rootInput");
		const setRootBtn = document.getElementById("setRootBtn");
		const prevBtn = document.getElementById("prevBtn");
		const nextBtn = document.getElementById("nextBtn");
		const pageInfo = document.getElementById("pageInfo");
		const pageSizeInput = document.getElementById("pageSize");
		// Simple status helper (avoid using window.status)
		const status = (text) => {
			if (statusEl) statusEl.textContent = text || "";
		};
		
		// --- Filters (tags/performers) ---
		window.__filters = window.__filters || { tags: [], performers: [], matchAny: true };
		async function _ensureRegistryLists() {
			try {
				const [tRes, pRes] = await Promise.all([
				fetch('/api/registry/tags'), fetch('/api/registry/performers')
				]);
				if (tRes.ok) {
					const tl = document.getElementById('filterTagsList');
					if (tl) {
						tl.innerHTML = '';
						const j = await tRes.json();
						(j.data?.tags || j.tags || []).forEach(it => {
							const o = document.createElement('option'); o.value = it.name || ''; if (o.value) tl.appendChild(o);
						});
					}
				}
				if (pRes.ok) {
					const pl = document.getElementById('filterPerfsList');
					if (pl) {
						pl.innerHTML = '';
						const j = await pRes.json();
						(j.data?.performers || j.performers || []).forEach(it => {
							const o = document.createElement('option'); o.value = it.name || ''; if (o.value) pl.appendChild(o);
						});
					}
				}
			} catch(_) {}
		}
		function _renderFilterChips() {
			const box = document.getElementById('filterChips'); if (!box) return;
			box.innerHTML = '';
			const addChip = (type, val) => {
				const chip = document.createElement('span'); chip.className = 'chip';
				chip.innerHTML = `${type}: ${val} <span class="x" title="Remove">×</span>`;
				chip.querySelector('.x').onclick = () => {
					const arr = (type === 'tag') ? window.__filters.tags : window.__filters.performers;
					const idx = arr.indexOf(val); if (idx >= 0) arr.splice(idx, 1);
					_renderFilterChips(); load(cwd || '');
				};
				box.appendChild(chip);
			};
			(window.__filters.tags || []).forEach(v => addChip('tag', v));
			(window.__filters.performers || []).forEach(v => addChip('perf', v));
		}
		function _wireFilterInputs() {
			const t = document.getElementById('filterTagInput');
			const p = document.getElementById('filterPerfInput');
			if (t && !t.dataset.wired) {
				t.dataset.wired = '1';
				t.addEventListener('change', () => {
					const v = (t.value || '').trim();
					if (!v) return; if (!window.__filters.tags.includes(v)) window.__filters.tags.push(v);
					t.value = ''; _renderFilterChips(); load(cwd || '');
				});
			}
			if (p && !p.dataset.wired) {
				p.dataset.wired = '1';
				p.addEventListener('change', () => {
					const v = (p.value || '').trim();
					if (!v) return; if (!window.__filters.performers.includes(v)) window.__filters.performers.push(v);
					p.value = ''; _renderFilterChips(); load(cwd || '');
				});
			}
		}
		
		videoEl.classList.add("hidden");
		metaEl.textContent = "";
		
		// Removed duplicate declaration of cwd
		let cwd = "";
		
		let currentPage = 1;
		// Initialize from URL (?page=#)
		currentPage = getPageFromLocation();
		let pageSize =
		parseInt(pageSizeInput ? pageSizeInput.value : 48, 10) || 48;
		let totalPages = 1;
		let totalFiles = 0;
		let loading = false;
		let allFiles = [];
		let selectedFile = null;
		let selectedTile = null;
		const metaCache = new Map();
		let visibleStart = 0,
		visibleEnd = 0;
		
		function human(n) {
			if (n< 1024) {
				return n + " B";
			}
			const u = ["KB", "MB", "GB", "TB"];
			let i = -1;
			do {
				n = n / 1024;
				i++;
			}
			while (n >= 1024 && i< u.length - 1);
			return n.toFixed(1) + " " + u[i];
		}
		
		// Allow double-click on the root input to open a folder picker
		if (rootInput) {
			const hiddenDirPicker = document.getElementById("hiddenDirPicker");
			if (hiddenDirPicker) {
				hiddenDirPicker.addEventListener("change", async (ev) => {
					try { 
						const files = hiddenDirPicker.files;
						if (!files || files.length === 0) return;
						// Best-effort: derive directory from first file path if available
						// On some browsers, we may have a fake path, but in desktop Safari/Chrome it often contains the directory structure
						const f = files[0];
						let dirGuess = (f.webkitRelativePath || f.name || "").split("/")[0] || "";
						// Prefer full path prompt if available; otherwise use guess
						let chosenPath = dirGuess;
						if (!chosenPath) return;
						rootInput.value = chosenPath;
						status("Setting root…");
						const tp = await fetch("/api/testpath?" + new URLSearchParams({path: chosenPath }).toString(), {method: "POST" });
						let okToSet = false;
						if (tp.ok) {
							const tjson = await tp.json();
							const tdata = tjson.data || tjson;
							okToSet = !!(tdata && tdata.exists && tdata.is_dir);
						}
						if (okToSet) {
							const res = await fetch("/api/setroot?" + new URLSearchParams({root: chosenPath }), {method: "POST" });
							if (res.ok) {
								currentPage = 1;
								cwd = "";
								await load("");
							}
						}
						else {
							alert("Could not set root from selection. Please type the full path.");
						}
					}
					catch (_) {/* ignore */ }
				});
			}
			rootInput.addEventListener("dblclick", async (e) => {
				e.preventDefault();
				e.stopPropagation();
				try { 
					// Try modern File System Access API
					if (window.showDirectoryPicker) {
						const dirHandle = await window.showDirectoryPicker();
						// Resolve a path-like string if possible
						// On browsers without local path access (e.g., non-Electron), we can't get absolute path
						// So we fallback to using the name and asking the backend to interpret it relative to current root
						let chosenPath = dirHandle.name || "";
						// Prefer previously typed root as base if present
						if (chosenPath) {
							// Update input and attempt setroot
							rootInput.value = chosenPath;
							status("Setting root…");
							const tp = await fetch("/api/testpath?" + new URLSearchParams({path: chosenPath }).toString(), {method: "POST" });
							let okToSet = false;
							if (tp.ok) {
								const tjson = await tp.json();
								const tdata = tjson.data || tjson;
								okToSet = !!(tdata && tdata.exists && tdata.is_dir);
							}
							if (okToSet) {
								const res = await fetch("/api/setroot?" + new URLSearchParams({root: chosenPath }), {method: "POST" });
								if (res.ok) {
									currentPage = 1;
									cwd = "";
									await load("");
									return;
								}
							}
						}
					}
				}
				catch (_) {/* ignore */ }
				// Fallback: prompt the user for a path
				try { 
					// Try hidden file input directory selection on browsers supporting webkitdirectory
					if (hiddenDirPicker) {
						hiddenDirPicker.click();
						return;
					}
					const val = prompt("Enter absolute path for media root:", rootInput.value || "");
					if (val && val.trim()) {
						const v = val.trim();
						rootInput.value = v;
						status("Setting root…");
						const tp = await fetch("/api/testpath?" + new URLSearchParams({path: v }).toString(), {method: "POST" });
						let okToSet = false;
						if (tp.ok) {
							const tjson = await tp.json();
							const tdata = tjson.data || tjson;
							okToSet = !!(tdata && tdata.exists && tdata.is_dir);
						}
						if (okToSet) {
							const res = await fetch("/api/setroot?" + new URLSearchParams({root: v }), {method: "POST" });
							if (res.ok) {
								currentPage = 1;
								cwd = "";
								await load("");
							}
						}
						else {
							alert("Path does not exist or is not a directory.");
						}
					}
				}
				catch (_) {/* ignore */ }
			});
		}
		
		function esc(s) {
			return String(s == null ? "" : s);
		}
		
		function baseName(name) {
			const i = name.lastIndexOf(".");
			return i >0 ? name.slice(0, i) : name;
		}
		function hhmmss(sec) {
			if (!sec && sec !== 0) {
				return "";
			}
			sec = Math.floor(sec);
			const h = Math.floor(sec / 3600);
			const m = Math.floor((sec % 3600) / 60);
			const s = sec % 60;
			const pad = (n) => String(n).padStart(2, "0");
			return h >0 ? `${h}:${pad(m)}:${pad(s)}` : `${m}:${pad(s)}`;
		}
		
		async function showInfo(file) {
			if (!infoPanel) {
				return;
			}
			selectedFile = file;
			try { if (activeTab === 'Image') {await loadFaces(); } }
			catch (_) { }
			const sizeLine = human(file.size || 0);
			const ext = file.name.split(".").pop().toLowerCase();
			// Build info panel with DOM APIs
			infoPanel.textContent = "";
			const frag = document.createDocumentFragment();
			if (file.cover) {
				const img = document.createElement("img");
				img.id = "infoThumb";
				img.src = `${file.cover}?t=${Date.now()}`;
				img.alt = "Thumbnail";
				img.className = "thumb-img";
				frag.appendChild(img);
			}
			else {
				const div = document.createElement("div");
				div.id = "infoThumb";
				div.className = "placeholder thumb-placeholder";
				div.textContent = "No thumbnail";
				frag.appendChild(div);
			}
			const titleDiv = document.createElement("div");
			titleDiv.className = "infoTitle";
			titleDiv.textContent = esc(file.title || baseName(file.name));
			frag.appendChild(titleDiv);
			function row(label, value, id, withAction) {
				const r = document.createElement("div");
				r.className = "infoRow";
				const lab = document.createElement("span");
				lab.className = "infoLabel";
				lab.textContent = label;
				const val = document.createElement("span");
				val.className = "infoValue";
				if (id) val.id = id;
				val.textContent = value;
				r.appendChild(lab);
				r.appendChild(val);
				if (withAction) {
					const btn = document.createElement('button');
					btn.className = 'btn';
					btn.textContent = '×';
					btn.title = 'Generate';
					btn.style.padding = '0 6px';
					btn.style.lineHeight = '18px';
					btn.style.fontSize = '12px';
					btn.dataset.actionFor = id;
					r.appendChild(btn);
				}
				frag.appendChild(r);
				return val;
			}
			row("Type", ext);
			row("Size", sizeLine);
			row("Duration", "Loading…", "infoDuration");
			row("Resolution", "Loading…", "infoRes");
			row("V Codec", "Loading…", "infoCodec");
			row("V Bitrate", "Loading…", "infoVBitrate");
			row("Bitrate", "Loading…", "infoBitrate");
			row("A Codec", "—", "infoACodec");
			row("A Bitrate", "—", "infoABitrate");
			row("Metadata", "Loading…", "infoMetaFile", true);
			row("Thumbnail", file.cover ? "✅" : "❌", "infoThumbStatus", true);
			row("Hover Preview", file.hoverPreview ? "✅" : "❌", "infoHoverPreview", true);
			row("pHash", file.phash ? "✅" : "❌", "infoPhash", true);
			row("Chapter Markers", file.chapters ? "✅" : "❌", "infoScenes", true);
			row("Scrubbing Thumbnails", file.scrubThumbs ? "✅" : "❌", "infoSprites", true);
			row("Heatmaps", "Loading…", "infoHeatmaps", true);
			row("Subtitles", "Loading…", "infoSubtitles", true);
			row("Face Embeddings", "Loading…", "infoFaces", true);
			const extra = document.createElement("div");
			extra.id = "infoMetaExtra";
			extra.className = "small meta-extra";
			frag.appendChild(extra);
			const actions = document.createElement("div");
			actions.className = "row mt-8 gap-6 wrap";
			const playBtnEl = document.createElement("button");
			playBtnEl.className = "btn";
			playBtnEl.id = "infoPlay";
			playBtnEl.textContent = "Play";
			actions.appendChild(playBtnEl);
			frag.appendChild(actions);
			// First, render the fragment so elements exist in the DOM
			infoPanel.appendChild(frag);
			// Wire Play button
			try {
				playBtnEl.onclick = () => { showTab("Player"); play(file); };
			} catch (_) {}
			// Make status values clickable to generate artifacts
			const setClickable = (id, title, handler) => {
				const el = document.getElementById(id);
				if (!el) return;
				el.classList.add("clickable");
				el.title = title;
				el.onclick = async () => {
					try { el.textContent = "…"; } catch (_) {}
					try { await handler(); } catch (_) {}
					showInfo(file);
				};
				// Also wire the adjacent × button
				try { 
					const btn = el.parentElement?.querySelector('button.btn[data-action-for="' + id + '"]');
					if (btn) {
						btn.onclick = async (ev) => {
							ev.stopPropagation();
							btn.disabled = true;
							try { await handler(); } finally { btn.disabled = false; }
							showInfo(file);
						};
						btn.title = title;
					}
				} catch(_) {}
			};
			setClickable("infoThumbStatus", "Click to (re)generate cover", async () => {
				await fetch(`/api/cover/create?path=${encodeURIComponent(file.path)}`, { method: 'POST' });
			});
			setClickable("infoHoverPreview", "Click to (re)generate hover preview", async () => {
				await fetch(`/api/hover/create?path=${encodeURIComponent(file.path)}`, { method: 'POST' });
			});
			setClickable("infoSprites", "Click to (re)generate sprites (use if scrubbing looks wrong)", async () => {
				await fetch(`/api/sprites/create?path=${encodeURIComponent(file.path)}`, { method: 'POST' });
			});
			setClickable("infoHeatmaps", "Click to (re)generate heatmaps", async () => {
				const qs = new URLSearchParams({ path: file.path });
				try {
					const chk = document.getElementById('heatmapsPngChk');
					if (chk && chk.checked) qs.set('png', 'true');
				} catch(_){}
				await fetch(`/api/heatmaps/create?${qs.toString()}`, { method: 'POST' });
			});
			setClickable("infoSubtitles", "Click to (re)generate subtitles", async () => {
				await fetch(`/api/subtitles/create?path=${encodeURIComponent(file.path)}`, { method: 'POST' });
			});
			setClickable("infoPhash", "Click to (re)generate perceptual hash", async () => {
				await fetch(`/api/phash/create?path=${encodeURIComponent(file.path)}`, { method: 'POST' });
			});
			setClickable("infoFaces", "Click to (re)compute faces", async () => {
				const backend = document.getElementById('faceBackendSelect')?.value || 'auto';
				const qs = new URLSearchParams({ path: file.path, backend });
				await fetch(`/api/faces/create?${qs.toString()}`, { method: 'POST' });
			});
			setClickable("infoMetaFile", "Click to (re)generate metadata", async () => {
				await fetch(`/api/metadata/create?path=${encodeURIComponent(file.path)}`, { method: 'POST' });
			});
			setClickable("infoScenes", "Click to (re)generate chapters", async () => {
				await fetch(`/api/scenes/create?path=${encodeURIComponent(file.path)}`, { method: 'POST' });
			});
			// After wiring actions, asynchronously verify artifact presence and update statuses
			(async function refreshArtifactStatuses(f) {
				const headOk = async (url) => {
					try { const r = await fetch(url, { method: 'HEAD', cache: 'no-store' }); return r.ok; } catch(_) { return false; }
				};
				const getJson = async (url) => {
					try { const r = await fetch(url, { method: 'GET', cache: 'no-store' }); if (!r.ok) return null; return await r.json(); } catch(_) { return null; }
				};
				const setCheck = (id, ok) => { const el = document.getElementById(id); if (el) el.textContent = ok ? '✅' : '❌'; };
				// Thumbnail
				const coverOk = await headOk(`/api/cover/get?path=${encodeURIComponent(f.path)}&t=${Date.now()}`);
				setCheck('infoThumbStatus', coverOk);
				if (coverOk) {
					const img = document.getElementById('infoThumb');
					if (img && img.tagName === 'IMG') { img.src = `/api/cover/get?path=${encodeURIComponent(f.path)}&t=${Date.now()}`; }
				}
				// Hover preview
				const hoverOk = await headOk(`/api/hover/get?path=${encodeURIComponent(f.path)}&t=${Date.now()}`);
				setCheck('infoHoverPreview', hoverOk);
				// Sprites
				const spritesJson = await getJson(`/api/sprites/json?path=${encodeURIComponent(f.path)}&t=${Date.now()}`);
				const spritesOk = !!(spritesJson && (spritesJson.index || spritesJson.data?.index));
				setCheck('infoSprites', spritesOk);
				// Scenes / chapters
				const scenesJson = await getJson(`/api/scenes/get?path=${encodeURIComponent(f.path)}&t=${Date.now()}`);
				const scenesArr = (scenesJson && (scenesJson.data?.markers || scenesJson.markers || scenesJson.data?.scenes)) || [];
				setCheck('infoScenes', Array.isArray(scenesArr) && scenesArr.length > 0);
				// Heatmaps
				let heatOk = await headOk(`/api/heatmaps/png?path=${encodeURIComponent(f.path)}&t=${Date.now()}`);
				if (!heatOk) {
					const hm = await getJson(`/api/heatmaps/json?path=${encodeURIComponent(f.path)}&t=${Date.now()}`);
					heatOk = !!(hm && ((hm.data?.heatmaps?.samples?.length || 0) > 0 || (hm.heatmaps?.samples?.length || 0) > 0 || (hm.samples?.length || 0) > 0));
				}
				setCheck('infoHeatmaps', heatOk);
				// Subtitles
				const subsOk = await headOk(`/api/subtitles/get?path=${encodeURIComponent(f.path)}&t=${Date.now()}`);
				setCheck('infoSubtitles', subsOk);
				// pHash: try a lightweight metadata get and look for a phash-like field
				const meta = await getJson(`/api/metadata/get?path=${encodeURIComponent(f.path)}&view=1&t=${Date.now()}`);
				const metaBody = meta?.data || meta || {};
				const phashOk = !!(metaBody.phash || metaBody.pHash || metaBody.hash || metaBody.artifacts?.phash);
				setCheck('infoPhash', phashOk);
				// Faces
				const faces = await getJson(`/api/faces/json?path=${encodeURIComponent(f.path)}&t=${Date.now()}`);
				const faceArr = (faces && (faces.data?.faces || faces.faces)) || [];
				setCheck('infoFaces', Array.isArray(faceArr) && faceArr.length > 0);
			})(file);
			infoPanel.appendChild(frag);
			renderTagEditor(file);
			try { 
				const res = await fetch(
				`/api/metadata/get?path=${encodeURIComponent(file.path)}`,
				{method: "GET" },
				);
				if (res.ok) {
					const body = await res.json();
					const j = body.data || body;
					document.getElementById("infoMetaFile").textContent = "✅";
					if (j.duration) {
						document.getElementById("infoDuration").textContent = hhmmss(
						j.duration,
						);
					}
					if (j.width && j.height) {
						document.getElementById("infoRes").textContent =
						`${j.width}×${j.height}`;
					}
					if (j.vcodec) {
						document.getElementById("infoCodec").textContent = j.vcodec;
					}
					if (j.vbitrate) {
						document.getElementById("infoVBitrate").textContent = j.vbitrate
						? `${(j.vbitrate / 1e6).toFixed(1)} Mbps`
						: "";
					}
					else {
						document.getElementById("infoVBitrate").textContent = "";
					}
					if (j.bitrate) {
						document.getElementById("infoBitrate").textContent =
						`${(j.bitrate / 1e6).toFixed(1)} Mbps`;
					}
					if (j.acodec) {
						document.getElementById("infoACodec").textContent = j.acodec;
					}
					if (j.abitrate) {
						document.getElementById("infoABitrate").textContent =
						`${(j.abitrate / 1e6).toFixed(1)} Mbps`;
					}
					// Show any extra metadata keys not explicitly displayed
					const known = new Set([
					"duration",
					"width",
					"height",
					"vcodec",
					"vbitrate",
					"bitrate",
					"acodec",
					"abitrate",
					]);
					const extras = Object.keys(j)
					.filter((k) => !known.has(k) && j[k] != null && j[k] !== "")
					.map((k) => `${k}: ${j[k]}`);
					if (extras.length) {
						document.getElementById("infoMetaExtra").textContent =
						extras.join("\n");
					}
				}
				else {
					// TODO @copilot: there must be a dryer was to do this
					document.getElementById("infoDuration").textContent = "";
					document.getElementById("infoRes").textContent = "";
					document.getElementById("infoCodec").textContent = "";
					document.getElementById("infoBitrate").textContent = "";
					document.getElementById("infoVBitrate").textContent = "";
					document.getElementById("infoMetaFile").textContent = "❌";
				}
			}
			catch (_) {
				// TODO @copilot: there must be a dryer was to do this
				document.getElementById("infoDuration").textContent = "";
				document.getElementById("infoRes").textContent = "";
				document.getElementById("infoCodec").textContent = "";
				document.getElementById("infoBitrate").textContent = "";
				document.getElementById("infoVBitrate").textContent = "";
				const mf = document.getElementById("infoMetaFile");
				if (mf) {
					mf.textContent = "❌";
				}
			}
			// Update Heatmaps/Subtitles/Faces indicators dynamically
			(async () => {
				const setFlag = (id, ok) => {
					const el = document.getElementById(id);
					if (el) {
						el.textContent = ok ? "✅" : "❌";
					}
				};
				// Heatmaps: prefer PNG, fallback JSON
				try { 
					const hp = await fetch(`/api/heatmaps/png?path=${encodeURIComponent(file.path)}`, {method: 'HEAD' });
					if (hp.ok) {
						setFlag('infoHeatmaps', true);
					}
					else {
						const hj = await fetch(`/api/heatmaps/json?path=${encodeURIComponent(file.path)}`, {method: 'GET' });
						setFlag('infoHeatmaps', hj.ok);
					}
				} 
				catch (_) {
					setFlag('infoHeatmaps', false);
				}
				// Subtitles: SRT only
				try { 
					const hs = await fetch(`/api/subtitles/get?path=${encodeURIComponent(file.path)}`, { method: 'HEAD' });
					setFlag('infoSubtitles', hs.ok);
				} catch (_) { setFlag('infoSubtitles', false); }
				// Faces
				try { 
					let ok = false;
					try { 
						const hf = await fetch(`/api/faces/get?path=${encodeURIComponent(file.path)}`, {method: 'HEAD' });
						ok = hf.ok;
					}
					catch (_) {/* fallback */ }
					if (!ok) {
						const jf = await fetch(`/api/faces/json?path=${encodeURIComponent(file.path)}`, {method: 'GET' });
						ok = jf.ok;
					}
					setFlag('infoFaces', ok);
				}
				catch (_) {setFlag('infoFaces', false); }
			})();
			const playBtn = document.getElementById("infoPlay");
			if (playBtn) {
				playBtn.onclick = () => play(file);
			}
		}
		
		function selectTile(tile, file) {
			if (selectedTile && selectedTile !== tile) {
				selectedTile.classList.remove("selected");
			}
			selectedTile = tile;
			selectedFile = file;
			// Persist last selected file for sidebar restore on Grid/List
			try {
				const LAST_SELECTED_KEY = 'lastSelected.v1';
				const payload = { path: file.path, name: file.name, title: file.title || '' };
				localStorage.setItem(LAST_SELECTED_KEY, JSON.stringify(payload));
			} catch (_) {}
			tile.classList.add("selected");
			// On demand cover generation and display
			let coverDiv = tile.querySelector(".placeholder");
			if (coverDiv) {
				coverDiv.textContent = "Loading cover…";
				fetch(`/api/cover/get?path=${encodeURIComponent(file.path)}`, {
					method: "GET",
				})
				.then((res) => {
					if (res.ok) return res.blob();
					// If no cover, trigger generation
					return fetch( `/api/cover/create?path=${encodeURIComponent(file.path)}`, {method: "POST" },
					).then((postRes) => {
						if (!postRes.ok) throw new Error("Cover generation failed");
						// After generation, fetch again
						return fetch(
						`/api/cover/get?path=${encodeURIComponent(file.path)}&t=${Date.now()}`,
						{method: "GET" },
						).then((finalRes) => {
							if (!finalRes.ok) throw new Error("Cover fetch failed");
							return finalRes.blob();
						});
					});
				})
				.then((blob) => {
					const url = URL.createObjectURL(blob);
					const img = document.createElement("img");
					img.className = "thumb";
					img.src = url;
					img.onload = () => {
						URL.revokeObjectURL(url);
					};
					coverDiv.replaceWith(img);
				})
				.catch(() => {
					coverDiv.textContent = "No cover";
				});
			}
			showInfo(file);
		}
		
		// --- Subtitles: SRT parsing and track injection ---
		function parseSrtToCues(srtText) {
			// Returns array of { start, end, text }
			const blocks = srtText.replace(/\r/g, '').split(/\n\n+/);
			const cues = [];
			const ts = (t) => {
				// 00:00:12,345 or 0:12:34,567 -> seconds
				const m = t.trim().replace(',', '.').match(/(?:(\d{1,2}):)?(\d{1,2}):(\d{1,2})\.(\d{1,3})/);
				if (!m) return 0;
				const hh = parseInt(m[1] || '0', 10);
				const mm = parseInt(m[2] || '0', 10);
				const ss = parseInt(m[3] || '0', 10);
				const ms = parseInt((m[4] || '0').padEnd(3, '0'), 10);
				return hh * 3600 + mm * 60 + ss + ms / 1000;
			};
			for (const b of blocks) {
				const lines = b.split('\n').filter(Boolean);
				if (!lines.length) continue;
				// skip index line if numeric
				let i = 0;
				if (/^\d+$/.test(lines[0].trim())) i = 1;
				if (!lines[i]) continue;
				const parts = lines[i].split(new RegExp("\\s*-->\\s*"));
				if (parts.length !== 2) continue;
				const start = ts(parts[0]);
				const end = ts(parts[1]);
				const text = lines.slice(i + 1).join('\n');
				if (end > start) cues.push({ start, end, text });
			}
			return cues;
		}
		
		function clearAllTextTracks(video) {
			try { 
				const tracks = video.textTracks || [];
				for (let ti = 0; ti < tracks.length; ti++) {
					const tr = tracks[ti];
					try { tr.mode = 'disabled'; } catch (_) {}
					const cues = tr.cues || [];
					if (cues && cues.length) {
						// HTMLTextTrackCueList is live; remove from the front
						while (tr.cues && tr.cues.length) {
							try { tr.removeCue(tr.cues[0]); } catch (_) { break; }
						}
					}
				}
				// Also clear our reference to any previously created subtitles track
				try { video._subsTrack = null; } catch (_) {}
			} catch (_) {}
		}
		
		let _io;
		function observeLazy(el) {
			if (!_io) {
				_io = new IntersectionObserver(
				(entries) => {
					entries.forEach((e) => {
						if (e.isIntersecting) {
							const v = e.target;
							if (!v.src && v.dataset.src) {
								v.src = v.dataset.src;
							}
							_io.unobserve(v);
						}
					});
				},
				{root: null, rootMargin: "200px", threshold: 0.01 },
				);
			}
			_io.observe(el);
		}
		
		let _ioMeta;
		function observeMeta(el, file) {
			if (!_ioMeta) {
				_ioMeta = new IntersectionObserver(
				(entries) => {
					entries.forEach(async (e) => {
						if (!e.isIntersecting) {
							return;
						}
						const tgt = e.target;
						_ioMeta.unobserve(tgt);
						const key = tgt.dataset.metakey;
						if (!key) {
							return;
						}
						if (metaCache.has(key)) {
							tgt.textContent = metaCache.get(key);
							return;
						}
						if (tgt.dataset.loading) {
							return;
						}
						tgt.dataset.loading = "1";
						try { 
							const res = await fetch(
							`/api/metadata/get?path=${encodeURIComponent(key)}`,
							{method: "GET" },
							);
							if (res.ok) {
								const j = await res.json();
								const bits = [];
								if (j.duration) {
									bits.push(hhmmss(j.duration));
								}
								if (j.width && j.height) {
									bits.push(`${j.width}×${j.height}`);
								}
								if (j.vcodec) {
									bits.push(j.vcodec);
								}
								if (j.bitrate) {
									const mbps = (j.bitrate / 1e6).toFixed(1);
									bits.push(`${mbps} Mbps`);
								}
								const line = bits.join(" • ");
								metaCache.set(key, line);
								tgt.textContent = line;
							}
							else {
								tgt.textContent = "";
							}
						}
						catch (_) {
							tgt.textContent = "";
						}
						finally {
							delete tgt.dataset.loading;
						}
					});
				},
				{
					root: null,
					rootMargin: "200px",
					threshold: 0.01,
				},
				);
			}
			el.dataset.metakey = file.path;
			_ioMeta.observe(el);
		}
		
		async function generateCover(file, overrideOffset) {
			const off = overrideOffset != null ? Number(overrideOffset) : parseFloat(
			document.getElementById("coverOffset")?.value || "0", ) || 0;
			const params = new URLSearchParams({path: file.path, t: String(off) });
			if (off >0) params.set("overwrite", "1");
			const res = await fetch(`/api/cover/create?${params.toString()}`, {
				method: "POST",
			});
			return res.ok;
		}
		
		async function load(path = "", pageOverride) {
			status("Loading…");
			const params = new URLSearchParams();
			if (path) {
				params.set("path", path);
			}
			// Use pageOverride if provided, else currentPage (seeded from URL)
			const pageToRequest = pageOverride !== undefined ? pageOverride : currentPage;
			params.set("page", String(pageToRequest));
			params.set("page_size", String(pageSize));
			// Add search, filter, and sort params
			const searchVal = document.getElementById("searchInput")?.value?.trim();
			if (searchVal) {
				params.set("search", searchVal);
			}
			const sortVal = document.getElementById("sortBy")?.value;
			if (sortVal) {
				params.set("sort", sortVal);
			}
			// Read order from toggle button dataset (default asc)
			const orderBtn = document.getElementById("sortOrderToggle");
			let orderVal = (orderBtn && orderBtn.dataset.order) || "asc";
			if (orderBtn && !orderBtn.dataset.order) { orderBtn.dataset.order = orderVal; }
			params.set("order", orderVal);
			// Add tag/performer filters from chips
			if (window.__filters) {
				const f = window.__filters;
				if (f.tags && f.tags.length) params.set("tags", f.tags.join(","));
				if (f.performers && f.performers.length) params.set("performers", f.performers.join(","));
				if (f.matchAny) params.set("match_any", "1");
			}
			// Fetch with timeout to avoid hanging UI on slow network/back-end
			const controller = new AbortController();
			const timer = setTimeout(() => controller.abort(), 10000);
			let res;
			try { 
				res = await fetch("/api/library?" + params.toString(), {
					method: "GET",
					signal: controller.signal,
				});
			}
			catch (e) {
				clearTimeout(timer);
				status("Error loading");
				return;
			}
			clearTimeout(timer);
			if (!res.ok) {
				status("Error loading");
				return;
			}
			const body = await res.json();
			const data = body.data || body;
			// pagination info available in `data` if needed for debugging
			cwd = data.cwd || "";
			// Always use backend values for pagination
			currentPage = data.page || pageToRequest;
			// Persist current page in URL (omit ?page=1)
			setPageInLocation(currentPage, true);
			totalPages = data.total_pages || 1;
			totalFiles = data.total_files || 0;
			pageSize = data.page_size || pageSize;
			// Render directories list in sidebar
			try { renderDirs(data.dirs || []); } catch (_) {}
			// Only use current page's files for rendering
			renderFiles(data.files || []);
			// Always display backend's total_files and total_pages in paginator
			renderPager(currentPage, totalPages, totalFiles, pageSize);
			// Update allFiles for bulk operations (fetch all files if needed)
			allFiles = data.files || [];
			selectedTile = null;
			selectedFile = null;
			if (infoPanel) {
				// Show a friendly placeholder until a file is selected
				infoPanel.innerHTML = "<div class=\"small\">Select a video from the grid to see details here.</div>";
			}
			// If on Grid/List and nothing is selected, auto-select the first visible tile to populate the sidebar
			try {
				const tabNow = getTabFromLocation() || 'Grid';
				if ((tabNow === 'Grid' || tabNow === 'List') && !document.querySelector('.tile.selected')) {
					const first = document.querySelector('.tile');
					if (first) {
						const p = first.dataset.path || '';
						const name = first.querySelector('.name')?.textContent || (p.split('/').pop() || p);
						first.classList.add('selected');
						const f = { path: p, name, title: '' };
						selectedTile = first; selectedFile = f;
						showInfo(f);
					}
				}
			} catch (_) {}
			status("OK");
		}
		
		// Helper: attempt to select a file's tile by its relative path. Returns true if selected.
		async function selectFileInGridByPath(relPath, fallbackName, fallbackTitle) {
			try {
				const tiles = Array.from(document.querySelectorAll('.tile'));
				const match = tiles.find(t => (t.dataset && t.dataset.path) === relPath);
				if (match) {
					match.classList.add('selected');
					const f = { path: relPath, name: fallbackName || (relPath.split('/').pop() || relPath), title: fallbackTitle || '' };
					selectedTile = match; selectedFile = f;
					showInfo(f);
					try { match.scrollIntoView({ block: 'nearest', inline: 'nearest' }); } catch (_) {}
					return true;
				}
			} catch (_) { }
			return false;
		}
		
		async function ensureHover(file) {
			// Fast path: backend reported hover preview exists
			if (file.hoverPreview) return file.hoverPreview + `&t=${Date.now()}`;
			const base = `/api/hover/get?path=${encodeURIComponent(file.path)}`;
			// Check if available now
			try { 
				const head = await fetch(base + `&t=${Date.now()}`, {
					method: "HEAD",
					cache: "no-store",
				});
				if (head.ok) return base + `&t=${Date.now()}`;
			}
			catch (_) { }
			// Trigger generation (non-blocking if already exists)
			try { 
				await fetch(
				`/api/hover/create?path=${encodeURIComponent(file.path)}`,
				{method: "POST" },
				);
			}
			catch (_) { }
			// Poll briefly for readiness so preview can start on first hover
			const maxTries = 12; // ~1.8s @ 150ms
			for (let i = 0; i< maxTries; i++) {
				try { 
					const head2 = await fetch(base + `&t=${Date.now()}`, {
						method: "HEAD",
						cache: "no-store",
					});
					if (head2.ok) return base + `&t=${Date.now()}`;
				}
				catch (_) { }
				await new Promise((r) => setTimeout(r, 150));
			}
			return null;
		}
		
		// Ensure no tiles are currently showing a hover video
		function stopAllTileHovers(exceptTile = null) {
			try { 
				const tiles = document.querySelectorAll(".tile");
				tiles.forEach((t) => {
					if (exceptTile && t === exceptTile) return;
					if (typeof t.onmouseleave === "function") {
						try { 
							t.onmouseleave();
						}
						catch (_) { }
					}
					else {
						// Best-effort: pause any inline video
						const v = t.querySelector("video.thumb");
						if (v) {
							try { 
								v.pause();
							}
							catch (_) { }
							v.removeAttribute("src");
							try { 
								v.load();
							}
							catch (_) { }
						}
					}
					t._hovering = false;
				});
			}
			catch (_) { }
		}
		
		function renderFiles(files) {
			// Render file tiles with preview (image/video/placeholder)
			if (!Array.isArray(files)) return;
			if (!filesEl) return;
			filesEl.innerHTML = "";
			files.forEach((file) => {
				const tile = document.createElement("div");
				tile.className = "tile";
				// Tag with file path for restoration
				try { tile.dataset.path = file.path || ""; } catch (_) {}
				// Basic structure: name and placeholder (build with DOM APIs)
				const displayTitle = file.title || file.name;
				const placeholder = document.createElement("div");
				placeholder.className = "placeholder";
				placeholder.textContent = "Loading…";
				const nameDiv = document.createElement("div");
				nameDiv.className = "name";
				nameDiv.textContent = esc(displayTitle || file.title || baseName(file.name));
				tile.appendChild(placeholder);
				tile.appendChild(nameDiv);
				tile.onclick = () => {
					selectTile(tile, file);
					showInfo(file);
					// Save last grid tile for back button
					window._lastGridTile = tile;
				};
				tile.ondblclick = () => {
					selectTile(tile, file);
					showTab("Player");
					play(file);
					// Save last grid tile for back button
					window._lastGridTile = tile;
				};
				filesEl.appendChild(tile);
				// Asynchronously load thumbnail
				setTimeout(() => {
					let previewEl;
					if (file.cover) {
						const img = document.createElement("img");
						img.className = "thumb";
						img.src = file.cover;
						img.alt = "cover";
						previewEl = img;
					}
					else if (file.type && file.type.startsWith("video")) {
						const div = document.createElement("div");
						div.className = "placeholder";
						div.textContent = "VIDEO";
						previewEl = div;
					}
					else if (file.type && file.type.startsWith("audio")) {
						const div = document.createElement("div");
						div.className = "placeholder";
						div.textContent = "AUDIO";
						previewEl = div;
					}
					else {
						const div = document.createElement("div");
						div.className = "placeholder";
						div.textContent = "NO PREVIEW";
						previewEl = div;
					}
					const ph = tile.querySelector(".placeholder");
					if (ph && previewEl) {
						ph.replaceWith(previewEl);
					}
					tile.onmouseenter = async () => {
						if (!hoverPreviewsEnabled) return;
						// Stop any other tile's hover video before starting this one
						stopAllTileHovers(tile);
						// Track hover tokens to avoid late insert after mouse leaves
						const token = (tile._hoverToken || 0) + 1;
						tile._hoverToken = token;
						tile._hovering = true;
						const url = await ensureHover(file);
						// If no preview exists, don't swap out the thumbnail
						if (!url) {
							return;
						}
						if (!tile._hovering || tile._hoverToken !== token) return;
						// Double-check no other tiles are showing hover previews
						stopAllTileHovers(tile);
						const current = tile.querySelector(
						".thumb, .placeholder, video.thumb",
						);
						const v = document.createElement("video");
						v.className = "thumb";
						v.src = url;
						v.muted = true;
						v.autoplay = true;
						v.loop = true;
						v.playsInline = true;
						v.style.pointerEvents = "none";
						if (current) current.replaceWith(v);
						try { 
							await v.play();
						}
						catch (_) { }
					};
					tile.onmouseleave = () => {
						tile._hovering = false;
						tile._hoverToken = (tile._hoverToken || 0) + 1;
						if (tile._hoverTimer) {
							clearInterval(tile._hoverTimer);
							tile._hoverTimer = null;
						}
						const current = tile.querySelector("video.thumb");
						if (current) {
							current.pause();
							current.src = "";
							current.load();
							if (file.cover) {
								const img = document.createElement("img");
								img.className = "thumb";
								img.src = file.cover;
								current.replaceWith(img);
							}
							else if (file.type && file.type.startsWith("video")) {
								const div = document.createElement("div");
								div.className = "placeholder";
								div.textContent = "VIDEO";
								current.replaceWith(div);
							}
							else if (file.type && file.type.startsWith("audio")) {
								const div = document.createElement("div");
								div.className = "placeholder";
								div.textContent = "AUDIO";
								current.replaceWith(div);
							}
							else {
								const div = document.createElement("div");
								div.className = "placeholder";
								div.textContent = "NO PREVIEW";
								current.replaceWith(div);
							}
						}
					};
				}, 0);
			});
		}
		
		function renderDirs(dirs) {
			if (!dirsEl) return;
			dirsEl.innerHTML = "";
			// Add an "Up" entry when not at root
			try {
				if (cwd && typeof cwd === 'string' && cwd.length > 0) {
					const up = document.createElement('li');
					up.textContent = "..";
					up.title = "Up one level";
					up.onclick = async () => {
						const parent = cwd.includes('/') ? cwd.substring(0, cwd.lastIndexOf('/')) : "";
						currentPage = 1;
						await load(parent);
					};
					dirsEl.appendChild(up);
				}
			} catch (_) {}
			if (!Array.isArray(dirs)) return;
			dirs.forEach(d => {
				const li = document.createElement('li');
				li.textContent = d.name || d.path || "(folder)";
				li.title = d.path || d.name || "";
				li.onclick = async () => {
					currentPage = 1;
					await load(d.path || "");
				};
				dirsEl.appendChild(li);
			});
		}
		
		if (toggleHoversBtn) {
			toggleHoversBtn.onclick = () => {
				hoverPreviewsEnabled = !hoverPreviewsEnabled;
				toggleHoversBtn.dataset.enabled = hoverPreviewsEnabled ? "1" : "0";
				toggleHoversBtn.textContent = hoverPreviewsEnabled ? "Hovers: On" : "Hovers: Off";
				toggleHoversBtn.classList.toggle("active", hoverPreviewsEnabled);
				if (!hoverPreviewsEnabled) {
					// When disabling, immediately stop any active hover previews
					stopAllTileHovers();
				}
			};
			// Reflect default state on load
			toggleHoversBtn.dataset.enabled = hoverPreviewsEnabled ? "1" : "0";
			toggleHoversBtn.textContent = hoverPreviewsEnabled ? "Hovers: On" : "Hovers: Off";
			toggleHoversBtn.classList.toggle("active", hoverPreviewsEnabled);
		}
		
		function renderPager() {
			if (!pageInfo) {
				return;
			}
			// Use arguments if provided, fallback to globals
			const args = arguments;
			const page = args.length >0 ? args[0] : currentPage;
			const pages = args.length >1 ? args[1] : totalPages;
			const files = args.length >2 ? args[2] : totalFiles;
			const size = args.length >3 ? args[3] : pageSize;
			pageInfo.textContent = `Page ${page} / ${pages} • ${files} files`;
			if (pageSizeInput) {
				pageSizeInput.value = String(size);
			}
			if (prevBtn) {
				prevBtn.disabled = page <= 1;
			}
			if (nextBtn) {
				nextBtn.disabled = page >= pages;
			}
		}
		// Resume position storage
		// TODO @copilot v1 reference
		function resumeKey(path) {return `resume.v1:${path}`; }
		let _lastSavedPosTs = 0;
		function persistPosition() {
			if (!selectedFile || !selectedFile.path) return;
			const now = Date.now();
			if (now - _lastSavedPosTs< 1500) return; // throttle ~1.5s
			_lastSavedPosTs = now;
			try { 
				const pos = Math.floor(videoEl.currentTime || 0);
				if (isFinite(pos) && pos >= 0) {
					localStorage.setItem(resumeKey(selectedFile.path), String(pos));
				}
			}
			catch (_) { }
		}
		if (videoEl) {
			videoEl.addEventListener('timeupdate', persistPosition);
			window.addEventListener('beforeunload', persistPosition);
		}
		
		async function play(file) {
			selectedFile = file;
			const src = `/api/stream?path=${encodeURIComponent(file.path)}`;
			const srtURL = `/api/subtitles/get?path=${encodeURIComponent(file.path)}`;
			videoEl.pause();
			videoEl.innerHTML = "";
			videoEl.classList.remove("hidden");
			playerEl.classList.remove('hidden');
			const source = document.createElement("source");
			if (!source.src) {
				source.src = src;
			}
			source.src = src;
			videoEl.appendChild(source);
			// Ensure sidebar shows details for the playing file and persist selection
			try {
				showInfo(file);
				// TODO @copilot
				const LAST_SELECTED_KEY = 'lastSelected.v1';
				const payload = { path: file.path, name: file.name || (file.path.split('/').pop() || ''), title: file.title || '' };
				localStorage.setItem(LAST_SELECTED_KEY, JSON.stringify(payload));
			} catch(_) {}
			// Helper to force-enable our subtitles track
			const ensureCaptionsVisible = () => {
				try { 
					const tt = videoEl._subsTrack || (videoEl.textTracks && Array.from(videoEl.textTracks).find(t => t.kind === 'subtitles'));
					if (tt) {
						try { tt.mode = 'showing'; } catch (_) {}
						try { Array.from(videoEl.textTracks || []).forEach(t => { if (t !== tt) t.mode = 'disabled'; }); } catch (_) {}
					}
				}
				catch (_) { }
			};
			// Attach subtitles by fetching SRT and injecting cues (SRT-only support)
			try { 
				const head = await fetch(srtURL, { method: "HEAD" });
				if (head.ok) {
					// Clear any residual tracks/cues
					clearAllTextTracks(videoEl);
					// Create a new text track and populate with cues
					const track = videoEl.addTextTrack('subtitles', 'English', 'en');
					track.mode = 'showing';
					const res = await fetch(srtURL, { method: 'GET', cache: 'no-store' });
					if (res.ok) {
						const srt = await res.text();
						const cues = parseSrtToCues(srt);
						const Cue = window.VTTCue || window.TextTrackCue || window.WebKitTextTrackCue;
						for (const c of cues) {
							try { 
								const cue = new Cue(c.start, c.end, c.text);
								// Push captions further up to avoid overlapping controls/nav
								// Use percentage line if supported
								try { cue.snapToLines = false; } catch (_) {}
								try { cue.line = 88; } catch (_) {}
								try { cue.position = 50; } catch (_) {}
								track.addCue(cue);
							} catch (_) { /* ignore broken cue */ }
						}
						ensureCaptionsVisible();
					}
					// Show CC toggle button
					let toggleSubsBtn = document.getElementById("toggleSubsBtn");
					if (!toggleSubsBtn) {
						toggleSubsBtn = document.createElement("button");
						toggleSubsBtn.id = "toggleSubsBtn";
						toggleSubsBtn.className = "btn mt-8";
						toggleSubsBtn.textContent = "Hide Subtitles";
						const setThumbBtn = document.getElementById("setThumbBtn");
						if (setThumbBtn) {
							setThumbBtn.parentNode.insertBefore(
							toggleSubsBtn,
							setThumbBtn.nextSibling,
							);
						}
					}
					toggleSubsBtn.style.display = "";
					toggleSubsBtn.onclick = () => {
						const tt = videoEl._subsTrack || (videoEl.textTracks && Array.from(videoEl.textTracks).find(t => t.kind === 'subtitles'));
						if (!tt) return;
						const next = tt.mode === 'showing' ? 'disabled' : 'showing';
						try { tt.mode = next; } catch (_) {}
						try { Array.from(videoEl.textTracks || []).forEach(t => { if (t !== tt) t.mode = 'disabled'; }); } catch (_) {}
						toggleSubsBtn.textContent = next === 'showing' ? 'Hide Subtitles' : 'Show Subtitles';
					};
				} else {
					const toggleSubsBtn = document.getElementById("toggleSubsBtn");
					if (toggleSubsBtn) toggleSubsBtn.style.display = "none";
				}
			} catch (_) { }
			// Persist last played video for reload restore
			try { 
				// TODO @copilot: reference to versions
				const LAST_VIDEO_KEY = 'lastVideo.v1';
				const name = file.name || (file.path ? file.path.split('/').pop() : '');
				const payload = {path: file.path, name, title: file.title || '' };
				localStorage.setItem(LAST_VIDEO_KEY, JSON.stringify(payload));
			}
			catch (_) { }
			metaEl.textContent = file.title || baseName(file.name);
			videoEl.load();
			// Apply resume position before playback begins
			const applyResume = () => {
				try { 
					const key = resumeKey(file.path);
					const saved = parseFloat(localStorage.getItem(key) || '');
					const dur = videoEl.duration || 0;
					if (isFinite(saved) && saved >0 && dur && saved< Math.max(1, dur - 1)) {
						videoEl.currentTime = saved;
					}
				}
				catch (_) { }
			};
			if (videoEl.readyState >= 1) {
				applyResume();
			}
			else {
				await new Promise((resolve) => {
					const onMeta = () => {videoEl.removeEventListener('loadedmetadata', onMeta); resolve(); };
					videoEl.addEventListener('loadedmetadata', onMeta);
				});
				applyResume();
			}
			// Warm up scrubbing sprites so previews are ready
			try { 
				if (window.ensureSprites) {
					await window.ensureSprites();
				}
			}
			catch (_) { }
			try { 
				await videoEl.play();
			}
			catch (_) { }
			// Load and render scenes and heatmaps overlays
			renderOverlaysForFile(file).catch(() => {});
			// Refresh markers when duration becomes available
			videoEl.onloadedmetadata = () => {
				renderOverlaysForFile(file).catch(() => {});
				// Ensure our subtitles track (if any) is shown and others disabled
				try { 
					const tt = videoEl._subsTrack || (videoEl.textTracks && Array.from(videoEl.textTracks).find(t => t.kind === 'subtitles'));
					if (tt) {
						try { tt.mode = 'showing'; } catch (_) {}
						try { Array.from(videoEl.textTracks || []).forEach(t => { if (t !== tt) t.mode = 'disabled'; }); } catch (_) {}
					}
				} catch (_) {}
				if (controlsBar && getTabFromLocation() === "Player")
				controlsBar.classList.remove("hidden");
			};
		}
		
		async function renderOverlaysForFile(file) {
			if (!file) return;
			// Scenes
			let scenes = null;
			try { 
				const res = await fetch(`/api/scenes/get?path=${encodeURIComponent(file.path)}`);
				if (res.ok) {
					const body = await res.json();
					scenes = (body.data && (body.data.markers || body.data.scenes || body.data.markers)) 
					|| body.markers 
					|| null;
					if (Array.isArray(body.data?.markers)) scenes = body.data.markers;
				}
			}
			catch (_) { }
			renderChapters(scenes, file);
			// Heatmaps: prefer PNG for speed; fallback to JSON gradient
			let heatmapURL = null;
			try { 
				const resP = await fetch(`/api/heatmaps/png?path=${encodeURIComponent(file.path)}`);
				if (resP.ok) {
					// Blob URL to avoid re-requesting
					const blob = await resP.blob();
					heatmapURL = URL.createObjectURL(blob);
				}
			}
			catch (_) { }
			if (heatmapURL) {
				renderHeatmapStripe({type: "png", url: heatmapURL });
			}
			else {
				try { 
					const resJ = await fetch( `/api/heatmaps/json?path=${encodeURIComponent(file.path)}`);
					if (resJ.ok) {
						const body = await resJ.json();
						// Support multiple shapes:
						// - { data: { heatmaps: { samples: [...] } } }
						// - { heatmaps: { samples: [...] } }
						// - { samples: [...] }
						let data = (body.data && body.data.heatmaps) || body.heatmaps || body;
						renderHeatmapStripe({type: "json", data });
					}
					else {
						renderHeatmapStripe(null);
					}
				}
				catch (_) {
					renderHeatmapStripe(null);
				}
			}
			if (controlsBar && getTabFromLocation() === "Player")
			controlsBar.classList.remove("hidden");
		}
		
		function renderChapters(scenes, file) {
			if (!chaptersBar) return;
			chaptersBar.innerHTML = "";
			const duration = videoEl.duration || file?.duration || 0;
			if (!duration || !Array.isArray(scenes)) return;
			// scenes entries could be {time,score} or tuples; normalize
			const times = scenes
			.map((s) => typeof s === "number" ? s : (s.time ?? s[0] ?? s.t ?? null))
			.filter((t) => typeof t === "number");
			times.forEach((t) => {
				const pct = Math.min(99.9, Math.max(0, (t / duration) * 100));
				const m = document.createElement("div");
				m.className = "marker";
				m.style.left = pct + "%";
				// clicking a marker seeks to its time
				m.style.pointerEvents = "auto";
				m.title = `Scene @ ${hhmmss(t)}`;
				m.addEventListener("click", (ev) => {
					ev.stopPropagation();
					try { 
						videoEl.currentTime = t;
					}
					catch (_) { }
				});
				chaptersBar.appendChild(m);
			});
		}
		
		function renderHeatmapStripe(payload) {
			if (!heatmapStripe) return;
			heatmapStripe.style.backgroundImage = "";
			heatmapStripe.style.background = "#111";
			if (!payload) return;
			if (payload.type === "png" && payload.url) {
				heatmapStripe.style.backgroundImage = `url('${payload.url}')`;
				heatmapStripe.style.backgroundRepeat = "no-repeat";
				heatmapStripe.style.backgroundSize = "100% 100%";
				return;
			}
			if (payload.type === "json" && payload.data) {
				const data = payload.data;
				const samples = data.samples || (data.heatmaps && data.heatmaps.samples) || [];
				if (!samples.length) return;
				// Build CSS gradient using value 'v' (0..1) or brightness (0..255)
				const lastIdx = samples.length - 1;
				const stops = samples.map((s, i) => {
					const v = s.v != null ? Number(s.v) : (s.brightness != null ? Number(s.brightness) / 255 : 0);
					const g = Math.max(0, Math.min(255, Math.round((isFinite(v) ? v : 0) * 255)));
					const color = `rgb(${g},${g},${g})`;
					const pct = lastIdx > 0 ? (i / lastIdx) * 100 : 0;
					return `${color} ${pct}%`;
				});
				heatmapStripe.style.backgroundImage = `linear-gradient(to right, ${stops.join(",")})`;
			}
		}
		
		// Seek behavior on overlay
		if (controlsProgress) {
			const seekFromEvent = (ev) => {
				const rect = controlsProgress.getBoundingClientRect();
				const x = (ev.touches ? ev.touches[0].clientX : ev.clientX) - rect.left;
				const pct = Math.max(0, Math.min(1, x / rect.width));
				if (!isNaN(videoEl.duration)) {
					videoEl.currentTime = pct * videoEl.duration;
				}
			};
			// Hover scrubbing preview using sprite sheet when available
			let spriteData = null; // {index:{...}, sheetUrl:string}
			let previewEl = null;
			const spritesRequested = new Set(); // track files we've kicked off generation for
			async function ensureSprites() {
				if (!selectedFile) return null;
				if (spriteData && spriteData.file === selectedFile.path)
				return spriteData;
				// Try to fetch existing sprites first
				const tryFetch = async () => {
					const res = await fetch(`/api/sprites/json?path=${encodeURIComponent(selectedFile.path)}`);
					if (!res.ok) return null;
					const body = await res.json();
					const index = (body.data && body.data.index) || body.index;
					let sheetUrl = (body.data && body.data.sheet) || body.sheet;
					// cache-bust to avoid stale sprite sheets after regeneration
					try { sheetUrl = sheetUrl + (sheetUrl.includes("?") ? "&" : "?") + "t=" + Date.now(); } catch (_) {}
					return {index, sheetUrl };
				};
				try { 
					let data = await tryFetch();
					if (!data) {
						// If missing, kick off generation once for this file, then poll briefly
						const key = selectedFile.path;
						if (!spritesRequested.has(key)) {
							spritesRequested.add(key);
							try { 
								await fetch( `/api/sprites/create?path=${encodeURIComponent(key)}`, {method: "POST" }, );
							}
							catch (_) { }
						}
						// Poll up to ~12s for readiness (sprite extraction can take longer)
						const deadline = Date.now() + 12000;
						while (!data && Date.now()< deadline) {
							await new Promise((r) => setTimeout(r, 300));
							data = await tryFetch();
						}
					}
					if (!data) {
						spriteData = null;
						return null;
					}
					spriteData = {...data, file: selectedFile.path };
					return spriteData;
				}
				catch (_) {
					spriteData = null;
					return null;
				}
			}
			// Expose for warm-up from play()
			try { window.ensureSprites = ensureSprites; }
			catch (_) { }
			function ensurePreviewEl() {
				if (previewEl) return previewEl;
				previewEl = document.createElement("div");
				previewEl.className = "sprite-preview";
				const wrap = document.querySelector('.player-media');
				if (wrap) wrap.appendChild(previewEl);
				else document.body.appendChild(previewEl);
				return previewEl;
			}
			function updatePreviewPosition(clientX) {
				const wrap = document.querySelector('.player-media');
				const wrect = wrap ? wrap.getBoundingClientRect() : {left: 0 };
				const prect = controlsProgress.getBoundingClientRect();
				const clamped = Math.max(prect.left + 8, Math.min(prect.right - 8, clientX));
				const localX = clamped - wrect.left; // position within wrapper relative to controls
				ensurePreviewEl();
				previewEl.style.left = `${localX}px`;
			}
			function showSpriteAt(pct) {
				if (!spriteData) return;
				const idx = spriteData.index;
				const frames = idx.frames || (idx.cols * idx.rows);
				if (!frames) return;
				// Prefer time-based mapping using interval when available
				let i;
				const hasInterval = Number.isFinite(idx.interval) && idx.interval > 0;
				if (hasInterval && videoEl && Number.isFinite(videoEl.duration)) {
					const t = Math.max(0, Math.min(videoEl.duration, pct * videoEl.duration));
					i = Math.floor(t / idx.interval);
				} else {
					i = Math.floor(pct * frames);
				}
				i = Math.max(0, Math.min(frames - 1, i));
				const col = i % idx.cols;
				const row = Math.floor(i / idx.cols);
				const tw = idx.tile_width || 160;
				const th = idx.tile_height || 90;
				const x = -col * tw;
				const y = -row * (idx.tile_height || th);
				previewEl.style.backgroundImage = `url('${spriteData.sheetUrl}')`;
				previewEl.style.backgroundSize = `${idx.cols * tw}px ${idx.rows * (idx.tile_height || th)}px`;
				previewEl.style.backgroundPosition = `${x}px ${y}px`;
				previewEl.style.width = `${tw}px`;
				previewEl.style.height = `${idx.tile_height || th}px`;
				// Must force visible to override CSS .sprite-preview {display: none }
				previewEl.style.display = "block";
			}
			controlsProgress.addEventListener("mousemove", async (e) => {
				const rect = controlsProgress.getBoundingClientRect();
				const x = e.clientX - rect.left;
				const pct = Math.max(0, Math.min(1, x / rect.width));
				updatePreviewPosition(e.clientX);
				const s = await ensureSprites();
				if (s) showSpriteAt(pct);
			});
			controlsProgress.addEventListener("mouseleave", () => {
				if (previewEl) previewEl.style.display = "none";
			});
			controlsProgress.addEventListener("click", seekFromEvent);
			let dragging = false;
			controlsProgress.addEventListener("mousedown", (e) => {
				dragging = true;
				seekFromEvent(e);
			});
			window.addEventListener("mousemove", (e) => {
				if (dragging) seekFromEvent(e);
			});
			window.addEventListener("mouseup", () => (dragging = false));
			controlsProgress.addEventListener("touchstart",
			(e) => {
				dragging = true;
				seekFromEvent(e);
			},
			{passive: true});
			controlsProgress.addEventListener("touchmove",
			(e) => {
				if (dragging) seekFromEvent(e);
			}, {passive: true});
			window.addEventListener("touchend", () => (dragging = false), {
				passive: true,
			});
		}
		
		/* duplicate startJobsSSE removed: using the primary implementation in Tasks section */
		
		// Control listeners setup
		function setupControlListeners() {
			document.getElementById("searchInput").addEventListener("input", () => {
				currentPage = 1;
				load(cwd);
			});
			document.getElementById("sortBy").addEventListener("change", () => {
				currentPage = 1;
				load(cwd);
			});
			const sortOrderToggle = document.getElementById("sortOrderToggle");
			function updateSortOrderToggleIcon() {
				if (!sortOrderToggle) return;
				const cur = sortOrderToggle.dataset.order === 'desc' ? 'desc' : 'asc';
				sortOrderToggle.textContent = cur === 'asc' ? '↑' : '↓';
				sortOrderToggle.title = `Toggle sort order (${cur === 'asc' ? 'Asc' : 'Desc'})`;
			}
			if (sortOrderToggle) {
				// seed from URL if present
				try {
					const u = new URL(window.location.href);
					const orderQ = u.searchParams.get('order');
					if (orderQ === 'asc' || orderQ === 'desc') {
						sortOrderToggle.dataset.order = orderQ;
					}
				} catch(_){}
				updateSortOrderToggleIcon();
				sortOrderToggle.addEventListener('click', () => {
					const cur = sortOrderToggle.dataset.order === 'desc' ? 'desc' : 'asc';
					const next = cur === 'asc' ? 'desc' : 'asc';
					sortOrderToggle.dataset.order = next;
					updateSortOrderToggleIcon();
					currentPage = 1;
					load(cwd);
				});
			}
			document.getElementById("gridSize").addEventListener("change", () => {
				load(cwd);
			});
			if (pageSizeInput) {
				pageSizeInput.addEventListener("change", () => {
					let v = parseInt(pageSizeInput.value, 10);
					if (v >0) {
						if (v % 4 !== 0) {
							v = Math.round(v / 4) * 4;
						}
						pageSizeInput.value = v;
						pageSize = v;
						currentPage = 1;
						load(cwd);
					}
				});
			}
			
			// Wire explicit Set button to apply the root path from the input
			if (setRootBtn) {
				setRootBtn.onclick = async () => {
					try {
						const v = (rootInput && rootInput.value) ? rootInput.value.trim() : "";
						if (!v) {
							alert("Enter a root folder path.");
							return;
						}
						status("Setting root…");
						// Validate path first to avoid server-side errors
						let okToSet = false;
						try {
							const tp = await fetch("/api/testpath?" + new URLSearchParams({ path: v }).toString(), { method: "POST" });
							if (tp.ok) {
								const tjson = await tp.json();
								const tdata = tjson.data || tjson;
								okToSet = !!(tdata && tdata.exists && tdata.is_dir);
							}
						} catch (_) { okToSet = false; }
						if (!okToSet) {
							status("");
							alert("Path does not exist or is not a directory.");
							return;
						}
						const res = await fetch("/api/setroot?" + new URLSearchParams({ root: v }).toString(), { method: "POST" });
						if (res.ok) {
							currentPage = 1;
							cwd = "";
							await load("");
							status("OK");
						} else {
							status("");
							alert("Failed to set root.");
						}
					} catch (_) {
						status("");
					}
				};
			}
		}
		
		// Auto-load root folder on page load
		window.addEventListener("DOMContentLoaded", async () => {
			// Wire up set thumbnail button logic
			const setThumbBtn = document.getElementById("setThumbBtn");
			const setMarkerBtn = document.getElementById("setMarkerBtn");
			if (setThumbBtn) {
				setThumbBtn.onclick = async () => {
					if (!selectedFile) return;
					const currentTime = Math.floor(videoEl.currentTime || 0);
					setThumbBtn.disabled = true;
					setThumbBtn.textContent = "Setting thumbnail…";
					// Use correct API: POST to /api/create_cover?path=...&t=...
					// Always use 't' as the timestamp query param for backend
					const res = await fetch(`/api/cover/create?path=${encodeURIComponent(selectedFile.path)}&t=${currentTime}&overwrite=1`, {method: "POST" });
					if (res.ok) {
						setThumbBtn.textContent = "Thumbnail set!";
						// Use a unique timestamp to force browser to reload the image
						const uniqueTs = Date.now() + Math.floor(Math.random() * 10000);
						const metaRes = await fetch( `/api/metadata/get?path=${encodeURIComponent(selectedFile.path)}`, {method: "GET" } );
						let updatedFile = selectedFile;
						if (metaRes.ok) {
							const meta = await metaRes.json();
							const metaBody = meta.data || meta;
							updatedFile = {
								...selectedFile,
								...metaBody,
								cover: `/api/cover/get?path=${encodeURIComponent(selectedFile.path)}&t=${uniqueTs}`,
							};
						}
						else {
							updatedFile = {
								...selectedFile,
								cover: `/api/cover/get?path=${encodeURIComponent(selectedFile.path)}&t=${uniqueTs}`,
							};
						}
						showInfo(updatedFile);
					}
					else {
						setThumbBtn.textContent = "Failed to set thumbnail";
					}
					setTimeout(() => {
						setThumbBtn.textContent = "Set Thumbnail from Current Frame";
						setThumbBtn.disabled = false;
					}, 2000);
				};
				// Only show button in Player tab
				setThumbBtn.style.display = "none";
			}
			if (setMarkerBtn) {
				setMarkerBtn.onclick = async () => {
					if (!selectedFile || !selectedFile.path) return;
					const t = Math.max(0, Math.min(videoEl.duration || 0, videoEl.currentTime || 0));
					try { 
						await fetch(`/api/marker?path=${encodeURIComponent(selectedFile.path)}&time=${encodeURIComponent(t)}`, { method: 'POST' });
						// Refresh scenes overlay to show the new marker immediately
						await renderOverlaysForFile(selectedFile);
					} catch (_) {}
				};
				// Only show button in Player tab
				setMarkerBtn.style.display = "none";
			}
			setupControlListeners();
			mountSpritePreviewInPlayer();
			// Initialize filter registries and inputs
			try { await _ensureRegistryLists(); } catch(_) {}
			try { _wireFilterInputs(); } catch(_) {}
			try { _renderFilterChips(); } catch(_) {}
			// Ensure backend root is set before attempting to restore/load; if not provided, proceed with existing backend root
			try { 
				const v = (rootInput && rootInput.value) ? rootInput.value.trim() : "";
				if (v) {
					status("Setting root…");
					// Verify path quickly to avoid hanging on bad roots
					const tp = await fetch("/api/testpath?" + new URLSearchParams({path: v }).toString(), {method: "POST" });
					let okToSet = false;
					if (tp.ok) {
						const tjson = await tp.json();
						const tdata = tjson.data || tjson;
						okToSet = !!(tdata && tdata.exists && tdata.is_dir);
					}
					if (okToSet) {
						const params = new URLSearchParams({root: v });
						const res = await fetch("/api/setroot?" + params.toString(), {method: "POST" });
						if (res.ok) {
							currentPage = 1;
							cwd = "";
							await load("");
						}
						else {
							// Fall back to current root
							await load("");
						}
					}
					else {
						// Invalid path typed; just load current root
						await load("");
					}
				}
				else {
					// No root provided; use existing server root
					await load("");
				}
			}
			catch (_) {
				// On any error, attempt to load current root rather than hang
				try { await load(""); }
				catch (_) { }
			}
			// Initialize tab from URL (hash) or default to Grid without pushing a new history entry
			const initialTab = getTabFromLocation() || "Grid";
			showTab(initialTab, true);
			try { setRouteForTab(initialTab, true); }
			catch (_) { }
			// Restore last played/selected video (set selection always; autoplay only when on Player)
			try { 
				// TODO @copilot v1 reference
				const LAST_VIDEO_KEY = 'lastVideo.v1';
				const LAST_SELECTED_KEY = 'lastSelected.v1';
				const raw = localStorage.getItem(LAST_VIDEO_KEY);
				if (raw) {
					const rec = JSON.parse(raw);
					if (rec && rec.path) {
						const file = { path: rec.path, name: rec.name || (rec.path.split('/').pop() || rec.path), title: rec.title || '' };
						selectedFile = file;
						if (initialTab === 'Player') {
							await play(file);
						} else {
							// If landing on Grid/List, ensure the sidebar shows the last video
							// by loading its directory and selecting its tile. If not on page 1,
							// paginate until found (bounded by totalPages from backend response).
							const lastDir = rec.path.includes('/') ? rec.path.substring(0, rec.path.lastIndexOf('/')) : '';
							try { await load(lastDir || ""); } catch (_) {}
							let found = await selectFileInGridByPath(rec.path, file.name, file.title);
							if (!found) {
								try {
									const maxPages = totalPages || 1;
									for (let p = 2; p <= maxPages; p++) {
										await load(lastDir || "", p);
										found = await selectFileInGridByPath(rec.path, file.name, file.title);
										if (found) break;
									}
								} catch (_) {}
							}
						}
					}
				}
				// If no lastVideo or selection unsuccessful, try lastSelected fallback on Grid/List
				if ((initialTab === 'Grid' || initialTab === 'List') && (!selectedFile || !document.querySelector('.tile.selected'))) {
					const r2 = localStorage.getItem(LAST_SELECTED_KEY);
					if (r2) {
						try {
							const rec2 = JSON.parse(r2);
							if (rec2 && rec2.path) {
								const dir2 = rec2.path.includes('/') ? rec2.path.substring(0, rec2.path.lastIndexOf('/')) : '';
								await load(dir2 || "");
								let ok = await selectFileInGridByPath(rec2.path, rec2.name, rec2.title);
								if (!ok) {
									const maxPages = totalPages || 1;
									for (let p = 2; p <= maxPages; p++) {
										await load(dir2 || "", p);
										ok = await selectFileInGridByPath(rec2.path, rec2.name, rec2.title);
										if (ok) break;
									}
								}
							}
						} catch (_) {}
					}
					// Final fallback: select first visible tile to ensure sidebar isn't empty
					if (!document.querySelector('.tile.selected')) {
						const first = document.querySelector('.tile');
						if (first) {
							try {
								const p = first.dataset.path || '';
								const name = first.querySelector('.name')?.textContent || (p.split('/').pop() || p);
								first.classList.add('selected');
								const f = { path: p, name, title: '' };
								selectedTile = first; selectedFile = f;
								showInfo(f);
							} catch (_) {}
						}
					}
				}
			}
			catch (_) { }
		});
		
		// Handle back/forward navigation for tabs
		window.addEventListener("popstate", async () => {
			const t = getTabFromLocation() || "Grid";
			const p = getPageFromLocation();
			currentPage = p;
			await showTab(t, true);
			// If grid/list visible, reload to reflect page from URL
			if (t === 'Grid' || t === 'List') {
				await load(cwd, p);
			}
		});
		window.addEventListener("hashchange", async () => {
			const t = getTabFromLocation() || "Grid";
			await showTab(t, true);
		});
		
		if (prevBtn) {
			prevBtn.onclick = async () => {
				if (currentPage >1) {
					const p = currentPage - 1;
					setPageInLocation(p);
					await load(cwd, p);
				}
			};
		}
		if (nextBtn) {
			nextBtn.onclick = async () => {
				if (currentPage< totalPages) {
					const p = currentPage + 1;
					setPageInLocation(p);
					await load(cwd, p);
				}
			};
		}
		if (pageSizeInput) {
			pageSizeInput.onchange = async () => {
				let v = parseInt(pageSizeInput.value, 10);
				if (v > 0) {
					// Only allow multiples of 4 or 8
					if (v % 4 !== 0) v = Math.round(v / 4) * 4;
					pageSizeInput.value = v;
					pageSize = v;
					currentPage = 1;
					setPageInLocation(currentPage);
					await load(cwd, currentPage);
				}
			};
		}
		
		const gridSizeInput = document.getElementById("gridSize");
		if (gridSizeInput) {
			gridSizeInput.onchange = () => {
				const cols = parseInt(gridSizeInput.value, 10) || 4;
				// TODO @copilot: there must be a better way to do this
				filesEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
			};
			filesEl.style.gridTemplateColumns = `repeat(${gridSizeInput.value}, 1fr)`;
		}
		
		document.addEventListener("keydown", (e) => {
			// Always allow space/arrow keys for player and grid navigation
			if (document.activeElement && ["INPUT", "TEXTAREA"].includes(document.activeElement.tagName)) return;
			const tiles = Array.from(document.querySelectorAll(".tile"));
			let idx = tiles.indexOf(selectedTile);
			let cols = parseInt(document.getElementById("gridSize").value, 10) || 4;
			if (e.code === "Space") {
				if (!videoEl.classList.contains("hidden")) {
					e.preventDefault();
					if (videoEl.paused) {
						videoEl.play();
					}
					else {
						videoEl.pause();
					}
				}
				else {
					if (selectedTile && tiles.length) {
						selectedTile.click();
					}
				}
			}
			else if (e.code === "ArrowLeft") {
				if (!videoEl.classList.contains("hidden")) {
					e.preventDefault();
					try { 
						videoEl.currentTime = Math.max(0, (videoEl.currentTime || 0) - 5);
					}
					catch (_) { }
				}
				else {
					if (idx >0) {
						tiles[idx - 1].click();
						tiles[idx - 1].scrollIntoView({
							block: "nearest",
							inline: "nearest",
						});
						e.preventDefault();
					}
				}
			}
			else if (e.code === "ArrowRight") {
				if (!videoEl.classList.contains("hidden")) {
					e.preventDefault();
					try { 
						videoEl.currentTime = (videoEl.currentTime || 0) + 5;
					}
					catch (_) { }
				}
				else {
					if (idx< tiles.length - 1) {
						tiles[idx + 1].click();
						tiles[idx + 1].scrollIntoView({
							block: "nearest",
							inline: "nearest",
						});
						e.preventDefault();
					}
				}
			}
			else if (e.code === "ArrowDown") {
				if (idx + cols< tiles.length) {
					tiles[idx + cols].click();
					tiles[idx + cols].scrollIntoView({
						block: "nearest",
						inline: "nearest",
					});
					e.preventDefault();
				}
			}
			else if (e.code === "ArrowUp") {
				if (idx - cols >= 0) {
					tiles[idx - cols].click();
					tiles[idx - cols].scrollIntoView({
						block: "nearest",
						inline: "nearest",
					});
					e.preventDefault();
				}
			}
		});
		
		// Add 'Random' to sort dropdown
		const sortBySelect = document.getElementById("sortBy");
		if ( sortBySelect && !Array.from(sortBySelect.options).some((opt) => opt.value === "random") ) {
			const randomOption = document.createElement("option");
			randomOption.value = "random";
			randomOption.textContent = "Random";
			sortBySelect.appendChild(randomOption);
		}
		// Add 'Play Random Video' button at the top
		const controlsDiv = document.getElementById("gridControls");
		if (controlsDiv && !document.getElementById("playRandomBtn")) {
			const playRandomBtn = document.createElement("button");
			playRandomBtn.id = "playRandomBtn";
			playRandomBtn.className = "btn";
			playRandomBtn.textContent = "Random";
			controlsDiv.insertBefore(playRandomBtn, controlsDiv.firstChild);
			playRandomBtn.onclick = async () => {
				// Fetch all files (all pages)
				let allMediaFiles = [];
				let page = 1;
				let pageSize = 500;
				let totalPages = 1;
				do {
					const params = new URLSearchParams();
					params.set("page", String(page));
					params.set("page_size", String(pageSize));
					// Use current filters (search only)
					const searchVal = document
					.getElementById("searchInput")
					?.value?.trim();
					if (searchVal) params.set("search", searchVal);
					params.set("sort", "name"); // Always fetch all, don't sort random here
					const res = await fetch("/api/library?" + params.toString(), {
						method: "GET",
					});
					if (!res.ok) break;
					const body = await res.json();
					const data = body.data || body;
					allMediaFiles = allMediaFiles.concat(data.files || []);
					totalPages = data.total_pages || 1;
					page++;
				}
				while (page <= totalPages);
				if (allMediaFiles.length === 0) {
					alert("No videos found!");
					return;
				}
				const randomIdx = Math.floor(Math.random() * allMediaFiles.length);
				const file = allMediaFiles[randomIdx];
				play(file);
			};
		}
		
		// List tab logic
		// Column config
		const LIST_COLS_KEY = "listCols.v2";
		const defaultListCols = [
		{key: "name", label: "Name", align: "left", width: 320, visible: true, source: "basic" },
		{key: "size", label: "Size", align: "right", width: 100, visible: true, source: "basic" },
		{key: "duration", label: "Duration", align: "right", width: 110, visible: true, source: "basic" },
		{key: "codecs", label: "Codecs", align: "left", width: 160, visible: true, source: "basic" },
		{key: "tags", label: "Tags", align: "left", width: 200, visible: true, source: "basic" },
		// Artifacts (hidden by default)
		{key: "art.cover", label: "Cover", align: "center", width: 80, visible: false, source: "artifact" },
		{key: "art.hover", label: "Hover", align: "center", width: 80, visible: false, source: "artifact" },
		{key: "art.sprites", label: "Sprites", align: "center", width: 80, visible: false, source: "artifact" },
		{key: "art.subtitles", label: "Subtitles", align: "center", width: 92, visible: false, source: "artifact" },
		{key: "art.phash", label: "pHash", align: "center", width: 80, visible: false, source: "artifact" },
		{key: "art.heatmaps", label: "Heatmaps", align: "center", width: 92, visible: false, source: "artifact" },
		{key: "art.scenes", label: "Scenes", align: "center", width: 80, visible: false, source: "artifact" },
		{key: "art.faces", label: "Faces", align: "center", width: 80, visible: false, source: "artifact" },
		];
		function getListCols() {
			try { 
				const raw = localStorage.getItem(LIST_COLS_KEY);
				if (!raw) return defaultListCols.slice();
				const parsed = JSON.parse(raw);
				if (!Array.isArray(parsed)) return defaultListCols.slice();
				// merge to ensure any new defaults are included
				const byKey = Object.fromEntries(parsed.map(c => [c.key, c]));
				const merged = defaultListCols.map(d => ({...d, ...(byKey[d.key] || {}) }));
				// include any legacy/custom keys
				parsed.forEach(c => {if (!merged.find(m => m.key === c.key)) merged.push(c); });
				return merged;
			}
			catch {
				return defaultListCols.slice();
			}
		}
		function setListCols(cols) {
			localStorage.setItem(LIST_COLS_KEY, JSON.stringify(cols));
		}
		// Metadata discovery cache
		const metaRawCache = new Map(); // path ->raw ffprobe json
		let discoveredMetaKeys = new Set();
		
		function renderListColumnsPanel() {
			const panel = document.getElementById("listColumnsPanel");
			if (!panel) return;
			const cols = getListCols();
			// TODO @copilot: avoid this. use static html that's hidden until needed
			panel.innerHTML = `
			<div class="row"><strong>Columns</strong><span class="muted">(drag to reorder)</span></div>
			<div class="section">
				<div class="muted">Basics & Artifacts</div>
				<div id="listColsChoices" class="choices"></div>
			</div>
			<div class="section">
				<div class="row">
					<strong>ffprobe metadata</strong>
					<input id="metaFilter" type="text" placeholder="filter…" />
					<button id="discoverMetaBtn" class="btn">Discover ffprobe keys</button>
				</div>
				<div id="metaColsChoices" class="choices"></div>
			</div>
			<div class="row">
				<button id="resetListColsBtn" class="btn">Reset</button>
			</div>
		`;
			const choices = panel.querySelector("#listColsChoices");
			cols.forEach((c, idx) => {
				const id = `col_${c.key}`;
				const wrap = document.createElement("div");
				wrap.className = "row";
				wrap.style.alignItems = "center";
				wrap.style.gap = "8px";
				wrap.draggable = true;
				wrap.dataset.index = String(idx);
				// TODO @copilot: avoid this. use static html that's hidden until needed
				wrap.innerHTML = `<input type="checkbox" id="${id}" ${c.visible ? "checked" : ""}/><label for="${id}">${esc(c.label)}</label>`;
				// drag to reorder
				wrap.addEventListener("dragstart", (e) => {
					wrap.classList.add("dragging-col");
					e.dataTransfer?.setData("text/plain", String(wrap.dataset.index || idx));
				});
				wrap.addEventListener("dragend", () => {
					wrap.classList.remove("dragging-col");
					wrap.classList.remove("drop-before");
					wrap.classList.remove("drop-after");
				});
				wrap.addEventListener("dragover", (e) => {
					e.preventDefault();
					const rect = wrap.getBoundingClientRect();
					const mid = rect.top + rect.height / 2;
					wrap.classList.toggle("drop-before", (e.clientY || 0) < mid);
					wrap.classList.toggle("drop-after", (e.clientY || 0) >= mid);
				});
				wrap.addEventListener("dragleave", () => {
					wrap.classList.remove("drop-before");
					wrap.classList.remove("drop-after");
				});
				wrap.addEventListener("drop", (e) => {
					e.preventDefault();
					const from = parseInt(e.dataTransfer?.getData("text/plain") || "-1", 10);
					let to = parseInt(wrap.dataset.index || String(idx), 10);
					const rect = wrap.getBoundingClientRect();
					const mid = rect.top + rect.height / 2;
					if ((e.clientY || 0) >= mid) to = to + 1;
					if (from >= 0 && from !== to) {
						const cur = getListCols();
						const [moved] = cur.splice(from, 1);
						cur.splice(to, 0, moved);
						setListCols(cur);
						renderListHeader();
						// re-open panel to reflect order
						renderListColumnsPanel();
						loadListRows(lastListDataCache || []);
					}
					wrap.classList.remove("drop-before");
					wrap.classList.remove("drop-after");
				});
				choices.appendChild(wrap);
				const cb = wrap.querySelector("input");
				cb.addEventListener("change", () => {
					const cur = getListCols();
					cur[idx].visible = cb.checked;
					setListCols(cur);
					renderListHeader();
					loadListRows(lastListDataCache || []);
				});
			});
			// metadata choices
			const metaChoices = panel.querySelector('#metaColsChoices');
			function renderMetaChoices() {
				if (!metaChoices) return;
				metaChoices.innerHTML = '';
				const filterVal = (panel.querySelector('#metaFilter')?.value || '').toLowerCase();
				const keys = Array.from(discoveredMetaKeys).sort();
				keys.forEach((k) => {
					if (filterVal && !k.toLowerCase().includes(filterVal)) return;
					const id = `mcol_${k.replace(/[^a-zA-Z0-9_.-]/g,'_')}`;
					const row = document.createElement('div');
					row.className = 'row';
					row.style.alignItems = 'center';
					row.style.gap = '8px';
					const existing = getListCols().find(c => c.source === 'meta' && c.key === k);
					// TODO @copilot: avoid this. use static html that's hidden until needed
					row.innerHTML = `<input type="checkbox" id="${id}" ${existing ? 'checked' : ''}/><label for="${id}">${esc(k)}</label>`;
					metaChoices.appendChild(row);
					const cb = row.querySelector('input');
					cb.addEventListener('change', () => {
						const cur = getListCols();
						if (cb.checked) {
							if (!existing) {
								cur.push({key: k, label: k, align: 'left', width: 160, visible: true, source: 'meta' });
							}
						}
						else {
							const idx = cur.findIndex(c => c.source === 'meta' && c.key === k);
							if (idx >= 0) cur.splice(idx, 1);
						}
						setListCols(cur);
						renderListHeader();
						loadListRows(lastListDataCache || []);
						renderMetaChoices();
					});
				});
			}
			panel.querySelector('#metaFilter')?.addEventListener('input', renderMetaChoices);
			const discoverBtn = panel.querySelector('#discoverMetaBtn');
			if (discoverBtn) {
				discoverBtn.addEventListener('click', async () => {
					await discoverMetadataKeys();
					renderMetaChoices();
				});
			}
			renderMetaChoices();
			const resetBtn = panel.querySelector("#resetListColsBtn");
			resetBtn.addEventListener("click", () => {
				setListCols(defaultListCols);
				renderListHeader();
				renderListColumnsPanel();
				loadListRows(lastListDataCache || []);
			});
		}
		function renderListHeader() {
			const row = document.getElementById("listHeaderRow");
			if (!row) return;
			row.innerHTML = "";
			const cols = getListCols().filter(c => c.visible !== false);
			cols.forEach((c, idx) => {
				const th = document.createElement("th");
				th.className = `th text-${c.align || "left"}`;
				th.draggable = true;
				th.dataset.key = c.key;
				th.dataset.index = String(idx);
				if (c.width) th.style.width = c.width + "px";
				// TODO @copilot: avoid this. use static html that's hidden until needed
				th.innerHTML = `<span class="th-label">${esc(c.label)}</span><span class="col-resizer" data-idx="${idx}"></span>`;
				// drag reorder
				th.addEventListener("dragstart", (e) => {
					th.classList.add("dragging-col");
					e.dataTransfer?.setData("text/plain", String(th.dataset.index || idx));
				});
				th.addEventListener("dragend", () => {
					th.classList.remove("dragging-col");
					th.classList.remove("drop-left");
					th.classList.remove("drop-right");
				});
				th.addEventListener("dragover", (e) => {
					e.preventDefault();
					const rect = th.getBoundingClientRect();
					const mid = rect.left + rect.width / 2;
					th.classList.toggle("drop-left", (e.clientX || 0) < mid);
					th.classList.toggle("drop-right", (e.clientX || 0) >= mid);
				});
				th.addEventListener("dragleave", () => {
					th.classList.remove("drop-left");
					th.classList.remove("drop-right");
				});
				th.addEventListener("drop", (e) => {
					e.preventDefault();
					const from = parseInt(e.dataTransfer?.getData("text/plain") || "-1", 10);
					let to = parseInt(th.dataset.index || String(idx), 10);
					// If dropped on right half, insert after
					const rect = th.getBoundingClientRect();
					const mid = rect.left + rect.width / 2;
					if ((e.clientX || 0) >mid) to = to + 1;
					if (from >= 0 && from !== to) {
						// reorder on full config preserving hidden columns order
						const curAll = getListCols();
						const visible = curAll.filter(c => c.visible !== false);
						const hidden = curAll.filter(c => c.visible === false);
						const [moved] = visible.splice(from, 1);
						// Clamp to bounds
						const toIdx = Math.max(0, Math.min(visible.length, to));
						visible.splice(toIdx, 0, moved);
						const merged = [];
						// maintain original order but with new visible ordering
						visible.forEach(v => merged.push(v));
						hidden.forEach(h => merged.push(h));
						setListCols(merged);
						renderListHeader();
						loadListRows(lastListDataCache || []);
					}
					th.classList.remove("drop-left");
					th.classList.remove("drop-right");
				});
				// resize handle
				const handle = th.querySelector(".col-resizer");
				handle.addEventListener("mousedown", (e) => {
					e.preventDefault();
					e.stopPropagation();
					const startX = e.clientX;
					const startW = th.getBoundingClientRect().width;
					function onMove(ev) {
						const dx = ev.clientX - startX;
						const newW = Math.max(60, Math.round(startW + dx));
						th.style.width = newW + "px";
					}
					function onUp() {
						window.removeEventListener("mousemove", onMove);
						window.removeEventListener("mouseup", onUp);
						// persist width to config
						const key = th.dataset.key;
						const cur = getListCols();
						const found = cur.find(c => c.key === key);
						if (found) {
							const w = Math.round(th.getBoundingClientRect().width);
							found.width = w;
							setListCols(cur);
						}
					}
					window.addEventListener("mousemove", onMove);
					window.addEventListener("mouseup", onUp);
				});
				// double-click: auto-fit to content
				handle.addEventListener("dblclick", (e) => {
					e.preventDefault(); e.stopPropagation();
					// Measure header label
					const lbl = th.querySelector('.th-label');
					let maxW = 60;
					if (lbl) {
						const rect = (lbl instanceof HTMLElement) ? lbl.getBoundingClientRect() : null;
						if (rect) maxW = Math.max(maxW, Math.ceil(rect.width) + 24);
					}
					// Measure body cells in this column
					const table = document.getElementById('listTable');
					if (table) {
						const colIdx = Array.from(th.parentElement?.children || []).indexOf(th);
						const rows = table.querySelectorAll('tbody tr');
						let count = 0;
						rows.forEach((tr) => {
							if (count > 200) return; // cap measurement for performance
							const tds = tr.querySelectorAll('td');
							const td = tds[colIdx];
							if (td) {
								const r = td.getBoundingClientRect();
								maxW = Math.max(maxW, Math.ceil(r.width));
								count++;
							}
						});
					}
					// Apply and persist
					maxW = Math.max(60, Math.min(maxW + 18, 1200));
					th.style.width = maxW + 'px';
					const key = th.dataset.key;
					const cur = getListCols();
					const found = cur.find(c => c.key === key);
					if (found) { found.width = maxW; setListCols(cur); }
				});
				row.appendChild(th);
			});
		}
		function cellText(col, v) {
			if (col.source === 'artifact') {
				const art = v.artifacts || {};
				const key = col.key.replace('art.', '');
				// TODO @copilot: fix these. hover as hover, scenes as scenes. is this even necessary? 
				const alt = v[key] || v[{
					cover: 'cover', 
					hover: 'hoverPreview', 
					sprites: 'scrubThumbs', 
					subtitles: 'subtitles', 
					phash: 'phash', 
					heatmaps: 'heatmaps', 
					scenes: 'chapters', 
					faces: 'faces'
				}[key]];
				const val = (art[key] !== undefined ? art[key] : (alt !== undefined ? alt : false));
				return val ? '✅' : '—';
			}
			if (col.source === 'meta') {
				return '…'; // will be filled asynchronously
			}
			switch (col.key) {
				case "name": return esc(v.name);
				case "size": return human(v.size || 0);
				case "duration": return hhmmss(v.duration || 0);
				case "codecs": return [v.vcodec || "", v.acodec || ""].filter(Boolean).join(" / ");
				case "tags": return Array.isArray(v.tags) ? v.tags.join(", ") : "";
				default: return esc(v[col.key] ?? "");
			}
		}
		function getByPath(obj, path) {
			try { 
				const parts = String(path)
				.replace(/\[(\d+)\]/g, '.$1')
				.split('.')
				.filter(p => p.length > 0);
				let cur = obj;
				for (const p of parts) {
					if (/^\d+$/.test(p)) {
						const i = parseInt(p, 10);
						cur = Array.isArray(cur) ? cur[i] : undefined;
					}
					else {
						cur = cur?.[p];
					}
					if (cur == null) return undefined;
				}
				return cur;
			}
			catch {return undefined; }
		}
		async function ensureMetadata(path) {
			if (metaRawCache.has(path)) return metaRawCache.get(path);
			try { 
				const res = await fetch(`/api/metadata/get?path=${encodeURIComponent(path)}&view=1`);
				if (!res.ok) return null;
				const j = await res.json();
				const raw = j?.data?.raw ?? j?.raw ?? null;
				if (raw) metaRawCache.set(path, raw);
				return raw;
			}
			catch {return null; }
		}
		async function fillMetaCellsForRow(tr, v) {
			const cells = tr.querySelectorAll('[data-meta-path]');
			if (!cells.length) return;
			const raw = await ensureMetadata(v.path);
			cells.forEach((td) => {
				const p = td.getAttribute('data-meta-path');
				let val = raw ? getByPath(raw, p) : undefined;
				if (val == null) td.textContent = '';
				else if (typeof val === 'object') td.textContent = JSON.stringify(val);
				else td.textContent = String(val);
			});
		}
		function _listRow(v) {
			const tr = document.createElement("tr");
			const cols = getListCols().filter(c => c.visible !== false);
			cols.forEach((c) => {
				const td = document.createElement("td");
				td.className = `td text-${c.align || "left"}`;
				if (c.width) td.style.width = c.width + "px";
				const txt = cellText(c, v);
				if (c.source === 'meta') {
					td.textContent = txt;
					td.dataset.metaPath = c.key; // meta path key
				}
				else {
					td.textContent = txt;
				}
				tr.appendChild(td);
			});
			tr.addEventListener("click", () => {
				selectedFile = {
					path: v.path,
					name: v.name,
					size: v.size,
					duration: v.duration,
					cover: v.cover,
					title: v.title,
				};
				showInfo(selectedFile);
			});
			tr.addEventListener("dblclick", () => {
				if (!selectedFile || selectedFile.path !== v.path) {
					selectedFile = {
						path: v.path,
						name: v.name,
						size: v.size,
						duration: v.duration,
					};
				}
				showTab("Player");
				play(selectedFile);
			});
			// async fill meta cells
			fillMetaCellsForRow(tr, v);
			return tr;
		}
		let lastListDataCache = null;
		function loadListRows(vids) {
			const tbody = document.querySelector("#listTable tbody");
			if (!tbody) return;
			tbody.innerHTML = "";
			vids.forEach((v) => tbody.appendChild(_listRow(v)));
		}
		async function loadList() {
			// Use the same directory that Grid is currently showing (cwd), falling back to rootInput or '.'
			const dir = typeof cwd === "string" && cwd.length > 0 ? cwd : rootInput?.value?.trim() || ".";
			const url = `/videos?directory=${encodeURIComponent(dir)}&recursive=false&limit=1000&detail=true`;
			renderListHeader();
			const tbody = document.querySelector("#listTable tbody");
			if (tbody) tbody.innerHTML = "";
			try { 
				const res = await fetch(url);
				if (!res.ok) return;
				const j = await res.json();
				const vids = j.videos || [];
				lastListDataCache = vids;
				loadListRows(vids);
			}
			catch (_) { }
		}
		const reloadListBtn = document.getElementById("reloadListBtn");
		if (reloadListBtn) reloadListBtn.onclick = () => loadList();
		
		// --- Registry Tab Logic ---
		async function loadRegistry() {
			async function fetchJSON(url, opts) {
				try { const r = await fetch(url, opts || {}); if (!r.ok) return null; return await r.json(); } catch(_) { return null; }
			}
			const tagsBox = document.getElementById('tagsRegistryList');
			const perfBox = document.getElementById('performersRegistryList');
			if (tagsBox) tagsBox.textContent = 'Loading…';
			if (perfBox) perfBox.textContent = 'Loading…';
			const [t, p] = await Promise.all([
			fetchJSON('/api/registry/tags'), fetchJSON('/api/registry/performers')
			]);
			if (tagsBox) {
				const arr = (t && (t.data?.tags || t.tags)) || [];
				arr.sort((a,b) => (a.name||'').localeCompare(b.name||''));
				tagsBox.innerHTML = arr.map(x => `<div>${(x.id!=null?`#${x.id} `:'')}${x.name} <span class="small muted">(${x.slug||''})</span></div>`).join('');
			}
			if (perfBox) {
				const arr = (p && (p.data?.performers || p.performers)) || [];
				arr.sort((a,b) => (a.name||'').localeCompare(b.name||''));
				perfBox.innerHTML = arr.map(x => `<div>${(x.id!=null?`#${x.id} `:'')}${x.name} <span class="small muted">(${x.slug||''})</span></div>`).join('');
			}
			// Update filter registries as well
			try { await _ensureRegistryLists(); } catch(_) {}
		}
		(function wireRegistryButtons(){
			const _ = (id) => document.getElementById(id);
			_('refreshRegistryBtn')?.addEventListener('click', () => loadRegistry());
			_('createTagBtn')?.addEventListener('click', async () => {
				const name = (_('newTagName')?.value || '').trim(); if (!name) return;
				await fetch('/api/registry/tags/create', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name }) });
				_('newTagName').value = ''; await loadRegistry();
			});
			_('renameTagBtn')?.addEventListener('click', async () => {
				const name = (_('renameTagFrom')?.value || '').trim(); const new_name = (_('renameTagTo')?.value || '').trim(); if (!name || !new_name) return;
				await fetch('/api/registry/tags/rename', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name, new_name }) });
				_('renameTagFrom').value = ''; _('renameTagTo').value = ''; await loadRegistry();
			});
			_('mergeTagBtn')?.addEventListener('click', async () => {
				const from_name = (_('mergeTagFrom')?.value || '').trim(); const into_name = (_('mergeTagTo')?.value || '').trim(); if (!from_name || !into_name) return;
				const qs = new URLSearchParams({ from_name, into_name, rewrite_sidecars: '1' });
				await fetch('/api/registry/tags/merge?' + qs.toString(), { method: 'POST' });
				_('mergeTagFrom').value = ''; _('mergeTagTo').value = ''; await loadRegistry();
			});
			_('deleteTagBtn')?.addEventListener('click', async () => {
				const name = (_('deleteTagName')?.value || '').trim(); if (!name) return;
				await fetch('/api/registry/tags/delete', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name }) });
				_('deleteTagName').value = ''; await loadRegistry();
			});
			_('createPerfBtn')?.addEventListener('click', async () => {
				const name = (_('newPerfName')?.value || '').trim(); if (!name) return;
				await fetch('/api/registry/performers/create', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name }) });
				_('newPerfName').value = ''; await loadRegistry();
			});
			_('renamePerfBtn')?.addEventListener('click', async () => {
				const name = (_('renamePerfFrom')?.value || '').trim(); const new_name = (_('renamePerfTo')?.value || '').trim(); if (!name || !new_name) return;
				await fetch('/api/registry/performers/update', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name, new_name }) });
				_('renamePerfFrom').value = ''; _('renamePerfTo').value = ''; await loadRegistry();
			});
			_('mergePerfBtn')?.addEventListener('click', async () => {
				const from_name = (_('mergePerfFrom')?.value || '').trim(); const into_name = (_('mergePerfTo')?.value || '').trim(); if (!from_name || !into_name) return;
				const qs = new URLSearchParams({ from_name, into_name, rewrite_sidecars: '1' });
				await fetch('/api/registry/performers/merge?' + qs.toString(), { method: 'POST' });
				_('mergePerfFrom').value = ''; _('mergePerfTo').value = ''; await loadRegistry();
			});
			_('deletePerfBtn')?.addEventListener('click', async () => {
				const name = (_('deletePerfName')?.value || '').trim(); if (!name) return;
				await fetch('/api/registry/performers/delete', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name }) });
				_('deletePerfName').value = ''; await loadRegistry();
			});
		})();
		
		// Rotate headers toggle
		const toggleRotateHeadersBtn = document.getElementById('toggleRotateHeadersBtn');
		const listTableEl = document.getElementById('listTable');
		const ROTATE_HDRS_KEY = 'list.rotateHeaders.v1';
		function applyRotateHeaders(flag) {
			if (!listTableEl) return;
			listTableEl.classList.toggle('rotate-headers', !!flag);
			if (toggleRotateHeadersBtn) toggleRotateHeadersBtn.textContent = `Rotate headers: ${flag ? 'On' : 'Off'}`;
		}
		(function initRotateHeaders(){
			try { applyRotateHeaders(localStorage.getItem(ROTATE_HDRS_KEY) === '1'); } catch(_){}
		})();
		if (toggleRotateHeadersBtn) toggleRotateHeadersBtn.onclick = () => {
			const cur = listTableEl?.classList.contains('rotate-headers');
			const next = !cur;
			applyRotateHeaders(next);
			try { localStorage.setItem(ROTATE_HDRS_KEY, next ? '1' : '0'); } catch(_){}
		};
		
		// Column/Row selection logic
		const enableColSelectChk = document.getElementById('enableColSelectChk');
		const enableRowSelectChk = document.getElementById('enableRowSelectChk');
		let colSelectEnabled = false;
		let rowSelectEnabled = false;
		let selectedColIndex = -1;
		function setColSelected(index) {
			selectedColIndex = index;
			const table = document.getElementById('listTable');
			if (!table) return;
			// Clear previous
			table.querySelectorAll('th.col-selected, td.col-selected').forEach(el => el.classList.remove('col-selected'));
			if (index < 0) return;
			// Mark header
			const headerCells = table.querySelectorAll('thead th');
			if (headerCells[index]) headerCells[index].classList.add('col-selected');
			// Mark body cells at same index
			table.querySelectorAll('tbody tr').forEach(tr => {
				const cells = tr.querySelectorAll('td');
				if (cells[index]) cells[index].classList.add('col-selected');
			});
		}
		function clearRowSelections() {
			const table = document.getElementById('listTable');
			if (!table) return;
			table.querySelectorAll('tbody tr.row-selected').forEach(tr => tr.classList.remove('row-selected'));
		}
		function setColumnHover(index, on) {
			const table = document.getElementById('listTable');
			if (!table) return;
			// Header
			const th = table.querySelectorAll('thead th')[index];
			if (th) th.classList.toggle('drag-hover', !!on);
			// Body cells
			table.querySelectorAll('tbody tr').forEach(tr => {
				const cells = tr.querySelectorAll('td');
				if (cells[index]) cells[index].classList.toggle('drag-hover', !!on);
			});
		}
		
		function wireSelectionHandlers() {
			const table = document.getElementById('listTable');
			if (!table) return;
			// Header click for column selection
			table.querySelectorAll('thead th').forEach((th, idx) => {
				if (th.dataset.selWired === '1') return;
				th.dataset.selWired = '1';
				th.addEventListener('click', (e) => {
					if (!colSelectEnabled) return;
					setColSelected(selectedColIndex === idx ? -1 : idx);
					e.stopPropagation();
				});
				// Stronger drag target feedback across full column
				th.addEventListener('dragover', () => setColumnHover(idx, true));
				th.addEventListener('dragleave', () => setColumnHover(idx, false));
				th.addEventListener('drop', () => setColumnHover(idx, false));
			});
			// Row click for row selection
			table.querySelectorAll('tbody tr').forEach((tr) => {
				if (tr.dataset.selWired === '1') return;
				tr.dataset.selWired = '1';
				tr.addEventListener('click', (e) => {
					if (!rowSelectEnabled) return;
					const already = tr.classList.contains('row-selected');
					clearRowSelections();
					if (!already) tr.classList.add('row-selected');
					e.stopPropagation();
				});
			});
		}
		// Apply after header/body render
		const _renderListHeader_orig = renderListHeader;
		renderListHeader = function() {
			_renderListHeader_orig();
			wireSelectionHandlers();
		};
		const _loadListRows_orig = loadListRows;
		loadListRows = function(vids) {
			_loadListRows_orig(vids);
			wireSelectionHandlers();
			// Re-apply selected column after rerender
			if (colSelectEnabled && selectedColIndex >= 0) setColSelected(selectedColIndex);
		};
		// Toggle checkboxes
		if (enableColSelectChk) enableColSelectChk.addEventListener('change', () => {
			colSelectEnabled = !!enableColSelectChk.checked;
			if (!colSelectEnabled) setColSelected(-1);
		});
		if (enableRowSelectChk) enableRowSelectChk.addEventListener('change', () => {
			rowSelectEnabled = !!enableRowSelectChk.checked;
			if (!rowSelectEnabled) clearRowSelections();
		});
		
		// Columns control
		const toggleListColumnsBtn = document.getElementById("toggleListColumnsBtn");
		if (toggleListColumnsBtn) {
			toggleListColumnsBtn.addEventListener("click", (e) => {
				const panel = document.getElementById("listColumnsPanel");
				if (!panel) return;
				const isVisible = panel.style.display === "block";
				if (!isVisible) {
					renderListColumnsPanel();
					const rect = toggleListColumnsBtn.getBoundingClientRect();
					panel.style.position = "absolute";
					panel.style.top = rect.bottom + 6 + "px";
					panel.style.left = rect.left + "px";
				}
				panel.style.display = isVisible ? "none" : "block";
				const onDocClick = (ev) => {
					const within = panel.contains(ev.target) || toggleListColumnsBtn.contains(ev.target);
					if (!within) {
						panel.style.display = "none";
						document.removeEventListener("click", onDocClick);
					}
				};
				document.addEventListener("click", onDocClick);
			});
		}
		async function discoverMetadataKeys() {
			// Scan current video list (up to 50) for ffprobe keys
			const vids = (lastListDataCache || []).slice(0, 50);
			const found = new Set(discoveredMetaKeys);
			for (const v of vids) {
				const raw = await ensureMetadata(v.path);
				if (!raw) continue;
				function walk(obj, prefix) {
					if (obj == null) return;
					if (Array.isArray(obj)) {
						obj.forEach((item, i) => walk(item, `${prefix}[${i}]`));
					}
					else if (typeof obj === 'object') {
						for (const k of Object.keys(obj)) {
							const np = prefix ? `${prefix}.${k}` : k;
							const val = obj[k];
							if (val && typeof val === 'object') walk(val, np);
							else if (np) found.add(np);
						}
					}
					else {
						if (prefix) found.add(prefix);
					}
				}
				walk(raw, '');
			}
			discoveredMetaKeys = new Set(Array.from(found).filter(k => !!k && typeof k === 'string' && k.trim().length > 0));
			return found;
		}
		
		load();
	</script>
</body>

</html>